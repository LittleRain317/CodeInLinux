============================第一章导论==========================
不同应用领域决定了操作系统不同的特点:eg,关注便捷，关注高效，兼容两者..
从用户角度来看操作系统：不同需求决定了操作系统的不同特点
从操作系统角度来看，属于资源分配器，控制程序

比较公认的定义是：操作系统是一直运行在计算机上面的程序（内核）

移动操作系统通常不只有内核还有中间件（middleware)（为应用程序开发人员提供的软件框架)

CPU和设备控制器可以并发执行，并且竞争内存(RAM)

开机过程:
MBR中存在引导程序（位于计算机固件(ROM或EEPROM))它初始化系统的各个组件，负责定位操作系统内核所在并且加载到内存(在此操作之前检查硬件状态),系统程序在启动时加载到内存而变成系统进程或系统后台程序（daemon),对于unix，首个系统进程是init,它启动其他后台程序，一旦完成系统就完全启动了

中断:当cpu被中断时，停止目前的事情立马跳转到包含中断程序的起始地址
事件发生通常通过硬件(调用系统总线发送信号到cpu)或软件中断(使用系统调用)来通知。
中断属于计算机体系结构的重要组成，一般是调用一个通用进程来检查中断程序（率先在低地址内存（100之内）保留各个设备的中断处理程序地址)当发生中断时率先将程序地址保留到系统栈里面，中断处理完后，重新加在该地址到PC

经典冯诺依曼体系，取指令（从内存取走指令保存到指令寄存器），翻译指令（解码），执行指令

操作系统为每个设备控制器(操作硬件,当设备控制器完成操作后产生中断来告知驱动程序完成了该操作)提供一个驱动程序（但是该程序一般由硬件厂商完成），该驱动程序负责为操作系统的其他部分提供统一的设备访问接口(Linux没有应用层层次上的图形操作，需要直接操作驱动程序来完成图形编程)

---------------------------------计算机系统的体系结构（本书按照通用处理器的数量)-----------------------
单处理器系统:只有一个通用处理器，但是每个设备可能内部集成了一个专用处理器（当通用处理器发生请求时响应请求,执行完成传回数据给cpu)

多处理器系统(多个cpu或多核cpu)：增加吞吐量，经济（对于多个单处理器系统），增加容错性（一个坏了其他继续）
	------------非对称处理(主从关系，一个主处理器，其他是附属处理器）
	------------对称多处理（没有主从关系，共享内存)

---------------------------------计算机系统结构---------------------
1.多道程序设计:
	这些job首先保存在job pool（包括硬盘上的，等待分配内存的所有进程，内存的job pool为整个的一个子集)，当一个job需要等待的时候，cpu切换到下一个job，直到等待完成重新获取cpu
	-----------------
	|	操作系统	|
	-----------------
	|   job1		|
	-----------------
	|   job2 		|
	-----------------
分时系统在多道程序设计上增加了时间片，超时就切换为下一个job


--------------------------------双重模式和多重模式的执行-------------------------
至少需要两种单独运行的模式：用户模式 系统模式,发生中断时硬件的模式位由用户模式变成系统模式

支持虚拟化的cpu会有一个单独模式用于表示虚拟机管理器VMM是否正在控制系统（特权多于用户模式少于系统模式,因为需要改变cpu状态,一般创建虚拟机)

MS-DOS由于没有硬件的模式位支持导致无法构建两种运行模式，因此存在安全隐患，而现代操作系统和硬件提供了多种模式切换

------------定时器（用于强行中断应用程序返回给操作系统来决定是否继续该应用程序)----------------

CPU 寄存器 高速缓存 内存 外存《==数据传输

===========================================第二章:操作系统结构=======================
操作系统的服务:
1.用户界面(GUI,CMD,BAT(批处理))
2.程序执行
3.IO操作
4.文件系统操作
5.通信
6.错误检测
7.资源分配
8.记账(统计资源使用情况等)
9.保护与安全

系统调用的类型一般分为:
1.进程控制
2.文件管理
3.设备管理
4.信息维护
5.通信
6.保护(权限安全)

微处理器都有一个CPU模式称之为单步(CPU每执行一条执行都会产生一个陷阱,调试器会捕获到该陷阱)

通信:常用模型有两种
	1.消息传递模型(典型的CS模型)
	2.共享内存模型(通常情况操作系统需要阻止一个进程访问另外一个进程的内存)

系统程序:
	1.文件管理
	2.状态信息(Win操作系统具有注册表,linuxinode节点)
	3.文件修改
	4.编程语言支持
	5.程序加载与执行
	6.通信
	7.后台服务

机制:决定如何做
策略:决定是否做
------------------------单片(单内核)--------------------------
所有服务集成在内核中,优点是系统调用和内核通信的开销非常小,缺点难以实现与设计

------------------------微内核--------------------
从内核中删除所有不必要的部分，而将它们当做系统级与用户级的程序来实现

主要功能为客户端程序和运行在用户空间中的各种服务提供通信(消息传递模型)(增加了性能的损耗)

eg:	winNT首个版本采用分层的微内核架构，其性能不如win95

------------------------模块-----------------------
(现今可能的最佳方法)可加载(按需加载)的内核模块，无论在启动或运行时内核都可以通过模块链入额外服务

类似分层系统(但是更加灵活任何模块都可以使用其他模块)
类似微内核(但是更有效,不需要消息传递来通信)

主要是从运行效率方面考虑，一个单内核系统运行内部是一个大程序，主要依靠函数调用；微内核系统运行时，把文件系统，网络协议栈，大部分的进程管理功能作为服务进程在内核之外运行，这必然意味着大量的进程间通信；进程间通信和函数调用效率自然差得很远。但是，也应该注意到，Linux kernel尽管是单内核的形式，但并不意味着它完全无视了微内核的设计思想，模块机制就是微内核设计思想在Linux kernel中的体现。

------------------------故障分析--------------------
大多数操作系统会对一个发生故障的进程写入错误信息到日志文件也会进行core dump(计算机早期，内存叫做核心，保留进程在内存中的状态)

内核故障称之为崩溃，具有崩溃转储(crash dump,独立于文件系统放在硬盘的某个位置上)

-----------------------系统引导-------------------
加载内核以启动计算机的过程称之为系统引导

所有形式的ROM都是固件

当CPU收到一个重置事件时(上电开机或重启，指令寄存器会加载某个预先定义的内存地址(ROM中的引导程序,为了增加可修改性将引导写入到EPROM))

引导程序(MBR)->引导块代码(硬盘)->操作系统内核(硬盘)
















