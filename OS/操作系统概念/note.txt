============================第一章导论==========================
不同应用领域决定了操作系统不同的特点:eg,关注便捷，关注高效，兼容两者..
从用户角度来看操作系统：不同需求决定了操作系统的不同特点
从操作系统角度来看，属于资源分配器，控制程序

比较公认的定义是：操作系统是一直运行在计算机上面的程序（内核）

移动操作系统通常不只有内核还有中间件（middleware)（为应用程序开发人员提供的软件框架)

CPU和设备控制器可以并发执行，并且竞争内存(RAM)

开机过程:
MBR中存在引导程序（位于计算机固件(ROM或EEPROM))它初始化系统的各个组件，负责定位操作系统内核所在并且加载到内存(在此操作之前检查硬件状态),系统程序在启动时加载到内存而变成系统进程或系统后台程序（daemon),对于unix，首个系统进程是init,它启动其他后台程序，一旦完成系统就完全启动了

中断:当cpu被中断时，停止目前的事情立马跳转到包含中断程序的起始地址
事件发生通常通过硬件(调用系统总线发送信号到cpu)或软件中断(使用系统调用)来通知。
中断属于计算机体系结构的重要组成，一般是调用一个通用进程来检查中断程序（率先在低地址内存（100之内）保留各个设备的中断处理程序地址)当发生中断时率先将程序地址保留到系统栈里面，中断处理完后，重新加在该地址到PC

经典冯诺依曼体系，取指令（从内存取走指令保存到指令寄存器），翻译指令（解码），执行指令

操作系统为每个设备控制器(操作硬件,当设备控制器完成操作后产生中断来告知驱动程序完成了该操作)提供一个驱动程序（但是该程序一般由硬件厂商完成），该驱动程序负责为操作系统的其他部分提供统一的设备访问接口(Linux没有应用层层次上的图形操作，需要直接操作驱动程序来完成图形编程)

---------------------------------计算机系统的体系结构（本书按照通用处理器的数量)-----------------------
单处理器系统:只有一个通用处理器，但是每个设备可能内部集成了一个专用处理器（当通用处理器发生请求时响应请求,执行完成传回数据给cpu)

多处理器系统(多个cpu或多核cpu)：增加吞吐量，经济（对于多个单处理器系统），增加容错性（一个坏了其他继续）
	------------非对称处理(主从关系，一个主处理器，其他是附属处理器）
	------------对称多处理（没有主从关系，共享内存)

---------------------------------计算机系统结构---------------------
1.多道程序设计:
	这些job首先保存在job pool（包括硬盘上的，等待分配内存的所有进程，内存的job pool为整个的一个子集)，当一个job需要等待的时候，cpu切换到下一个job，直到等待完成重新获取cpu
	-----------------
	|	操作系统	|
	-----------------
	|   job1		|
	-----------------
	|   job2 		|
	-----------------
分时系统在多道程序设计上增加了时间片，超时就切换为下一个job


--------------------------------双重模式和多重模式的执行-------------------------
至少需要两种单独运行的模式：用户模式 系统模式,发生中断时硬件的模式位由用户模式变成系统模式
root相当于皇帝状态，普通用户平民状态，但无论如何这两个都是在人间（用户态）。内核态相当于玉帝状态默默掌控一切，另外求个雨啥的还得找玉帝（系统调用等等）。

支持虚拟化的cpu会有一个单独模式用于表示虚拟机管理器VMM是否正在控制系统（特权多于用户模式少于系统模式,因为需要改变cpu状态,一般创建虚拟机)

MS-DOS由于没有硬件的模式位支持导致无法构建两种运行模式，因此存在安全隐患，而现代操作系统和硬件提供了多种模式切换

------------定时器（用于强行中断应用程序返回给操作系统来决定是否继续该应用程序)----------------

CPU 寄存器 高速缓存 内存 外存《==数据传输

===========================================第二章:操作系统结构=======================
操作系统的服务:
1.用户界面(GUI,CMD,BAT(批处理))
2.程序执行
3.IO操作
4.文件系统操作
5.通信
6.错误检测
7.资源分配
8.记账(统计资源使用情况等)
9.保护与安全

系统调用的类型一般分为:
1.进程控制
2.文件管理
3.设备管理
4.信息维护
5.通信
6.保护(权限安全)

微处理器都有一个CPU模式称之为单步(CPU每执行一条执行都会产生一个陷阱,调试器会捕获到该陷阱)

通信:常用模型有两种
	1.消息传递模型(典型的CS模型)
	2.共享内存模型(通常情况操作系统需要阻止一个进程访问另外一个进程的内存)

系统程序:
	1.文件管理
	2.状态信息(Win操作系统具有注册表,linuxinode节点)
	3.文件修改
	4.编程语言支持
	5.程序加载与执行
	6.通信
	7.后台服务

机制:决定如何做
策略:决定是否做
------------------------单片(单内核)--------------------------
所有服务集成在内核中,优点是系统调用和内核通信的开销非常小,缺点难以实现与设计

------------------------微内核--------------------
从内核中删除所有不必要的部分，而将它们当做系统级与用户级的程序来实现

主要功能为客户端程序和运行在用户空间中的各种服务提供通信(消息传递模型)(增加了性能的损耗)

eg:	winNT首个版本采用分层的微内核架构，其性能不如win95

------------------------模块-----------------------
(现今可能的最佳方法)可加载(按需加载)的内核模块，无论在启动或运行时内核都可以通过模块链入额外服务

类似分层系统(但是更加灵活任何模块都可以使用其他模块)
类似微内核(但是更有效,不需要消息传递来通信)

主要是从运行效率方面考虑，一个单内核系统运行内部是一个大程序，主要依靠函数调用；微内核系统运行时，把文件系统，网络协议栈，大部分的进程管理功能作为服务进程在内核之外运行，这必然意味着大量的进程间通信；进程间通信和函数调用效率自然差得很远。但是，也应该注意到，Linux kernel尽管是单内核的形式，但并不意味着它完全无视了微内核的设计思想，模块机制就是微内核设计思想在Linux kernel中的体现。

------------------------故障分析--------------------
大多数操作系统会对一个发生故障的进程写入错误信息到日志文件也会进行core dump(计算机早期，内存叫做核心，保留进程在内存中的状态)

内核故障称之为崩溃，具有崩溃转储(crash dump,独立于文件系统放在硬盘的某个位置上)

-----------------------系统引导-------------------
加载内核以启动计算机的过程称之为系统引导

所有形式的ROM都是固件

当CPU收到一个重置事件时(上电开机或重启，指令寄存器会加载某个预先定义的内存地址(ROM中的引导程序,为了增加可修改性将引导写入到EPROM))

引导程序(MBR)->引导块代码(硬盘)->操作系统内核(硬盘)

-----------------经验--------------
strace工具用于查看应用程序所使用的系统调用

在编写内核模块时可以使用内核函数

lsmod命令来列举当前所使用的内核模块
//名称 大小 正在使用的模块

insmod 装载已经编译好的模块 rmmod 删除模块 dmesg查看日志缓冲区


=====================第三章:进程============================
进程的内存结构
	------------------
	|	栈内存		 |
	|----------------|
	|		|		 |
	|		j        |
	|	             |
	|		|		 |
	|		k		 |
	|----------------|
	|	堆内存       |
	|----------------|
	|	.data .bss   |
	|----------------|
	|    .txt        |
	------------------

进程本身可以作为一个环境用于执行其他代码:eg: bash JVM

-----------------进程状态-----------------------
新的:进程正在创建
运行:指令正在执行
等待:进程等待某个事件的发生
就绪:进程等待分配处理器
终止:进程已经完成执行


IO或事件完成<等待(IO或事件的等待)<--|
		|							|
		|							|
新的->就绪------(调度器调度)----->执行------>终止
		|							|
		<-------(中断)--------------|



-----------------进程控制块---------------------
struct task_struct {
/* these are hardcoded - don't touch */
	long state;	/* -1 unrunnable, 0 runnable, >0 stopped */ //进程状态信息
	long counter;
	long priority; //优先级
	long signal;
	struct sigaction sigaction[32]; //可能的检查或修改处理信号的handler
	long blocked;	/* bitmap of masked signals */ //屏蔽信号
/* various fields */
	int exit_code; //_exit(code)
	unsigned long start_code,end_code,end_data,brk,start_stack;
	long pid,father,pgrp,session,leader;
	unsigned short uid,euid,suid;
	unsigned short gid,egid,sgid;
	long alarm; //定时器
	long utime,stime,cutime,cstime,start_time;
	unsigned short used_math;
/* file system info */
	int tty;		/* -1 if no tty, so it must be signed */
	unsigned short umask;
	struct m_inode * pwd;
	struct m_inode * root;
	struct m_inode * executable;
	unsigned long close_on_exec; //是否使用close() fd文件状态描述符
	struct file * filp[NR_OPEN];
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
	struct desc_struct ldt[3];
/* tss for this task */
	struct tss_struct tss;
};
//0.11内核源码

----------------------进程调度----------------------
进程调度通常使用队列图来表示
----->就绪队列---------------------------------------------------->CPU----------->
		|															--------
		|																	|
		|																	|
		|<------IO <-----IO队列	<-------------------IO请求 <----------------|
		|																	|
		|																	|
		|--------------------------------------<时间片已经过期<-------------|
		|																	|
		|<--子进程结束<-----------------等待子进程结束<---------------------|
		|																	|
		|<------中断发生<---------------等待中断<---------------------------|

IO请求 等待子进程结束 等待中断-->进程进入等待状态

--------------------调度程序-------------------------
进程一般可能分为CPU密集型和IO密集型，长度调度程序应该适量组合两种进程以防止IO或CPU没有处理进程导致的资源浪费

长期调度程序或作业调度程序会从硬盘的作业池中选择进程加载到内存中

短期调度程序或CPU调度程序，从准备执行的进程中选择进程并分配CPU

中期调度程序将进程从内存中或cpu中换出

切换CPU到另一个进程需要保存进程状态和恢复另一个进程的状态，这个任务叫做上下文切换(CPU寄存器的值，进程状态(新的，就绪，执行，等待，终止),内存管理信息,文件IO，参考task_struct结构)

-----------------------进程运行------------------------------------
红黑树结构，采用pid标识

子进程可以从操作系统中直接获取资源也可以从父进程中获取资源

------------------------进程结束--------------------
如果终止子进程，则父进程需要知道这些子进程的标识符，因此当一个进程创建新进程时，新创建的进程的标识符要传递到父进程中

有些操作系统不允许子进程在父进程已终止的情况下存在，对于这类操作系统，如果一个进程终止那么它的所有子进程都会终止，这种现象叫做级联终止

而Linux则当父进程没有调用wait时父进程就结束了，子进程会由pid=1的进程接管（该子进程叫做孤儿进程)

而父进程没有执行wait但子进程已经结束了，该子进程叫做僵尸进程(子进程的进程表项没有释放，导致新的进程的pid只能在该子进程之后)

-----------------------进程间通信---------------------
两种模型:共享内存(一旦创建以后，和普通内存无异)和消息传递

对于共享内存所有的访问都可以作为常规内存访问，无需借助内核

----------------------共享内存系统----------------------
通常一片共享内存区域驻留在创建共享内存段的进程地址空间内(谁创驻留在谁的内存中)
其他希望使用该共享内存的进程应该将其附加到自己的地址空间
(进程负责确保数据的有效性，它们不应该向同一个位置同时写入数据)

----------------------消息传递系统----------------------
直接通信:
	需要通信的每个进程必须明确指定通信的接受者或发送者
	逻辑通信链路的属性:
	在需要通信的每对进程之间，自动建立链路，进程仅需要知道对方身份可以进行交流
	每个链路只有两个进程相关
	每对进程之间只有一个链路
	变形:
		发送者指定接受者，而接受者不需要指定发送者

	缺点:更改进程的标识符可能需要分析其他进程的定义


间接通信:
	通过端口来发送和接受消息
	逻辑通信链路的属性:
	只有在两个进程共享一个端口时才能建立通信链路
	一个链路可以与两个或更多进程相关
	两个通信进程之间可以有多个链路，每条链路使用同一个端口

-------------------------同步---------------------------
阻塞或非阻塞(同步或异步)

---------------------缓存--------------------------
通信进程交换的信息总是驻留在临时队列中
队列实现有:
	零容量(队列的最大长度为0，发送者应该阻塞直到接受者接收到消息)
	有限容量(长度为n，如果队列慢，则发送者阻塞)
	无限容量(发送者从不阻塞)

------------------C/S通信----------------
1.套接字
2.远程过程调用(RPC)
3.管道

------------------远程过程调用----------------
RPC通信交换的消息具有明确结构，因此不再仅仅是数据包
消息包含:执行函数的一个标识符以及传递给该函数的一些参数，然后函数按照要求来执行，而所有结果会通过另一个消息，传递回请求者

通过客户端提供的存根stub(该存根定位服务器的端口并且封装参数)，RPC系统隐藏通信细节

对于PRC因为网络问题可能执行失败或多次重复执行，解决该问题的方法是操作系统确保只执行一次而不是最多执行一次

最多一次:(增加时间戳，超过该时间忽略)

正好一次执行:在最多一次的基础上增加ACK确认消息



客户端如何知道服务器上面的端口:
1.预留端口
2.绑定通过交会机制动态进行（服务器在预留RPC端口上提供交会服务程序),客户通过该端口获取服务器的端口号,然后发送RPC消息

RPC可以实现分布式文件系统

------------------管道-------------------
设计管道应该考虑四个问题:
1.管道允许单向通信还是双向通信
2.管道如果是双向的那么是全双工(数据在同一时间内可以在两个方向上传输),半双工
3.通信进程是否应该具有一定的关系(eg父子)
4.管道通信能否通过网络，还是只能在本地进行

---------普通管道---------------
单向通信
UNIX: pipe(int fd[])//fd[0]读 fd[1]写

一般父进程创建普通管道和子进程通信


!!!注意点:若一开始fork之后，双方没有关闭没有使用的一端，那么无法确保父进程写入端关闭后子进程能够检测到EOF
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define BUFFER_SIZE 25
#define READ_END 0
#define WRITE_END 1

int main(void)
{
	char write_msg[BUFFER_SIZE] = "Greetings";
	char read_msg[BUFFER_SIZE];
	int fd[2];
	pid_t pid;
	if (pipe(fd) == -1)
	{
		perror("Pipe error");
		return 1;
	}
	pid = fork();
	if (pid < 0)
	{
		perror("fork error");
		return 1;
	}
	if (pid > 0)
	{
//		close(fd[READ_END]);
		write(fd[WRITE_END], write_msg, strlen(write_msg) + 1);
		close(fd[WRITE_END]);
	}
	else 
	{
//		close(fd[WRITE_END]);
		while (read(fd[READ_END], read_msg, BUFFER_SIZE))
			printf("read %s", read_msg);
		close(fd[READ_END]);
	}
	return 0;
}


------------------命名管道----------------
UNIX的命名管道:FIFO，类似普通文件直到被删除，可以允许多个进程读写，但是是半双工


