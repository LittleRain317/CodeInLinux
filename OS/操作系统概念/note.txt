============================第一章导论==========================
不同应用领域决定了操作系统不同的特点:eg,关注便捷，关注高效，兼容两者..
从用户角度来看操作系统：不同需求决定了操作系统的不同特点
从操作系统角度来看，属于资源分配器，控制程序

比较公认的定义是：操作系统是一直运行在计算机上面的程序（内核）

移动操作系统通常不只有内核还有中间件（middleware)（为应用程序开发人员提供的软件框架)

CPU和设备控制器可以并发执行，并且竞争内存(RAM)

开机过程:
MBR中存在引导程序（位于计算机固件(ROM或EEPROM))它初始化系统的各个组件，负责定位操作系统内核所在并且加载到内存(在此操作之前检查硬件状态),系统程序在启动时加载到内存而变成系统进程或系统后台程序（daemon),对于unix，首个系统进程是init,它启动其他后台程序，一旦完成系统就完全启动了

中断:当cpu被中断时，停止目前的事情立马跳转到包含中断程序的起始地址
事件发生通常通过硬件(调用系统总线发送信号到cpu)或软件中断(使用系统调用)来通知。
中断属于计算机体系结构的重要组成，一般是调用一个通用进程来检查中断程序（率先在低地址内存（100之内）保留各个设备的中断处理程序地址)当发生中断时率先将程序地址保留到系统栈里面，中断处理完后，重新加在该地址到PC

经典冯诺依曼体系，取指令（从内存取走指令保存到指令寄存器），翻译指令（解码），执行指令

操作系统为每个设备控制器(操作硬件,当设备控制器完成操作后产生中断来告知驱动程序完成了该操作)提供一个驱动程序（但是该程序一般由硬件厂商完成），该驱动程序负责为操作系统的其他部分提供统一的设备访问接口(Linux没有应用层层次上的图形操作，需要直接操作驱动程序来完成图形编程)

---------------------------------计算机系统的体系结构（本书按照通用处理器的数量)-----------------------
单处理器系统:只有一个通用处理器，但是每个设备可能内部集成了一个专用处理器（当通用处理器发生请求时响应请求,执行完成传回数据给cpu)

多处理器系统(多个cpu或多核cpu)：增加吞吐量，经济（对于多个单处理器系统），增加容错性（一个坏了其他继续）
	------------非对称处理(主从关系，一个主处理器，其他是附属处理器）
	------------对称多处理（没有主从关系，共享内存)

---------------------------------计算机系统结构---------------------
1.多道程序设计:
	这些job首先保存在job pool（包括硬盘上的，等待分配内存的所有进程，内存的job pool为整个的一个子集)，当一个job需要等待的时候，cpu切换到下一个job，直到等待完成重新获取cpu
	-----------------
	|	操作系统	|
	-----------------
	|   job1		|
	-----------------
	|   job2 		|
	-----------------
分时系统在多道程序设计上增加了时间片，超时就切换为下一个job


--------------------------------双重模式和多重模式的执行-------------------------
至少需要两种单独运行的模式：用户模式 系统模式,发生中断时硬件的模式位由用户模式变成系统模式
root相当于皇帝状态，普通用户平民状态，但无论如何这两个都是在人间（用户态）。内核态相当于玉帝状态默默掌控一切，另外求个雨啥的还得找玉帝（系统调用等等）。

支持虚拟化的cpu会有一个单独模式用于表示虚拟机管理器VMM是否正在控制系统（特权多于用户模式少于系统模式,因为需要改变cpu状态,一般创建虚拟机)

MS-DOS由于没有硬件的模式位支持导致无法构建两种运行模式，因此存在安全隐患，而现代操作系统和硬件提供了多种模式切换

------------定时器（用于强行中断应用程序返回给操作系统来决定是否继续该应用程序)----------------

CPU 寄存器 高速缓存 内存 外存《==数据传输

===========================================第二章:操作系统结构=======================
操作系统的服务:
1.用户界面(GUI,CMD,BAT(批处理))
2.程序执行
3.IO操作
4.文件系统操作
5.通信
6.错误检测
7.资源分配
8.记账(统计资源使用情况等)
9.保护与安全

系统调用的类型一般分为:
1.进程控制
2.文件管理
3.设备管理
4.信息维护
5.通信
6.保护(权限安全)

微处理器都有一个CPU模式称之为单步(CPU每执行一条执行都会产生一个陷阱,调试器会捕获到该陷阱)

通信:常用模型有两种
	1.消息传递模型(典型的CS模型)
	2.共享内存模型(通常情况操作系统需要阻止一个进程访问另外一个进程的内存)

系统程序:
	1.文件管理
	2.状态信息(Win操作系统具有注册表,linuxinode节点)
	3.文件修改
	4.编程语言支持
	5.程序加载与执行
	6.通信
	7.后台服务

机制:决定如何做
策略:决定是否做
------------------------单片(单内核)--------------------------
所有服务集成在内核中,优点是系统调用和内核通信的开销非常小,缺点难以实现与设计

------------------------微内核--------------------
从内核中删除所有不必要的部分，而将它们当做系统级与用户级的程序来实现

主要功能为客户端程序和运行在用户空间中的各种服务提供通信(消息传递模型)(增加了性能的损耗)

eg:	winNT首个版本采用分层的微内核架构，其性能不如win95

------------------------模块-----------------------
(现今可能的最佳方法)可加载(按需加载)的内核模块，无论在启动或运行时内核都可以通过模块链入额外服务

类似分层系统(但是更加灵活任何模块都可以使用其他模块)
类似微内核(但是更有效,不需要消息传递来通信)

主要是从运行效率方面考虑，一个单内核系统运行内部是一个大程序，主要依靠函数调用；微内核系统运行时，把文件系统，网络协议栈，大部分的进程管理功能作为服务进程在内核之外运行，这必然意味着大量的进程间通信；进程间通信和函数调用效率自然差得很远。但是，也应该注意到，Linux kernel尽管是单内核的形式，但并不意味着它完全无视了微内核的设计思想，模块机制就是微内核设计思想在Linux kernel中的体现。

------------------------故障分析--------------------
大多数操作系统会对一个发生故障的进程写入错误信息到日志文件也会进行core dump(计算机早期，内存叫做核心，保留进程在内存中的状态)

内核故障称之为崩溃，具有崩溃转储(crash dump,独立于文件系统放在硬盘的某个位置上)

-----------------------系统引导-------------------
加载内核以启动计算机的过程称之为系统引导

所有形式的ROM都是固件

当CPU收到一个重置事件时(上电开机或重启，指令寄存器会加载某个预先定义的内存地址(ROM中的引导程序,为了增加可修改性将引导写入到EPROM))

引导程序(MBR)->引导块代码(硬盘)->操作系统内核(硬盘)

-----------------经验--------------
strace工具用于查看应用程序所使用的系统调用

在编写内核模块时可以使用内核函数

lsmod命令来列举当前所使用的内核模块
//名称 大小 正在使用的模块

insmod 装载已经编译好的模块 rmmod 删除模块 dmesg查看日志缓冲区


=====================第三章:进程============================
进程的内存结构
	------------------
	|	栈内存		 |
	|----------------|
	|		|		 |
	|		j        |
	|	             |
	|		|		 |
	|		k		 |
	|----------------|
	|	堆内存       |
	|----------------|
	|	.data .bss   |
	|----------------|
	|    .txt        |
	------------------

进程本身可以作为一个环境用于执行其他代码:eg: bash JVM

-----------------进程状态-----------------------
新的:进程正在创建
运行:指令正在执行
等待:进程等待某个事件的发生
就绪:进程等待分配处理器
终止:进程已经完成执行


IO或事件完成<等待(IO或事件的等待)<--|
		|							|
		|							|
新的->就绪------(调度器调度)----->执行------>终止
		|							|
		<-------(中断)--------------|



-----------------进程控制块---------------------
struct task_struct {
/* these are hardcoded - don't touch */
	long state;	/* -1 unrunnable, 0 runnable, >0 stopped */ //进程状态信息
	long counter;
	long priority; //优先级
	long signal;
	struct sigaction sigaction[32]; //可能的检查或修改处理信号的handler
	long blocked;	/* bitmap of masked signals */ //屏蔽信号
/* various fields */
	int exit_code; //_exit(code)
	unsigned long start_code,end_code,end_data,brk,start_stack;
	long pid,father,pgrp,session,leader;
	unsigned short uid,euid,suid;
	unsigned short gid,egid,sgid;
	long alarm; //定时器
	long utime,stime,cutime,cstime,start_time;
	unsigned short used_math;
/* file system info */
	int tty;		/* -1 if no tty, so it must be signed */
	unsigned short umask;
	struct m_inode * pwd;
	struct m_inode * root;
	struct m_inode * executable;
	unsigned long close_on_exec; //是否使用close() fd文件状态描述符
	struct file * filp[NR_OPEN];
/* ldt for this task 0 - zero 1 - cs 2 - ds&ss */
	struct desc_struct ldt[3];
/* tss for this task */
	struct tss_struct tss;
};
//0.11内核源码

----------------------进程调度----------------------
进程调度通常使用队列图来表示
----->就绪队列---------------------------------------------------->CPU----------->
		|															--------
		|																	|
		|																	|
		|<------IO <-----IO队列	<-------------------IO请求 <----------------|
		|																	|
		|																	|
		|--------------------------------------<时间片已经过期<-------------|
		|																	|
		|<--子进程结束<-----------------等待子进程结束<---------------------|
		|																	|
		|<------中断发生<---------------等待中断<---------------------------|

IO请求 等待子进程结束 等待中断-->进程进入等待状态

--------------------调度程序-------------------------
进程一般可能分为CPU密集型和IO密集型，长度调度程序应该适量组合两种进程以防止IO或CPU没有处理进程导致的资源浪费

长期调度程序或作业调度程序会从硬盘的作业池中选择进程加载到内存中

短期调度程序或CPU调度程序，从准备执行的进程中选择进程并分配CPU

中期调度程序将进程从内存中或cpu中换出

切换CPU到另一个进程需要保存进程状态和恢复另一个进程的状态，这个任务叫做上下文切换(CPU寄存器的值，进程状态(新的，就绪，执行，等待，终止),内存管理信息,文件IO，参考task_struct结构)

-----------------------进程运行------------------------------------
红黑树结构，采用pid标识

子进程可以从操作系统中直接获取资源也可以从父进程中获取资源

------------------------进程结束--------------------
如果终止子进程，则父进程需要知道这些子进程的标识符，因此当一个进程创建新进程时，新创建的进程的标识符要传递到父进程中

有些操作系统不允许子进程在父进程已终止的情况下存在，对于这类操作系统，如果一个进程终止那么它的所有子进程都会终止，这种现象叫做级联终止

而Linux则当父进程没有调用wait时父进程就结束了，子进程会由pid=1的进程接管（该子进程叫做孤儿进程)

而父进程没有执行wait但子进程已经结束了，该子进程叫做僵尸进程(子进程的进程表项没有释放，导致新的进程的pid只能在该子进程之后)

-----------------------进程间通信---------------------
两种模型:共享内存(一旦创建以后，和普通内存无异)和消息传递

对于共享内存所有的访问都可以作为常规内存访问，无需借助内核

----------------------共享内存系统----------------------
通常一片共享内存区域驻留在创建共享内存段的进程地址空间内(谁创驻留在谁的内存中)
其他希望使用该共享内存的进程应该将其附加到自己的地址空间
(进程负责确保数据的有效性，它们不应该向同一个位置同时写入数据)

----------------------消息传递系统----------------------
直接通信:
	需要通信的每个进程必须明确指定通信的接受者或发送者
	逻辑通信链路的属性:
	在需要通信的每对进程之间，自动建立链路，进程仅需要知道对方身份可以进行交流
	每个链路只有两个进程相关
	每对进程之间只有一个链路
	变形:
		发送者指定接受者，而接受者不需要指定发送者

	缺点:更改进程的标识符可能需要分析其他进程的定义


间接通信:
	通过端口来发送和接受消息
	逻辑通信链路的属性:
	只有在两个进程共享一个端口时才能建立通信链路
	一个链路可以与两个或更多进程相关
	两个通信进程之间可以有多个链路，每条链路使用同一个端口

-------------------------同步---------------------------
阻塞或非阻塞(同步或异步)

---------------------缓存--------------------------
通信进程交换的信息总是驻留在临时队列中
队列实现有:
	零容量(队列的最大长度为0，发送者应该阻塞直到接受者接收到消息)
	有限容量(长度为n，如果队列慢，则发送者阻塞)
	无限容量(发送者从不阻塞)

------------------C/S通信----------------
1.套接字
2.远程过程调用(RPC)
3.管道

------------------远程过程调用----------------
RPC通信交换的消息具有明确结构，因此不再仅仅是数据包
消息包含:执行函数的一个标识符以及传递给该函数的一些参数，然后函数按照要求来执行，而所有结果会通过另一个消息，传递回请求者

通过客户端提供的存根stub(该存根定位服务器的端口并且封装参数)，RPC系统隐藏通信细节

对于PRC因为网络问题可能执行失败或多次重复执行，解决该问题的方法是操作系统确保只执行一次而不是最多执行一次

最多一次:(增加时间戳，超过该时间忽略)

正好一次执行:在最多一次的基础上增加ACK确认消息



客户端如何知道服务器上面的端口:
1.预留端口
2.绑定通过交会机制动态进行（服务器在预留RPC端口上提供交会服务程序),客户通过该端口获取服务器的端口号,然后发送RPC消息

RPC可以实现分布式文件系统

------------------管道-------------------
设计管道应该考虑四个问题:
1.管道允许单向通信还是双向通信
2.管道如果是双向的那么是全双工(数据在同一时间内可以在两个方向上传输),半双工
3.通信进程是否应该具有一定的关系(eg父子)
4.管道通信能否通过网络，还是只能在本地进行

---------普通管道---------------
单向通信
UNIX: pipe(int fd[])//fd[0]读 fd[1]写

一般父进程创建普通管道和子进程通信


!!!注意点:若一开始fork之后，双方没有关闭没有使用的一端，那么无法确保父进程写入端关闭后子进程能够检测到EOF
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>

#define BUFFER_SIZE 25
#define READ_END 0
#define WRITE_END 1

int main(void)
{
	char write_msg[BUFFER_SIZE] = "Greetings";
	char read_msg[BUFFER_SIZE];
	int fd[2];
	pid_t pid;
	if (pipe(fd) == -1)
	{
		perror("Pipe error");
		return 1;
	}
	pid = fork();
	if (pid < 0)
	{
		perror("fork error");
		return 1;
	}
	if (pid > 0)
	{
//		close(fd[READ_END]);
		write(fd[WRITE_END], write_msg, strlen(write_msg) + 1);
		close(fd[WRITE_END]);
	}
	else 
	{
//		close(fd[WRITE_END]);
		while (read(fd[READ_END], read_msg, BUFFER_SIZE))
			printf("read %s", read_msg);
		close(fd[READ_END]);
	}
	return 0;
}


------------------命名管道----------------
UNIX的命名管道:FIFO，类似普通文件直到被删除，可以允许多个进程读写，但是是半双工

=====================第四章:多线程编程===========================
优点:
	1.响应性
	2.资源共享
	3.经济
	4.可伸缩性

-------------------多核编程-----------------------
Amdahl定律
如果S是应用程序的一部分，它在具有N个处理核的系统上可以串行执行
		
	加速比<= 1 / (S + (1 - S) / N)

eg:75%并行 25%串行 两个处理核 则加速比<= 1 / (25% + 75% / 2) = 1.6倍


---------------多线程模型----------------------
用户级线程映射到内核级线程
1.多对一模型
2.一对一模型
3.多对多模型
	变种:
		允许多对多的同时具有一对一

---------------隐式多线程(无需自己管理线程)----------------------
1.线程池 2.OpenMP 3.大中央调度

---------------信号处理-------------------------
UNIX信号用于通知进程某个特定事件已经发生，信号的接收可以是同步的(eg:除以0，段错误)也可以异步(kill -9,Ctrl+C)的
但无论如何都遵循相同的模式:
	1.信号是由特定事件的发生而产生的
	2.信号被传递给某个进程
	3.信号一旦收到就应处理

信号处理可以分为两种:
1.系统默认
2.用户自定义

多线程信号处理:
1.传递信号到信号所使用的线程
2.传递信号到进程内的每一个线程
3.传递信号到进程内的某些线程
4.规定一个特定线程以接收进程的所有信号

------------------线程撤销-----------------------
在线程完成之前终止线程
1.异步撤销(一个线程立即终止目标线程)
2.延迟撤销(目标线程不断检查它是否应终止，这允许目标线程有机会有序终止自己

pthreads支持三种撤销模式
模式 				状态				类型
关闭				禁用				-
延迟				启用				延迟
异步				启用				异步

---------------------线程本地存储---------------
线程具有自己的某些数据不同于局部变量，在某些方面类似于静态变量

-----------------------------内核与线程库之间的通信---------------
在用户和内核之间增加一个数据结构:轻量级进程(LWP)(表现为虚拟处理器)

用户线程阻塞----------->触发回调事件----------->内核新启一个虚拟处理器接管，执行回调处理程序(保存之前线程状态，并释放之前的虚拟处理器，选择新线程执行)

用户线程等待的事件发生-------->触发另一回调事件----------->内核新启一个虚拟处理器或抢占一个用户线程执行回调处理程序

---------------------操作系统的实际例子---------------------
win线程:
	线程ID，寄存器组，用户堆栈，内核堆栈，私有存储区域(用于各种运行时库和动态链接库)

Linux线程:	
	不区分进程和线程，仅仅靠是否共享，共享哪些资源决定

	clone()
		标志:
			CLONE_FS 		共享文件系统信息
			CLONE_VM 		共享相同内存空间
			CLONE_SIGHAND	共享信号处理程序
			CLONE_FILES		共享一组打开文件


===================第5章进程调度======================
每当CPU空闲时，操作系统就应该从就绪队列(不必是FIFO，可以是FIFO，优先队列，树或简单的无序链表等)中选择一个进程来执行，采用短期调度程序

抢占影响了操作系统的内核涉及，有些操作系统对于系统调用不会进行上下文切换
//当CPL为0时表示内核态，内核态进程若本次CPU时间片使用完，不会进行进程调度(也就不会被抢占)
//而用户态进程当使用完本次CPU时间片时，会进行进程调度算法
void do_timer(long cpl) //每进行一次IRQ0则调用该函数处理时间中断
{
	extern int beepcount;
	extern void sysbeepstop(void);
	//some code
	current->counter=0; //当前进程在本次的CPU时间片使用完
	if (!cpl) return;  //内核态进程直接退出
	schedule();  //用户态进程开始进程调度
}

-----------------调度准则--------------------
CPU使用率
吞吐量
周转时间:从进程提交到进程完成的时间段
等待时间:在就绪队列中所花费的时间和
相应时间:在提交请求后到产生第一响应的时间

-----------------调度算法-------------------
1.先到先服务FCFS(First_Come First_Served)

2.最短作业优先调度(Shortest_job_First, SJF)(最短下次CPU执行,让CPU执行所需时间最短的一个进程)

抢占式的SJF称之为最短剩余时间优先(把进程剩余时间参与到其他进程所需时间的时间表中，选择最短)

如何预估下一次CPU执行时间:
	下次 CPU 执行通常预测为以前 CPU 执行的测量长度的指数平均。我们可以按下面的公式来计算指数平均。设 tn 为第 n 个 CPU 执行长度，设 τn+1 为下次 CPU 执行预测值。因此，对于 α， 0≤α≤1，定义：
	τn+1 = αtn + (1-α)τn //展开公式后说明了后面项的权重比前面项的权重小
	值 tn 包括最近信息，而 τn 存储了过去历史。参数 α 控制最近和过去历史在预测中的权重：
	如果 α = 0，那么 τn+1 = τn，最近历史没有影响（当前情形为瞬态）；
	如果 α = 1，那么 τn+1 = tn，只有最近 CPU 执行才重要（过去历史被认为是陈旧的、无关的）。
	更为常见的是 α = 1/2，这样最近历史和过去历史同样重要。初始值可作为常量或系统的总体平均值。

3.优先级调度
主要问题无穷阻塞或饥饿(低优先级进程一直被抢占)
	解决方案之一是老化(让低优先级进程经过一段时间后提升优先级)

4.轮转调度(RR Round_Robin)
性能很大程度取决于时间片大小

5.多级队列调度
进程通常分为前台进程和后台进程
多级队列调度将就绪队列分成多个单独队列，每个队列有自己的调度算法(eg:前台进程RR，后台进程FCFS)

可能的实现是
		1.每个队列与更低层队列具有绝对的优先(即优先级高的队列为空时才会让优先级低的队列运行)
		2.在队列之间划分时间片eg给前台进程80%时间片进行RR，后台进程20%进程FCFS

6.多级反馈队列调度
允许进程在多个队列之中切换
通常，多级反馈队列调度可由下列参数来定义:
1.队列数量
2.每个队列的调度算法(eg:RR and FCFS)
3.用以确定何时升级到更高优先级队列的方法(eg:等待时间过长)
4.用以确定何时降级到更低优先级队列的方法(eg:队列给定时间片内未完成)
5.用以确定进程在需要服务时将会进入哪一个队列的方法(eg:下一次CPU执行时间预测)

------------------------------线程调度---------------------------------
1.竞争范围
用户级线程(线程库提供)与内核级线程(操作系统所调度，实际上运行的线程)的区别在于它们是如何调度的

进程竞争范围(Process-Contention Scope,PCS):决定哪一个用户级线程可以在轻量级进程(LWP)上运行(竞争只发生在映射到LWP的用户级线程之间)
系统竞争范围(System-Contention Scope,SCS):决定哪一个内核线程真正在CPU上执行(竞争发生在所有的内核级线程)

---------------pthreads调度----------------
PTHREAD_SCOPE_PROCESS:按PCS来调度线程(可能的实现是采用优先级调度算法),调度用户线程到可用LWP
PTHREAD_SCOPE_SYSTEM:按SCS来调度线程,会创建一个LWP，并将多对多系统的每个用户级线程绑定到LWP(实际采用一对一策略来映射线程)

#include <pthread.h>
int pthread_attr_setscope(pthread_attr_t *attr, int scope);
int pthread_attr_getscope(const pthread_attr_t *attr, int *scope);
Compile and link with -pthread.
//发生错误返回值非零

----------------------------------------多处理器调度-----------------------------------------
以上调度主要集中于单处理器系统上面的调度，如果有多个CPU，则负载分配load sharing成为可能

对于多处理器系统具有两种CPU调度
	1.对称多处理，每个处理器自我调度
	2.非对称多处理，让一个处理器处理所有调度，IO处理以及其它系统活动，其他处理器只能执行用户代码

-----------------------处理器亲和性------------------
为了避免缓存的无效或者重新填充的成本高，大多数SMP系统试图避免将一个进程从一个处理器(该处理器的缓存无效)移动到另一个处理器(该处理器的缓存需要用src一个处理器的缓存填充)，而是试图让一个进程运行在同一个处理器上这叫做处理器亲和性(即一个进程对它运行的处理器具有亲和性)

软亲和性:操作系统试图保持一个进程在同一处理器上(不保证它会这么做)

硬亲和性（affinity）：简单来说就是利用linux内核提供给用户的API，强行将进程或者线程绑定到某一个指定的cpu核运行。
		在 Linux 内核中，所有的进程都有一个相关的数据结构，称为 task_struct 。这个结构非常重要，原因有很多；其中与 亲和性（affinity）相关度最高的是cpus_allowed 位掩码。这个位掩码由n位组成，与系统中的n个逻辑处理器一一对应。 具有 4 个物理 CPU 的系统可以有 4 位。如果这些 CPU 都启用了超线程，那么这个系统就有一个 8 位的位掩码。

		如果为给定的进程设置了给定的位，那么这个进程就可以在相关的 CPU 上运行。因此，如果一个进程可以在任何 CPU 上运行，并且能够根据需要在处理器之间进行迁移，那么位掩码就全是 1。实际上，这就是 Linux 中进程的缺省状态。

		Linux 内核 API 提供了一些方法，让用户可以修改位掩码或查看当前的位掩码：

	sched_setaffinity, sched_getaffinity - set and get a thread's CPU affinity mask
		   #define _GNU_SOURCE             /* See feature_test_macros(7) */
		   #include <sched.h>
		   int sched_setaffinity(pid_t pid, size_t cpusetsize,
								 const cpu_set_t *mask);
		   int sched_getaffinity(pid_t pid, size_t cpusetsize,
								 cpu_set_t *mask);

NUMA,即Non-Uniform Memory Access Architecture，非统一内存访问架构。NUMA模式是一种分布式存储器访问方式，处理器可以同时访问不同的存储器地址，大幅度提高并行性。NUMA模式下，处理器被划分成多个"节点"（node），每个节点被分配有的本地存储器空间。所有节点中的处理器都可以访问全部的系统物理存储器，但是访问本节点内的存储器所需要的时间，比访问某些远程节点内的存储器所花的时间要少得多。

-------------------负载平衡------------------
负载平衡load balance是为了将负载平均分配到SMP系统上的所有处理器
为了负载平衡有两种推迁移(push migration)和拉迁移(pull migration)(但是会破坏CPU亲和性)

---------------------多核处理器---------------------
当一个处理器访问内存时，会发费大量时间等待所需数据，这种情况称之为内存停顿(memory stall)
原因有:eg缓存未命中(访问数据不在缓存中)

x核m线程处理器
x个核心，m个硬件线程  对于操作系统来说一共有x*m个逻辑处理器

eg:
				C计算周期 M内存停顿周期
	硬件线程1      ----------------->CMCMCMCMC
	硬件线程2      ---------------->CMCMCMCMCM
		 双线程CPU

    打个比方，如果把硬件线程看作是泳道，那么软件线程就是在泳道中游泳的人。


一般来说处理器核心的多线程有两种方法:
	1.粗粒度
		
	2.细粒度

通常一个多核多线程CPU实际上需要两个不同级别的调度(整个计算机或许存在三个级别的调度:调度用户级线程 调度内核级线程 调度硬件线程)
	1.操作系统采用上述单核调度算法来选择某一个软件线程(系统级线程)运行在哪一个硬件线程(逻辑处理器)
	2.每个核心如何决定运行哪一个硬件线程(eg:轮转算法(增设时间片) eg:紧迫性比较)




