c:regex.h
c++:regex

===============第2章:匹配单个字符============================
1.匹配普通文本(一般情况是只会返回首个匹配结果)
2.匹配任意字符
	1. 字符. 匹配任意一个字符
3.转义字符(转移元字符(有特殊含义的字符)):
	\特殊字符
	eg:\.

==============第3章:匹配一组字符==========================
1.匹配多个字符中的某一个
	[str] : 匹配str中任意一个字符

2.利用字符集区间(注意首的ASCII码小于尾部的ASCII码)(字符区间里面的元字符和普通文字没有区别)
	eg:[a-z]

3.排除区间
	eg:[^a-z]

==============第4章:使用元字符======================
1.匹配空白字符(vim中使用/可以搜索)
元字符
[\b]            回退一个字符 (为了与单词边界区别因此需要加上[])
\f              换页符号
\n              换行符号
\r              回车符号
\t              制表符
\v              垂直制表符

2.匹配特定的字符类型
	1.数字与非数字
		\d 等价于[0-9]
		\D 等价于[^0-9]
	2.字母数字下划线与非字母数字下划线
		\w  [a-zA-Z0-9_]
		\W  [^a-zA-Z0-9_]
	3.匹配空白字符与非空白字符
		\s [\f\n\r\t\v]
		\S [^\f\n\r\t\v]

	4.匹配十六进制或八进制(极少使用)
		\x0A等价于\n
		\011等价于\t


3.使用POSIX字符集
!!!:注意在实际使用时需要再加一层[]表示定义一个字符集    eg:[[:alnum:]]
	[:alnum:]        [a-zA-Z0-9]  \w
	[:alpha:]        [a-zA-Z]
	[:blank:]        [\t ](有空格)
	[:cntrl:]        0-31和127的ASCII码(控制字符)
	[:digit:]        [0-9]		\d
	[:graph:]        与[:print:](任何一个可打印的字符)一样,但是去除空格
	[:lower:]        [a-z]
	[:punct:]        既不属于[:alnum:]也不属于[:cntrl:]的任意一个字符
	[:space:]        [\f\n\r\t\v ](有空格)
	[:upper:]        [A-Z]
	[:xdigit:]       [a-fA-F0-9]  十六进制

====================第5章:重复匹配==============================
1.匹配一个或多个字符(+)
ch+(匹配ch至少一次,ch为单个字符)

2.匹配零个或多个字符(*)
ch*(匹配ch 零次或零次以上)

3.匹配零个或一个字符(?)
ch?(匹配ch 零次或一次)

4.具体的重复匹配
ch{n}  匹配ch n次
ch{n,} 匹配ch n次及其n次以上
ch{n1,n2} 匹配ch n1至n2次

5.防止过度匹配
注意+,*,{n,}都是属于贪婪型量词(尽可能多的匹配字符)
	在这些模式后面加?表示懒惰型量词(尽可能少的匹配字符) 

=======================第6章:位置匹配==========================
1.单词边界\b(含义一边是\w另外一边是\W的位置)
	\B(两边都是\w或者都是\W)

2.字符串边界 (!!注意点:通常匹配字符串的首尾位置，但是可以用(?m)来开启多行模式，来要求正则表达式以\n来视为字符串分割符号)
				但不是所有的正则表达式引擎都支持(?m)
^str$


=======================第7章:子表达式===========================
(regexp)构成子表达式

(rege1(regex2)) 

!!:注意|元字符的截断效果
	rege1|rege2 一旦rege1符合则无视rege2

=======================第8章:反向引用====================
反向引用指的是这些实体引用的是先前的子表达式(只能用括号括起来的子表达式)
eg:
	str: of of of temp
	regex: [ ]+(\w+)[ ]+\1
		\1指的是匹配与(\w+)一致的字符串
			eg:(\w+)的结果为of 则\1为of


反向引用通常从1开始计数\1 \2等等，在许多实现里\0表示整个正则表达式

正则表达式替换:
	格式标志
	ECMAScript 格式规则	sed 格式规则	替换文本
	“$&”					"&"	    与整个正则表达式相匹配的字符序列 ([match[0].first, match[0].second))
	"$$"				 				"$"
							"\&			"&"
	"$`" (美元符号后跟后引号)		与正则表达式相匹配的子序列之前的字符序列 ([match.prefix().first, match.prefix().second))
	“$'”（美元符号后跟正撇号）		与正则表达式相匹配的子序列之后的字符序列 ([match.suffix().first, match.suffix().second))
	“$n”					“\n”	在位置n与捕获组相匹配的字符序列, 其中n是一个介于0到9之间的[match[n].first, match[n].second)数字 ()
							"\\n"					“\n”
	“$nn”							在位置nn与捕获组相匹配的字符序列, 其中nn是一个介于10和 99 ([match[nn].first, match[nn].second)) 之间的数字
	

eg:

#include <string>
#include <iostream>
#include <regex>
#include <fstream>
using namespace std;
void read(string & str)
{
	ifstream ifile("temp.txt");
	while (!ifile.eof())
	{
		string temp;
		getline(ifile, temp);
		temp += "\n";
		str += temp;
	}
	str.pop_back();
	ifile.close();
}
int main()
{
	string str;
	read(str);
	string regexp;
	getline(cin, regexp);
	regex rege;
	rege = regexp;
	cout << "要匹配的字符串:\n" << str;
	cout << "正则表达式:\n" << regexp;
	string repla;
	getline(cin, repla);
	cout << "要替换的字符串:\n" << repla;  //repla: ($1) $3-$5

	cout << "结果:\n" << regex_replace(str, rege, repla);
	return 0;
}

------------大小写转换(c++ ECMAScript视乎不支持)--------------------
\E 结束\L或\U转换
\l 把下一个字符转换为小写
\L 把\L到\E之间的字符全部转换为小写
\u 把下一个字符转换为大写
\U 把\U到\E之间的字符全部转换为大写

-----------第9章:环视---------------------------
1.向前查看(也有文档使用消耗来表示匹配和返回文本的含义,向前查看不消耗所匹配的文本)
(?=str)
表示匹配后面含有str，但是实际的匹配结果不包括str

2.向后查看(不一定支持)
(?<=str) 
表示匹配前面含有str


