ARM工具 kcil ADS

------------------------第一章 ARM(Advanced RISC(Reduced Instruction Set Computing RISC精简指令集) Machines)概述及其基本编程模型------------------------

load 存储器->寄存器
store 寄存器->存储器


CPU模式:
		(非特权模式) (特权模式)
		user          sys (以及异常模式)

--------------------------ARM寄存器-------------------------------------------------------------------
37个(31个通用寄存器(R0-R15(R15为PC程序计数器)) 6个状态寄存器(CPSR+ SPSR(5种异常))

通用寄存器:
	1.未备份(R0-R7)
	2.备份寄存器(R8-R14)
	3.程序计数器(PC)

R13 : SP(stack pointer)
R14	: LR(link register)(存放子程序的返回地址)
R15 : PC(下一条指令的地址)

CPSR(当前程序状态寄存器):
	CPSR的值对应程序状态:
		N(是否负数)Z(是否为0)C(是否存在进位或借位)V(是否溢出)Q DNM(RAZ) I(是否允许中断)F(是否允许中断)T(T指令还是ARM指令) M4 M3 M2 M1 M0
		....  预留	   ...
		小写时表示状态位的值为0
		大写时表示状态位的值为1	

----------------------------




=====================第2章:ARM指令======================
指令格式:   <opcode>{<cond>}{S} <Rd>,<Rn>{,<opcode2>}

       其中，<>内的项是必须的，{}内的项是可选的，如<opcode>是指令助记符，是必须的，而{<cond>}为指令执行条件，是可选的，如果不写则使用默认条件AL(无条件执行)。

       opcode  指令助记符，如LDR，STR 等

       cond  执行条件，如EQ，NE 等

       S  是否影响CPSR 寄存器的值，书写时影响CPSR，否则不影响

       Rd  目标寄存器

       Rn  第一个操作数的寄存器

       shifter_operand2  第二个操作数
			1.立即数方式(高级语言的数值字面值): #num(注意开头的#)
			2.寄存器方式: r[0-15]
			3.寄存器移位方式:  r1 ,(移位运算) [#num | r0...]

指令实际编码:cond(高四位)   shifter_operand(低12位,采用(循环右移加8位立即数算法)表示32位立即数) 

------------条件码cond--------------------
16个条件

------------ARM指令的寻址方式----------------
1.立即寻址eg:
操作数包含在32位指令编码里,只要取出指令就可以得到立即数
立即数尽管32位，但实际存储只用12位来存储采用(循环右移(右移的个数除以2实际存储,因此移动的位数一定是偶数)加8位立即数(框住两个最大间隔'1')算法)表示32位立即数
		   0x0000 F200
		   0000...      [1111 0010] 0000 0000
		   				实际存储    1111 0010
							1111 0010 >> 24(24/2存储) 来表示0x0000 F200
							CF2
eg:
//0x102   //0000 0000..  0001 0000 0010
//0x103   //0000 0000..  0001 0000 0011
//0x104   //0000 0000..  00[01 0000 01]00  为合法立即数 0100 0001 >> 30 F41
//0x12800 //0000 0000... 00[01 0010 10]00 0000 0000
若按位取反也可以保存的话，那么也合法属于有效数，编译器会自动转化为按位取反助记符


2.寄存器寻址
操作数是寄存器方式

3.寄存器移位寻址
操作室是寄存器移位方式
	逻辑移位:(主要用于无符号) LSL LSR---------->特点:(补0，移出)
	算数移位:(主要用于有符号) ASL ASR---------->特点:(右移则一直补符号位,猜测左移则符号位保留,溢出的直接抛弃)
	循环移位:ROL ROR
	带扩展的循环移位(循环右移一位):RRX(C参与计算移动到最高位，最低位移到C)

--------字及其无符号字节的Load/Store指令的寻址方式
LDR把存储器的内容读入到寄存器
STR把寄存器的内容写到存储器

两部分组成基址,偏移量(立即数，寄存器，寄存器移位)

LDR{<cond>}{B}{T}<Rd>,<address_mode>
					 (基址寄存器+偏移量)

<address_mode>三种方式
	[r0, #1]//r0中的地址偏移#1
	[r0, #1]!//r0中的地址偏移#1,然后r0中的数据根据偏移量更新
	[r0],#1 //r0中的地址率先store或load，然后r0中的数据根据偏移量更新


