========================第1章:简介=========================
!!注意点:TCP是一个没有记录边界的字节流协议
因此在处理收发数据的边界时常常由应用层协议来决定（比如HTTPv1.0使用关闭连接 SMTP使用\r\n Sun远程过程调用（RPC)以及DNS在每个要发送的数据之前放置一个二进制的计数值来表示该记录的长度(TCP本身并不提供记录结束标志)

netstat命令
netstat [-atunlp]
--------|-a 目前系统上所有的连接、监听、socket都列出
--------|-t 列出tcp网络封包的数据
--------|-u 列出udp网络封包的数据
--------|-n 不以进程的服务名称，而以端口号显示
--------|-l 列出目前正在网络监听的程序
--------|-p 列出该网络服务的进程pid
--------|-i 提供网络接口信息
--------|-r 显示路由表

封包协议|接收队列|发送队列|本地ip和端口号|远程主机的ip和端口号|连接状态，创建（ESTABLISED）及监听（LISTEN）
Proto   | Recv-Q | Send-Q |Local Address |Foreign Address     |   State      
tcp        0      0 192.168.1.105:42776     211.159.235.143:http    TIME_WAIT  

socket file的输出栏有
Proto RefCnt(连接到此socket的数量) Flags       Type(确认连接STREAM与不需确认的DGRAM)       State(若CONNECTIED则表示多个进程之间已经连线创建)         I-Node   Path
unix  2      			   [ ]         DGRAM                  			  						             29510    /run/user/1000/systemd/notify

ifconfig 网络接口名字
显示每个网络接口的详细信息

=========================第2章:传输层TCP,UDP和SCTP(Stream Control Transmission Protocol)================
UDP是一个简单的、不可靠的数据报协议
TCP是一个复杂的、可靠的字节流协议
SCTP则比TCP提供更多的服务

-------------------------用户数据报协议UDP(User Datagram Protocol)----------------------

每个UDP数据报都有一个长度，如果一个数据报正确地到达目的地，则该数据报的长度将随着数据一道被传递给接收端应用进程（TCP则不相同)
UDP无连接:同一个UDP套接字可以发送一个数据给多个客户，也可以用一个UDP套接字从多个客户接受数据
面向连接与无连接是计算机网络诸多概念中的很重要的之一。所谓面向连接，是指通信双方在进行通信之前，要事先在双方之间建立起一个完整的可以彼此沟通的通道,这个通道也就是连接，在通信过程中，整个连接的情况一直可以被实时地监控和管理。而无连接的通信，就不需要预先建立起一个联络两个通信节点的连接来，需要通信的时候，发送节点就可以往“网络”上送出信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控，让该信息的传递在网上尽力而为地往目的地节点传送

-------------------------传输控制协议TCP(Transmission Control Protocol)-------------------
TCP连接:先与某个给定服务器进程建立一个连接，再跨该连接与该服务器进程交换数据，然后终止该连接
TCP可靠性:要求对方返回一个确认，如果没有收到确认，TCP就自动重传数据并等待更长时间，在多次重传失败后才放弃
TCP往返时间算法（RTT round-trip time)以便知道自己应该等待多长时间
TCP排序：给每一个字节关联一个序列号对发送的数据进行排序，如果数据乱序或重复则根据序列号进行筛选重新排列
TCP流量控制：告知对方在任何时刻它一次能够从对方接受多少字节的数据（通告窗口（advertised window）），该窗口动态变化
TCP双全工（full-duplex):在连接后任何时刻都是双向的可以收发数据

------------------------流控制传输协议(Stream Control Transmission Protocol)SCTP-----------------
SCTP类似TCP，但是在客户端和服务器之间提供关联（association）
与TCP的区别:
1.关联而不是连接：连接只涉及两个ip地址之间的通信，关联则是两个系统之间的一次通信，SCTP支持多宿而涉及不只两个地址
2.面向消息的（message-oriented):提供各个记录的按序传输，而且和UDP相同，每条记录长度随着记录一起发送
3.提供多个流：TCP会因为某个字节的数据丢失导致阻塞后面的数据直到该丢失被修复，SCTP提供多个流
4.多个宿主：使得单个SCTP端点支持多个IP地址(当某一个网络连接发生故障时有其他备选网络连接,多宿主主机就是一台具有多个网络接口的主机，因此可以通过多个IP地址来访问这台主机)
(通过路由协议的支持下TCP可以具有多宿特点：当两个路由器之间存在一条路由就可以保证两个路由器之间的BGP连接可用)

-----------------------TCP连接的建立和终止-----------------------------
三次握手
建立连接时会发生
1.服务器必须准备好接受外来的数据（一般用socket，bind，listen）称之为被动打开(accept阻塞)
2.客户端程序通过使用connect发起主动打开，将会导致客户端TCP发送一个SYN（同步）分节(segment)，用于告诉服务器将在连接中发送的数据的初始序列号（一般SYN分节(segment)其所在IP数据报只包含一个IP首部和TCP首部以及TCP选项)(connect阻塞)
3.服务器必须确认ACK(ACK为SYN的初始序列号+1)客户的SYN，同时自己也发送一个SYN，用于告诉客户端在发送数据的初始序列号，服务器在单个分节(segment)发送（SYN和客户SYN的ACK)(connect返回)
4.客户必须确认(ACK)服务器的SYN(accept返回，read或recv阻塞)

因为上述步骤至少需要3个分组，因此称之为TCP三次握手
TCP连接类似一个电话系统，socket等价于有电话可用，bind是告诉别人你的电话号码（套接字关联ip和端口号),listen则是打开电话响铃，connect需要知道对方的电话号码（ip和端口号),accept则发生在被呼叫的人应答电话时来电显示（但是不同的是accept实际上是建立连接之后才返回客户端的ip和端口号),DNS则提供了一本电话簿（用于ip和用户名对照)

TCP选项:
每一个SYN可以含有多个TCP选项
常见选项:
1.MSS选项:
	最大分节(segment)长度(Maximum Segment Size)
2.窗口规模选项:
	指定TCP首部中的通告窗口必须扩大的位数（0~14），因此所提供的最大窗口接近1GB(65535(2^16因为该字段占16位)*2^14),用于增大吞吐量
	但是必须双方系统都支持
3.时间戳选项:
	1）计算往返时延RTT：
	当a主机接收到b主机发送过来的确认ack报文s2时，a主机此时内核时刻为ta2.
	a主机从s2报文的timestamp echo选项中可以解析出该确认ack确认的报文的发送时刻为ta1.
	那么：RTT＝接收ack报文的时刻－发送报文的时刻＝ta2 －ta1.
	ta2和ta1都来自a主机的内核，所以不需要在tcp连接的两端进行任何时钟同步的操作。
	2）防止回绕的序号：
	我们知道TCP报文的序列号只有32位，而每增加2^32个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽涌来快速的传输数据。例如1Gb/s的速率发送报文，则不到35秒报文的序号就会重复。这样对TCP传输带来混乱的情况。而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。
	网络编程无需关心该细节

TCP连接终止:(四个分节(segment)但是可能FIN和数据一起在一个分节，也可能最后的ACK和FIN在同一个分节)
1.某个进程首先调用close（主动关闭)，于是该端的TCP发送FIN分节(segment)，表示数据结束
2.接受到该FIN分节的进程执行被动关闭(read返回0)（意味着该连接上没有数据可以接受了)，发送ACK确认(在2-3步骤之间的状态称之为半关闭,TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭)
3.一段时间后（比如处理接受到FIN之前的数据），接收到该FIN的进程将调用close关闭它的套接字，导致该进程的TCP也会发送一个FIN
4.最初主动关闭的进程接受到了这个FIN后，发送ACK确认该FIN

TIME_WAIT状态:
存在的理由:
1.可靠地实现TCP双全工连接的终止（否则会发送RST被TCP视为错误)
2.允许老的重复分节(segment)在网络中消逝(TCP不给TIME_WAIT状态的连接发送新的连接)
该端点停留在这个状态的持续时间是最长分节生命期(Maximum Segment Lifetime,MSL,任何IP数据报能够在因特网中存活的最长时间)的两倍


---------------------------------SCTP关联的建立和终止-----------------
四次握手:
1.服务器必须准备好接受外来的关联，（socket，bind，listen）被动打开(accept阻塞)
2.客户端调用connect(阻塞)或者发送一个隐式打开该关联的消息进行主动打开，使得客户端SCTP发送INIT信息（内含客户端的IP地址清单，初始序列号，用于标识本次关联的所有分组的起始标记，客户请求的外出流的数目以及客户能够支持外来流的数目)
3.服务器以INIT ACK消息确认客户的INIT消息(除了上述内容还增加了状态cookie(包含服务器用于确信本关联有效所需的所有状态
				与TCP不同，不支持半连接，发送INIT ACK(内含状态cookie)后会释放所有资源，不维护状态)
4.客户以COOKIE ECHO(accept返回)消息回射服务器的状态cookie（可能和其他数据一起在同一个分组里)
5.服务器以COOKIE ACK(connect返回)来确认客户端回射的cookie是正确的，之后该关联被建立

两端各自选择一个主目的地址，使用四次握手是为了避免dos攻击(不维护状态，状态给客户端来维护)

关联终止:
不允许像TCP一样具有半关闭的关联，当一端关闭某个关联时，另一端必须停止发送新的数据

SCTP选项:
	1.动态地址扩展(允许协作的SCTP端点从已有的关联中动态增删IP地址)
	2.不完全可靠性扩展(允许协作的SCTP端点在应用程序的引导下限制数据是否重传(对于老旧不必要的数据))

-------------------------------端口号------------------------------
客户端通常使用短期存活的临时端口(ephemeral port):通常由传输层协议自动赋值给客户端,客户端一般不关心其临时端口的具体值,只需要确定该端口在自身主机中是唯一的(传输层协议确保)

总所周知的端口号0-1023
已登记的端口号1024-49151
49152-65535是动态的或私用的端口号(临时端口)

套接字对(socket pair)定义了TCP连接的两个端点的四元组(本地ip和端口，对方ip和端口)
SCTP则是本地ip组一个端口号，对方ip组一个端口号

标识IP和端口号通常称为一个套接字

-------------------------------缓冲区大小及其限制------------------------
1.IPv6的净荷长度不包括IPv6的首部而IPv4的总长度包括IPv4的首部

2.IPv4要求的最小链路MTU(Maximum Transmission Unit, MTU)是68字节，允许最大的IPv4首部(20字节+40字节的选项部分)以及拼接最小的片段(IPv4首部中片段偏移字段(该字段的单位为8字节)) 68 = 20 + 40 + 1 * 8
IPv6则要求最小链路MTU为1280字节(可以小于该值但是链路需要具有分片和重组的功能,似乎看起来具有1280字节)

A-B与B-A之间的路径MTU(两个主机之间的路径中最小的MTU)可能不对等(上行下行)

3.如果一个IP数据报超过相应链路的MTU时:
	IPv4支持主机和路由器进行分片(由数据报变成分组packet)(到达目的之前一般不会重组)
	IPv6则支持主机进行分片,路由器不会对由它转发的数据进行分片(但是会由它产生的数据进行分片,此时路由器等价于主机)


4.IPv4中DF(don't fragment)被设置的话则表示不允许分片,当路由器收到了一个大于MTU但是DF位被设置的IP数据报时会产生ICMPv4错误
IPv6由于不允许路由器对于其转发的数据进行分片因此相当于隐含了一个DF位,.............................产生ICMPv6错误

path mtu discovery技术可以侦测DF位以及ICMP错误信息来反馈给TCP,TCP则减小每个数据报的数据量并且重传(但是由于防火墙会丢弃所有ICMP信息导致TCP无法得到降低数据报的信号)

5.IPv4和IPv6都定义了最小重组缓冲区大小(Minimum Reassembly Buffer Size)它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4为576字节，对于IPv6为1500字节

6.TCP具有一个MSS(Maximum segment size,最大分节大小)用于告诉对方其重组缓冲区大小的实际值(避免分片),一般MSS设置为MTU减去(IP和TCP首部)

7.SCTP使用最小MTU将较大的用户消息分隔成能够以单个IP数据报发送的若干个片段,SCTP_MAXSEG可以影响该值,使用户能够请求一个更小的分片点

---------------------------TCP输出----------------------------
每一个TCP套接字有一个发送缓冲区可以使用SO_SNDBUF来修改,当发送缓冲区容不下发送数据时,socket会被阻塞(默认设置),直到所有发送数据都被拷贝到了发送缓冲区中write系统调用则返回

TCP必须为发送的数据保留副本因为可能存在丢包现象
数据链路层的输出队列若发生了丢包则会通过协议栈上传至TCP,TCP捕获该信号然后重传数据(应用层屏蔽)

--------------------------UDP输出-------------------------
虚拟(不可靠数据无需维护一个数据缓冲区)一个套接字发送缓冲区(SO_SNDBUF来修改)，如果应用进程写一个大于套接字发送缓冲区的大小内核会返回错误

一个UDP套接字的write系统调用返回表示所写的数据报或其所有片段已经被加入到了数据链路层的输出队列中,如果该队列满了则内核!!通常会返回一个错误(ENOBUFS)

--------------------------SCTP输出-------------------------
类似TCP


========================第3章:套接字编程简介===========================
typedef uint32_t in_addr_t;
struct in_addr
 {
   in_addr_t s_addr;
 };


/* POSIX.1g specifies this type name for the `sa_family' member.  */
typedef unsigned short int sa_family_t;

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

#define __SOCKADDR_COMMON(sa_prefix) \
  sa_family_t sa_prefix##family

/* Structure describing an Internet (IP) socket address. */
#if  __UAPI_DEF_SOCKADDR_IN
#define __SOCK_SIZE__   16      /* sizeof(struct sockaddr)  */
struct sockaddr_in {
  __kernel_sa_family_t  sin_family; /* Address family       */          //IPv4地址族是AF_INET
  __be16        sin_port;   /* Port number          */                        !!!注意点:端口号和ip地址都是网络字节序存储
  struct in_addr    sin_addr;   /* Internet address     */

  /* Pad to size of `struct sockaddr'. */
  unsigned char     __pad[__SOCK_SIZE__ - sizeof(short int) -
            sizeof(unsigned short int) - sizeof(struct in_addr)];
};
#define sin_zero    __pad       /* for BSD UNIX comp. -FvK  */
#endif

---------------------IPv6套接字地址结构-------------------
#if !__USE_KERNEL_IPV6_DEFS
/* Ditto, for IPv6.  */
struct sockaddr_in6
  {
    __SOCKADDR_COMMON (sin6_); //IPv6地址族是AF_INET6
    in_port_t sin6_port;    /* Transport layer port # */
    uint32_t sin6_flowinfo; /* IPv6 flow information */				!!//低地址20位是流标(flow label,IPv6涉及),高地址12位是保留
    struct in6_addr sin6_addr;  /* IPv6 address */		
    uint32_t sin6_scope_id; /* IPv6 scope-id */
  };
#endif /* !__USE_KERNEL_IPV6_DEFS */

 /* IPv6 address */
struct in6_addr
  {
    union
      {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
      } __in6_u;

------------------新的通用套接字地址结构(在ANSIC之前void*不存在,采用此办法代替)-------------------
/* Structure large enough to hold any socket address 
(with the historical exception of AF_UNIX). 128 bytes reserved.  */

#if ULONG_MAX > 0xffffffff
# define __ss_aligntype __uint64_t
#else
# define __ss_aligntype __uint32_t
#endif
#define _SS_SIZE        128
#define _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))

struct sockaddr_storage
{
    sa_family_t ss_family;      /* Address family */
    __ss_aligntype __ss_align;  /* Force desired alignment.  */强制所需要的内存对齐
    char __ss_padding[_SS_PADSIZE];		//对于用户透明，使用时需要强转成其他类型如sockaddr_in
};

---------------字节排序函数-----------------------------
我们把某个给定系统所用的字节序称之为主机字节序host byte order
字节序中大小端的区别是指高地址存放高位数据还是低位数据，但是单个字节里面的内容是不会变的
un.s = 0x2102; // 0010 0001 0000 0010 //<--------高---------低 (小端模式)
//0x0221 0000 0010 0010 0001 //<--------高---------------低(大端模式)

#include <arpa/inet.h>
uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint32_t ntohl(uint32_t netlong);

h:host n:network s:short l:long

--------------字节操纵函数(标准库里面是mem开头eg:memset)------------------
#include <strings.h>
void bzero(void *dest, size_t nbtyes);
void bcopy(const void*src, void *dest, size_t nbytes);
int bcmp(const void* ptr1, const void*ptr2, size_t nbytes);
//最后一个若两个数据相等则为0，否则返回非0



------------------IP地址转换函数----------------------------
------------------inet_aton, inet_addr和 inet_ntoa函数-------------
#include <arpa/inet.h>
typedef uint32_t in_addr_t;
struct in_addr
{
	in_addr_t s_addr;
}

int inet_aton(const char* strptr, struct in_addr *addrptr);
//返回若字符串有效则1否则为0

in_addr_t inet_addr(const char*strptr);//
//返回若字符串有效则为32位二进制网络字节序的IPv4地址，否则返回INADDR_NONE(被定义为-1,导致255.255.255.255不可区分)
//已被废弃，inet_aton替换

char *inet_ntoa(struct in_addr inaddr);//返回一个指向点分十进制串的指针(eg:127.0.0.1)


------------------通用IP地址转换函数----------------------------
------------------inet_pton和inet_ntop函数-------------------------
//IPv4和IPv6协议都可以
#include <arpa/inet.h>
//AF_INET AF_INET6
//p表达的意思presentation
//n数值的意思numeric

addrptr应该指向struct in_addr(6)
int inet_pton(int family, const char* strptr, void* addrptr);
//成功返回1，失败返回0，错误-1

//strptr应该为至少len个字节,ipv4 16个字节，ipv6 46个字节
const char* inet_ntop(int family, const void* addrptr, char *strptr, size_t len);
//成功返回指向结果的指针，失败NULL

------------------------第四章基本TCP套接字编程-------------------------------
#include <sys/socket.h>
int socket(int family, int type, int protocol);//成功返回非负的socket描述符，失败-1
family:
       Name                Purpose                          Man page
       AF_UNIX, AF_LOCAL   Local communication(UNIX域协议)              unix(7)
       AF_INET             IPv4 Internet protocols          ip(7)
       AF_INET6            IPv6 Internet protocols          ipv6(7)
       AF_IPX              IPX - Novell protocols
       AF_NETLINK          Kernel user interface device     netlink(7)
       AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)
       AF_AX25             Amateur radio AX.25 protocol
       AF_ATMPVC           Access to raw ATM PVCs
       AF_APPLETALK        AppleTalk                        ddp(7)
       AF_PACKET           Low level packet interface       packet(7)
       AF_ALG              Interface to kernel crypto API

type:
       SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  An out-of-band data transmission mechanism may be supported.

       SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages of a fixed maximum length).

       SOCK_SEQPACKET  Provides  a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maxi‐
                       mum length; a consumer is required to read an entire packet with each input system call.

       SOCK_RAW        Provides raw network protocol access.

       SOCK_RDM        Provides a reliable datagram layer that does not guarantee ordering.

       SOCK_PACKET     Obsolete and should not be used in new programs; see packet(7).

       Some socket types may not be implemented by all protocol families.

       Since Linux 2.6.27, the type argument serves a second purpose: in addition to specifying a socket type, it  may  include  the
       bitwise OR of any of the following values, to modify the behavior of socket():

       SOCK_NONBLOCK   Set  the  O_NONBLOCK file status flag on the new open file description.  Using this flag saves extra calls to
                       fcntl(2) to achieve the same result.

       SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the  description  of  the  O_CLOEXEC
                       flag in open(2) for reasons why this may be useful.

protocol:
	IPPROTO_TCP
	IPPROTO_UDP
	IPPROTO_SCTP
	0表示根据domain以及type自动决定采用某个协议
		AF_INET             AF_INET6            AF_LOCAL              AF_ROUTE(路由套接字)             AF_KEY(密匙套接字)
SOCK_STREAM TCP|SCTP        TCP|SCTP            是(暂无具体词汇描述)
SOCK_DGRAM  UDP             UDP                 是
SOCK_SEQPACKET SCTP         SCTP                是
SOCK_RAW    IPv4            IPv6	                                 是                                是


---------------------------connect函数-------------------------
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr* servaddr, socklen_t addrlen);
//成功返回0失败-1
//若失败则sockfd不可使用必须关闭开启新的套接字

//TCP错误返回情况:
	1.TCP客户没有收到SYN分节的相应，返回ETIMEDOUT错误
	超时
	2.对于客户的SYN的响应是RST(表示复位),该服务器主机在我们指定的端口没有进程在等待与之连接(硬错误)
	ECONNERFUSED
	3.客户发出的SYN在中间的路由器上引发了一个"destination unreachable"(目的地不可达)ICMP错误(软错误)
	ENETUNREACH
     Network is unreachable.

抓包工具tcpdump(命令)

-------------------------bind函数------------------------
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr* addr, socklen_t addrlen);
//成功0失败-1
//对于TCP可以选择绑定一个ip或者端口号或者两者都具有，或者都不具有

//对于服务器绑定它众所周知的端口(但是远程过程调用(RPC)除外,一般由内核为它们分配临时端口，然后通过RPC端口映射器进行注册，客户端由RPC端口映射器来获取它们的临时端口
	如果没有绑定端口，则内核就要为相应的套接字选择一个临时端口

//进程可以绑定特定的IP，对于TCP客户，为绑定的套接字指派了源IP地址，对于服务器就限定了该套接字只接收那些目的为该IP地址的客户连接，

	若客户没有bind则内核会根据所用的外出网络接口(取决于到达的服务器所需的路径)来选择源IP地址
	若服务没有bind则内核会根据客户发出的SYN的目的地址作为服务器的源IP地址

struct sockadd_in serv;
serv.sin_addr.s_addr = htonl(INADDR_ANY);
对于IPv4的通配地址为INADDR_ANY来指定

struct sockaddr_in6 serv;
serv.sin6_addr = in6addr_any;
对于IPv6的通配地址为in6addr_any;

进程指定
IP           端口      结果
通配地址     0         内核选择IP地址和端口(ip根据到达的服务器所需路径选择源ip地址，分配临时端口)
通配地址    非0        内核选择IP地址，进程指定端口
本地IP地址  0          进程指定IP地址，内核选择端口
本地IP地址  非0        进程指定IP地址和端口(服务器一般用通配地址否则只能接受来自于目的地为指定ip的连接eg:127.0.0.1若设置，则无法接受192.168.42.203的连接(尽管都是本机),而设置为INADDR_ANY 或in6addr_any则可以)

//常见错误EADDRINUSE地址已使用

---------------------------listen函数--------------
listen用于将未连接的套接字变成被动套接字，指示内核应接受指向该套接字的连接请求

#include <sys/socket.h>
int listen(int sockfd, int backlog);//成功返回0，失败返回-1
对于backlog的理解:
1.内核为任何一个给定的监听套接字维护了两个队列
	1.未完成连接队列:等待客户的ACK确认 处于SYN_RCVD状态(保留服务的ACK和SYN直到三路握手的第三个分节到达,或者超时(超过往返时间(RTT))
			ddos攻击
	2.已完成连接队列:完成三路握手处于ESTABLISHED状态
以上两个队列之和不超过backlog
2.不应该设置为0，若不想让客户连接应该关闭套接字
3.操作系统的内部实现可能为backlog增加了一个模糊因子，把backlog乘以一个常数得到最大长度
4.若backlog超过操作系统所支持的最大值，内核会截断成内核所支持的最大值

如果三路握手正常那么该项就从未完成连接队列移动到已完成连接队列,之后由accept取出队列头部

若一个客户的SYN到达时这些队列是满的，那么TCP就忽略该分节,也就是不发送RST,是为了让客户能够重新发送SYN，否则connect会直接返回错误(而不是让TCP重传机制来处理)(尽管不同的操作系统可能不这么实现)

-------------------------accept函数--------------------
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr* cliaddr, socklen_t *addrlen);
//成功非负的socket描述符(已连接的socketfd),失败-1

------------------------getsockname和getpeername函数-----------------
#include <sys/socket.h>
int getsockname(int sockfd, struct sockaddr* localaddr, socklen_t* addrlen);
//对于服务sockfd应该是accept返回的已连接的socketfd，可以获取内核赋予该连接的本地IP地址
//对于没有调用bind的TCP客户，connect成功返回后，用于返回由内核赋予该连接的本地ip地址和本地端口号

int getpeername(int sockfd, struct sockaddr* peeraddr, socklen_t* addrlen);
//返回对方的ip信息

