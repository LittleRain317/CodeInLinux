========================第1章:简介=========================
!!注意点:TCP是一个没有记录边界的字节流协议
因此在处理收发数据的边界时常常由应用层协议来决定（比如HTTPv1.0使用关闭连接 SMTP使用\r\n Sun远程过程调用（RPC)以及DNS在每个要发送的数据之前放置一个二进制的计数值来表示该记录的长度(TCP本身并不提供记录结束标志)

netstat命令
netstat [-atunlp]
--------|-a 目前系统上所有的连接、监听、socket都列出
--------|-t 列出tcp网络封包的数据
--------|-u 列出udp网络封包的数据
--------|-n 不以进程的服务名称，而以端口号显示
--------|-l 列出目前正在网络监听的程序
--------|-p 列出该网络服务的进程pid
--------|-i 提供网络接口信息
--------|-r 显示路由表

封包协议|接收队列|发送队列|本地ip和端口号|远程主机的ip和端口号|连接状态，创建（ESTABLISED）及监听（LISTEN）
Proto   | Recv-Q | Send-Q |Local Address |Foreign Address     |   State      
tcp        0      0 192.168.1.105:42776     211.159.235.143:http    TIME_WAIT  

socket file的输出栏有
Proto RefCnt(连接到此socket的数量) Flags       Type(确认连接STREAM与不需确认的DGRAM)       State(若CONNECTIED则表示多个进程之间已经连线创建)         I-Node   Path
unix  2      			   [ ]         DGRAM                  			  						             29510    /run/user/1000/systemd/notify

ifconfig 网络接口名字
显示每个网络接口的详细信息

=========================第2章:传输层TCP,UDP和SCTP(Stream Control Transmission Protocol)================
UDP是一个简单的、不可靠的数据报协议
TCP是一个复杂的、可靠的字节流协议
SCTP则比TCP提供更多的服务

-------------------------用户数据报协议UDP(User Datagram Protocol)----------------------

每个UDP数据报都有一个长度，如果一个数据报正确地到达目的地，则该数据报的长度将随着数据一道被传递给接收端应用进程（TCP则不相同)
UDP无连接:同一个UDP套接字可以发送一个数据给多个客户，也可以用一个UDP套接字从多个客户接受数据
面向连接与无连接是计算机网络诸多概念中的很重要的之一。所谓面向连接，是指通信双方在进行通信之前，要事先在双方之间建立起一个完整的可以彼此沟通的通道,这个通道也就是连接，在通信过程中，整个连接的情况一直可以被实时地监控和管理。而无连接的通信，就不需要预先建立起一个联络两个通信节点的连接来，需要通信的时候，发送节点就可以往“网络”上送出信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控，让该信息的传递在网上尽力而为地往目的地节点传送

-------------------------传输控制协议TCP(Transmission Control Protocol)-------------------
TCP连接:先与某个给定服务器进程建立一个连接，再跨该连接与该服务器进程交换数据，然后终止该连接
TCP可靠性:要求对方返回一个确认，如果没有收到确认，TCP就自动重传数据并等待更长时间，在多次重传失败后才放弃
TCP往返时间算法（RTT round-trip time)以便知道自己应该等待多长时间
TCP排序：给每一个字节关联一个序列号对发送的数据进行排序，如果数据乱序或重复则根据序列号进行筛选重新排列
TCP流量控制：告知对方在任何时刻它一次能够从对方接受多少字节的数据（通告窗口（advertised window）），该窗口动态变化
TCP双全工（full-duplex):在连接后任何时刻都是双向的可以收发数据

------------------------流控制传输协议(Stream Control Transmission Protocol)SCTP-----------------
SCTP类似TCP，但是在客户端和服务器之间提供关联（association）
与TCP的区别:
1.关联而不是连接：连接只涉及两个ip地址之间的通信，关联则是两个系统之间的一次通信，SCTP支持多宿而涉及不只两个地址
2.面向消息的（message-oriented):提供各个记录的按序传输，而且和UDP相同，每条记录长度随着记录一起发送
3.提供多个流：TCP会因为某个字节的数据丢失导致阻塞后面的数据直到该丢失被修复，SCTP提供多个流
4.多个宿主：使得单个SCTP端点支持多个IP地址(当某一个网络连接发生故障时有其他备选网络连接,多宿主主机就是一台具有多个网络接口的主机，因此可以通过多个IP地址来访问这台主机)
(通过路由协议的支持下TCP可以具有多宿特点：当两个路由器之间存在一条路由就可以保证两个路由器之间的BGP连接可用)

-----------------------TCP连接的建立和终止-----------------------------
三次握手
建立连接时会发生
1.服务器必须准备好接受外来的数据（一般用socket，bind，listen）称之为被动打开(accept阻塞)
2.客户端程序通过使用connect发起主动打开，将会导致客户端TCP发送一个SYN（同步）分节(segment)，用于告诉服务器将在连接中发送的数据的初始序列号（一般SYN分节(segment)其所在IP数据报只包含一个IP首部和TCP首部以及TCP选项)(connect阻塞)
3.服务器必须确认ACK(ACK为SYN的初始序列号+1)客户的SYN，同时自己也发送一个SYN，用于告诉客户端在发送数据的初始序列号，服务器在单个分节(segment)发送（SYN和客户SYN的ACK)(connect返回)
4.客户必须确认(ACK)服务器的SYN(accept返回，read或recv阻塞)

因为上述步骤至少需要3个分组，因此称之为TCP三次握手
TCP连接类似一个电话系统，socket等价于有电话可用，bind是告诉别人你的电话号码（套接字关联ip和端口号),listen则是打开电话响铃，connect需要知道对方的电话号码（ip和端口号),accept则发生在被呼叫的人应答电话时来电显示（但是不同的是accept实际上是建立连接之后才返回客户端的ip和端口号),DNS则提供了一本电话簿（用于ip和用户名对照)

TCP选项:
每一个SYN可以含有多个TCP选项
常见选项:
1.MSS选项:
	最大分节(segment)长度(Maximum Segment Size)
2.窗口规模选项:
	指定TCP首部中的通告窗口必须扩大的位数（0~14），因此所提供的最大窗口接近1GB(65535(2^16因为该字段占16位)*2^14),用于增大吞吐量
	但是必须双方系统都支持
3.时间戳选项:
	1）计算往返时延RTT：
	当a主机接收到b主机发送过来的确认ack报文s2时，a主机此时内核时刻为ta2.
	a主机从s2报文的timestamp echo选项中可以解析出该确认ack确认的报文的发送时刻为ta1.
	那么：RTT＝接收ack报文的时刻－发送报文的时刻＝ta2 －ta1.
	ta2和ta1都来自a主机的内核，所以不需要在tcp连接的两端进行任何时钟同步的操作。
	2）防止回绕的序号：
	我们知道TCP报文的序列号只有32位，而每增加2^32个序列号后就会重复使用原来用过的序列号。假设我们有一条高速网络，通信的主机双方有足够大的带宽涌来快速的传输数据。例如1Gb/s的速率发送报文，则不到35秒报文的序号就会重复。这样对TCP传输带来混乱的情况。而采用时间戳选项，可以很容易的分辨出相同序列号的数据报，哪个是最近发送，哪个是以前发送的。
	网络编程无需关心该细节

TCP连接终止:(四个分节(segment)但是可能FIN和数据一起在一个分节，也可能最后的ACK和FIN在同一个分节)
1.某个进程首先调用close（主动关闭)，于是该端的TCP发送FIN分节(segment)，表示数据结束
2.接受到该FIN分节的进程执行被动关闭(read返回0)（意味着该连接上没有数据可以接受了)，发送ACK确认(在2-3步骤之间的状态称之为半关闭,TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。这就是所谓的半关闭)
3.一段时间后（比如处理接受到FIN之前的数据），接收到该FIN的进程将调用close关闭它的套接字，导致该进程的TCP也会发送一个FIN
4.最初主动关闭的进程接受到了这个FIN后，发送ACK确认该FIN

TIME_WAIT状态:
存在的理由:
1.可靠地实现TCP双全工连接的终止（否则会发送RST被TCP视为错误)
2.允许老的重复分节(segment)在网络中消逝(TCP不给TIME_WAIT状态的连接发送新的连接)
该端点停留在这个状态的持续时间是最长分节生命期(Maximum Segment Lifetime,MSL,任何IP数据报能够在因特网中存活的最长时间)的两倍


---------------------------------SCTP关联的建立和终止-----------------
四次握手:
1.服务器必须准备好接受外来的关联，（socket，bind，listen）被动打开(accept阻塞)
2.客户端调用connect(阻塞)或者发送一个隐式打开该关联的消息进行主动打开，使得客户端SCTP发送INIT信息（内含客户端的IP地址清单，初始序列号，用于标识本次关联的所有分组的起始标记，客户请求的外出流的数目以及客户能够支持外来流的数目)
3.服务器以INIT ACK消息确认客户的INIT消息(除了上述内容还增加了状态cookie(包含服务器用于确信本关联有效所需的所有状态
				与TCP不同，不支持半连接，发送INIT ACK(内含状态cookie)后会释放所有资源，不维护状态)
4.客户以COOKIE ECHO(accept返回)消息回射服务器的状态cookie（可能和其他数据一起在同一个分组里)
5.服务器以COOKIE ACK(connect返回)来确认客户端回射的cookie是正确的，之后该关联被建立

两端各自选择一个主目的地址，使用四次握手是为了避免dos攻击(不维护状态，状态给客户端来维护)

关联终止:
不允许像TCP一样具有半关闭的关联，当一端关闭某个关联时，另一端必须停止发送新的数据

SCTP选项:
	1.动态地址扩展(允许协作的SCTP端点从已有的关联中动态增删IP地址)
	2.不完全可靠性扩展(允许协作的SCTP端点在应用程序的引导下限制数据是否重传(对于老旧不必要的数据))

-------------------------------端口号------------------------------
客户端通常使用短期存活的临时端口(ephemeral port):通常由传输层协议自动赋值给客户端,客户端一般不关心其临时端口的具体值,只需要确定该端口在自身主机中是唯一的(传输层协议确保)

总所周知的端口号0-1023
已登记的端口号1024-49151
49152-65535是动态的或私用的端口号(临时端口)

套接字对(socket pair)定义了TCP连接的两个端点的四元组(本地ip和端口，对方ip和端口)
SCTP则是本地ip组一个端口号，对方ip组一个端口号

标识IP和端口号通常称为一个套接字

-------------------------------缓冲区大小及其限制------------------------
1.IPv6的净荷长度不包括IPv6的首部而IPv4的总长度包括IPv4的首部

2.IPv4要求的最小链路MTU(Maximum Transmission Unit, MTU)是68字节，允许最大的IPv4首部(20字节+40字节的选项部分)以及拼接最小的片段(IPv4首部中片段偏移字段(该字段的单位为8字节)) 68 = 20 + 40 + 1 * 8
IPv6则要求最小链路MTU为1280字节(可以小于该值但是链路需要具有分片和重组的功能,似乎看起来具有1280字节)

A-B与B-A之间的路径MTU(两个主机之间的路径中最小的MTU)可能不对等(上行下行)

3.如果一个IP数据报超过相应链路的MTU时:
	IPv4支持主机和路由器进行分片(由数据报变成分组packet)(到达目的之前一般不会重组)
	IPv6则支持主机进行分片,路由器不会对由它转发的数据进行分片(但是会由它产生的数据进行分片,此时路由器等价于主机)


4.IPv4中DF(don't fragment)被设置的话则表示不允许分片,当路由器收到了一个大于MTU但是DF位被设置的IP数据报时会产生ICMPv4错误
IPv6由于不允许路由器对于其转发的数据进行分片因此相当于隐含了一个DF位,.............................产生ICMPv6错误

path mtu discovery技术可以侦测DF位以及ICMP错误信息来反馈给TCP,TCP则减小每个数据报的数据量并且重传(但是由于防火墙会丢弃所有ICMP信息导致TCP无法得到降低数据报的信号)

5.IPv4和IPv6都定义了最小重组缓冲区大小(Minimum Reassembly Buffer Size)它是IPv4或IPv6的任何实现都必须保证支持的最小数据报大小。其值对于IPv4为576字节，对于IPv6为1500字节

6.TCP具有一个MSS(Maximum segment size,最大分节大小)用于告诉对方其重组缓冲区大小的实际值(避免分片),一般MSS设置为MTU减去(IP和TCP首部)

7.SCTP使用最小MTU将较大的用户消息分隔成能够以单个IP数据报发送的若干个片段,SCTP_MAXSEG可以影响该值,使用户能够请求一个更小的分片点

---------------------------TCP输出----------------------------
每一个TCP套接字有一个发送缓冲区可以使用SO_SNDBUF来修改,当发送缓冲区容不下发送数据时,socket会被阻塞(默认设置),直到所有发送数据都被拷贝到了发送缓冲区中write系统调用则返回

TCP必须为发送的数据保留副本因为可能存在丢包现象
数据链路层的输出队列若发生了丢包则会通过协议栈上传至TCP,TCP捕获该信号然后重传数据(应用层屏蔽)

--------------------------UDP输出-------------------------
虚拟(不可靠数据无需维护一个数据缓冲区)一个套接字发送缓冲区(SO_SNDBUF来修改)，如果应用进程写一个大于套接字发送缓冲区的大小内核会返回错误

一个UDP套接字的write系统调用返回表示所写的数据报或其所有片段已经被加入到了数据链路层的输出队列中,如果该队列满了则内核!!通常会返回一个错误(ENOBUFS)

--------------------------SCTP输出-------------------------
类似TCP


========================第3章:套接字编程简介===========================
typedef uint32_t in_addr_t;
struct in_addr
 {
   in_addr_t s_addr;
 };


/* POSIX.1g specifies this type name for the `sa_family' member.  */
typedef unsigned short int sa_family_t;

/* This macro is used to declare the initial common members
   of the data types used for socket addresses, `struct sockaddr',
   `struct sockaddr_in', `struct sockaddr_un', etc.  */

#define __SOCKADDR_COMMON(sa_prefix) \
  sa_family_t sa_prefix##family

/* Structure describing an Internet (IP) socket address. */
#if  __UAPI_DEF_SOCKADDR_IN
#define __SOCK_SIZE__   16      /* sizeof(struct sockaddr)  */
struct sockaddr_in {
  __kernel_sa_family_t  sin_family; /* Address family       */          //IPv4地址族是AF_INET
  __be16        sin_port;   /* Port number          */                        !!!注意点:端口号和ip地址都是网络字节序存储
  struct in_addr    sin_addr;   /* Internet address     */

  /* Pad to size of `struct sockaddr'. */
  unsigned char     __pad[__SOCK_SIZE__ - sizeof(short int) -
            sizeof(unsigned short int) - sizeof(struct in_addr)];
};
#define sin_zero    __pad       /* for BSD UNIX comp. -FvK  */
#endif

---------------------IPv6套接字地址结构-------------------
#if !__USE_KERNEL_IPV6_DEFS
/* Ditto, for IPv6.  */
struct sockaddr_in6
  {
    __SOCKADDR_COMMON (sin6_); //IPv6地址族是AF_INET6
    in_port_t sin6_port;    /* Transport layer port # */
    uint32_t sin6_flowinfo; /* IPv6 flow information */				!!//低地址20位是流标(flow label,IPv6涉及),高地址12位是保留
    struct in6_addr sin6_addr;  /* IPv6 address */		
    uint32_t sin6_scope_id; /* IPv6 scope-id */
  };
#endif /* !__USE_KERNEL_IPV6_DEFS */

 /* IPv6 address */
struct in6_addr
  {
    union
      {
    uint8_t __u6_addr8[16];
    uint16_t __u6_addr16[8];
    uint32_t __u6_addr32[4];
      } __in6_u;

------------------新的通用套接字地址结构-------------------
/* Structure large enough to hold any socket address 
(with the historical exception of AF_UNIX). 128 bytes reserved.  */

#if ULONG_MAX > 0xffffffff
# define __ss_aligntype __uint64_t
#else
# define __ss_aligntype __uint32_t
#endif
#define _SS_SIZE        128
#define _SS_PADSIZE     (_SS_SIZE - (2 * sizeof (__ss_aligntype)))

struct sockaddr_storage
{
    sa_family_t ss_family;      /* Address family */
    __ss_aligntype __ss_align;  /* Force desired alignment.  */强制所需要的内存对齐
    char __ss_padding[_SS_PADSIZE];		//对于用户透明，使用时需要强转成其他类型如sockaddr_in
};


