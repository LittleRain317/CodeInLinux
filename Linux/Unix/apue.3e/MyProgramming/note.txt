第一章:Unix基础

1.内核的接口被称之为系统调用(System call)
	公用函数库建立在系统调用接口之上（进一步封装）

时钟时间:进程运行的时间总量
用户cpu时间:执行用户指令的时间量
系统时间为该进程执行内核程序所经历的时间可用time命令查看
======================================第三章:文件I/O===================
所有打开的文件都通过文件描述符来引用

文件描述符中特殊的三个数值0 stdin 1 stdout 2 stderr
STDIN_FILENO STDOUT_FILENO STDERR_FILENO 定义在<unistd.h>

范围是0 ~ OPEN_MAX - 1

---------------------函数open和openat------------
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */); //即使参数完全一致，open的返回值也会是一个新的文件描述符，开启一个新的文件表项，但参数相同时，文件表项中的v节点指针指向同一个v节点
//内核会以进程的有效用户id和有效组id来检查权限
int openat(int dirfd, const char *path, int oflag, ... /* mode_t mode */);
成功返回文件描述符，否则返回-1

!!注意点:用open或creat创建文件时（若文件已经存在，则文件的访问权限不会因为mode的参数而改变)

按位或来操作oflag
O_RDONLY	只读打开 (需要有读权限)
O_WRONLY	只写打开 (需要有写权限)
O_RDWR      读、写打开 (需要有读写权限)
O_EXEC		只执行打开
O_SEARCH	只搜索打开（应用于目录)
以上必须执行一个，下面是可选的(使用|来连接)

O_APPEND	每次写时追加到文件的尾端,（即在write操作时会修改文件表项中的文件偏移量为文件尾部，将lseek(fd, 0, SEEK_END)和open(path, O_WRONLY)封装成一个原子操作)
O_CLOEXEC	把FD_CLOEXEC常量设置为文件描述符标志
O_CREAT		若文件不存在则创建它，使用此选项时，open函数需要mode参数，使用mode指定该新文件的访问权限
O_DIRECTORY	如果path引用的不是目录，则出错
O_EXCL		如果同时指定了O_CREAT，而文件已经存在，则出错，用此可以测试一个文件是否存在，如果不存在则创建该文件
O_NOCTTY 	如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端
O_NOFOLLOW 	如果path引用的是一个符号链接，则出错
O_NONBLOCK 	如果path引用的是一个FIFO，一个块文件或一个字符文件则此选项为文件的本次打开操作和后续的io操作设置非阻塞方式
O_SYNC 		使每次write等待物理i/o完成，包括该write操作引起的文件属性更新的i/o
O_TRUNC 	如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0(需要有写权限，猜想:>重定向使用了O_TRUNC
O_TTY_INIT 	如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合single unix specificaion标准
O_DSYNC 	使每次write要等待物理io操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新
O_RSYNC		使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作完成

dirfd参数说明:
1.当path指定的是绝对路径时，dirfd参数被忽略，openat相当于open
2.path为相对路径时，dirfd参数指出了相对路径名在文件系统中的开始地址，dirfd参数是通过打开相对路径名所在的目录来获取的
3.path为相对路径名，dirfd参数为AT_FDCWD，路径名在当前工作目录中获取，openat函数在操作上和open函数相同

概念:TOCTTOU time-of-check-to-time-of-use
如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的,因为两个调用非原子操作

--------------------------------------------函数creat-----------------
#include <fcntl.h>
int creat(const char *path, mode_t mode);
等价于open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);

---------------------------------------------函数close-----------------------
#include <unistd.h>
int close(int fd); //返回值 若成功返回0 失败-1
关闭一个文件时还会释放该进程加在该文件上的所有记录锁
当一个进程结束时，内核自动关闭它所有打开的文件

-------------------------------------函数lseek----------------------
文件偏移量：相对于开始处的计算的字节数
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence); //返回值 成功：新的文件偏移量，失败-1  !!注意点:这影响了下一次read或者write的位置，在调用lseek后未使用read或者write的话文件偏移量还是不会变的

若whence是SEEK_SET,	则文件的偏移量设置为距离文件开始处offset个字节
		  SEEK_CUR, 则文件的偏移量设置为当前值加offset，offset可正负
		  SEEK_END, 则文件的偏移量设置为文件长度加offset，offset可正负(若文件偏移量大于文件长度，则下一次写的操作会加长该文件并在文件中构成一个空洞（所有中间都被置位0，但这一部分是否占用磁盘空间取决于文件系统)

---------------------------------------函数read----------------------
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes); //返回值 成功:读取到的字节数若到文件尾部返回0，错误返回-1

-----------------------------------------函数write-----------------
#include <unistd.h>
ssize_t write(int fd, const void* buf, size_t nbytes); //返回值 成功:以写的字节数，错误返回-1

------------------------------------I/O的效率-----------------
操作系统试图使用高速缓存技术来将相关文件放在内存中以便重复数据的读写

大多数文件系统为了改善性能都是用预读技术

所谓不带缓冲是指用户层没有缓存，通过系统调用直接对磁盘文件进行读写，但是对于内核来说，还是进行了缓存，内核现将数据写到内核缓冲存储器中，当缓冲存储器溢出时再进行实际的IO操作

标准IO（带缓冲的IO）,标准IO通过库函数提供了无缓冲IO的带缓冲IO接口,在用户层建立一个流缓存区，库函数向流缓存区读写数据，流缓存区溢出时进行系统调用，即再调用无缓冲的IO

无缓冲的IO操作数据流向路径：数据——内核缓存区——磁盘

标准IO操作的数据流向：数据——流缓存区——内核缓存区——磁盘

-------------------------------------文件共享--------------------
每个进程在进程表中有一个记录项，记录项包含文件描述符和指向文件表项的指针

--------------------------------原子操作-------------------
原子操作:由多步组成的一个操作，如果该操作原子地执行则要不执行完，要不不执行，不可能执行所有步骤的一个子集
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset); //返回值 成功读到的字节数，到达文件尾返回0，错误返回-1
ssize_t pwrite(int fd, const void* buf, size_t nbytes, off_t offset); //返回值 成功返回已写的字节数，失败返回-1
以上两个函数将lseek和read或write进行了原子操作的封装

----------------------------函数dup和dup2-----------------------

#include <unistd.h>
int dup(int fd); //返回当前可用的文件描述符的最小值
int dup2(int fd, int fd2); 返回值 成功返回新的文件描述符，出错则返回-1 //原子操作
fd2来指定新的文件描述符，如果fd2已经打开，则先关闭，如果fd == fd2则直接返回fd2不关闭，否则fd2的FD_CLOEXEC文件描述符标志就被清除，这样子fd2在进程调用exec是打开状态

!!注意点:每一个文件描述符都有自己的一套文件描述符标志(文件描述符标志目前只有FD_CLOEXEC)
!!注意点:文件描述符标志和文件状态标志不同，文件状态标志取决于open函数中oflag参数

输入输出重定向的实现与dup有关，2>&1表示的是将fd2重定向至fd1所指向的文件表项 eg: dup2(fd1, fd2);这番操作后文件指针指向同一个文件表项
-----------------------------函数sync,fsync,fdatasync------------------
延迟写(delayed write):向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候(当要重新使用该缓冲区时)再写入磁盘

#include <unistd.h>
int fsync(int fd);  //只对由文件描述符fd指定的一个文件起作用，并且等待写入到磁盘结束才返回,会同步更新文件的属性
int fdatasync(int fd); //返回值 成功0 错误-1,类似fsync，但是只影响文件的数据部分
void sync(void); //只是将所有修改过的块缓冲区写入到队列中，并不等待实际的硬盘写入(update守护进程周期性调用sync函数，sync命令也会调用该函数)

---------------------------函数fcntl-------------------
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */); //修改已经打开的文件属性，返回值 成功依赖于cmd，失败-1
五种功能:
1.复制一个已有的文件描述符cmd = F_DUPFD 或 cmd = F_DUPFD_CLOEXEC)
2.获取/设置文件描述符标志(cmd = F_GETFD 或 cmd = F_SETFD)
3.获取/设置文件状态标志(cmd = F_GETFL 或 cmd = F_SETFL)
4.获取/设置异步i/o所有权(cmd = F_GETOWN 或 cmd = F_SETOWN)
5.获取/设置记录锁(cmd = F_GETLK, F_SETLK F_SETLKW)


	F_DUPFD 			复制文件描述符fd，如同dup(fd, fd2),
	F_DUPFD_CLOEXEC 	复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标志，返回新的文件描述符
	F_GETFD				对应于fd的文件描述符标志作为函数值返回，(目前实现当前只定义了FD_CLOEXEC, 该项数据在进程表项中)
	F_SETFD				对于fd设置文件描述符标志，新标志值按照第3个参数设置
	F_GETFL 			对应于fd的文件状态标志作为函数值返回
						O_RDONLY
						O_WRONLY
						O_RDWR
						O_EXEC
						O_SEARCH
						O_APPEND
						O_NONBLOCK
						O_SYNC 等待写完成（数据和属性)
						O_DSYNC 等待写完成(仅数据)
						O_RSYNC 同步读和写
						O_FSYNC	等待写完成
						O_ASYNC 异步I/O
		
						如何检验:
			if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)
			{
				err_sys("fcntl error for fd %d", atoi(argv[1]));
			}
			switch (val & O_ACCMODE)
			{
			case O_RDONLY:
				printf("read only");
				break;
			case O_WRONLY:
				printf("write only");
				break;
			default:
				err_dump("unknown access mode");
			}

			if (val & O_APPEND)
				printf(", append");
			if (val & O_NONBLOCK)
				printf(", nonblocking");
			if (val & O_SYNC)
				printf(", synchronous writes");
#if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)
			if (val & O_FSYNC)
				printf(", synchronous writes");
#endif
	F_SETFL 			可以修改的有O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, O_ASYNC	

	!!注意点在设置FL或者FD时，应该先获取当前的值，然后采用位运算计算出新的标志，之后再来设置
	F_GETOWN 			获取当前接收SIGIO和SIGURG信号的进程id或进程组id
	F_SETOWN 			设置接收SIGIO和SIGURG信号的进程id或进程组id，arg为正则表示进程id，负则表示arg绝对值的进程组id

----------------------------函数ioctl--------------------
 #include <sys/ioctl.h>

 int ioctl(int fd, unsigned long request, ...); //返回值 出错返回-1，成功返回其他
通常，需要包含设备专用的头文件比如终端i/o的ioctl命令需要头文件<termios.h>


=====================================第四章：文件和目录====================
-----------------函数stat, fstat, fstatat和lstat------------------
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf); //文件有关信息的数据结构 ls -l
int fstat(int fd, struct stat *buf); //fd上打开文件的有关信息
int lstat(const char *restrict pathname, struct stat *restrict buf); //pathname为符号链接时返回符号连接信息,而非所链接的文件信息
int fstatat(int dirfd, const char *restrict pathname, struct stat *restrict buf, int flag); //对于当前打开目录dirfd的路径名返回文件信息
flag 控制是否跟随者一个符号链接
//flag为AT_SYMLINK_NOFOLLOW时，返回链接本身信息
//dirfd为AT_FDCWD时，且pathname为相对路径时，fstatat会计算相对于当前目录的pathname参数，否则是相对于dirfd的相对路径
//如果pathname为绝对路径时，dirfd参数会被忽略

 //返回值 成功0 失败-1

----------------------------文件类型-------------
struct stat中st_mode记录了下列信息
1.普通文件(文本或者二进制数据，有别于二进制可执行文件二进制可执行文件需要elf)
2.目录文件:对于一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件，进程需要使用函数来修改目录
3.块设备文件:每次访问以固定长度为单位进行，提供对设备带缓冲的访问
4.字符设备文件:不带缓冲的访问
5.FIFO:（pipe）进程间通信
6.Socket:进程的网络通信，也可用于在一台主机上进程之间的非网络通信
7.符号连接
<sys/stat.h>下的宏用于判断文件类型
参数为st_mode
S_ISREG() ：普通文件
S_ISDIR() ：目录文件
S_ISCHR() ：字符文件
S_ISBLK() ：块文件
S_ISFIFO() ： 管道文件或队列文件
S_ISLNK() : 软链接符号连接
S_ISSOCK() : 套接字

S_ISUID S_IDGID常量可以&st_mode来判断文件是否具有其他属性（setuid和setgid,linux笔记中有提及)

从stat结构中确定进程间通信（IPC)对象的类型
参数为stat结构的指针
S_TYPEISMQ() : 消息队列
S_TYPEISSEM() : 信号量
S_TYPEISSHM() : 共享存储对象

#define S_IFMT  00170000 //is file mask type
#define S_IFSOCK 0140000
#define S_IFLNK	 0120000
#define S_IFREG  0100000
#define S_IFBLK  0060000
#define S_IFDIR  0040000
#define S_IFCHR  0020000
#define S_IFIFO  0010000
#define S_ISUID  0004000
#define S_ISGID  0002000
#define S_ISVTX  0001000

#define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
#define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
#define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
#define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)

----------------------------------------设置用户id和用户组id------------
进程包含了至少这些id:
|实际用户id
|实际组id 		我们实际上是谁(谁运行的进程)
------
|有效用户id
|有效组id
|附属组id 		用于文件访问权限检查(可以看做是进程对应的程序文件的拥有者,用户组)(一般等于实际用户id实际组id,当文件具有其他属性如setuid和setgid时则有效id就会变成setuid和setgid中的值)
------
|保存的设置用户id
|保存的设置组id	由exec函数保存包含了有效用户id和有效组id的副本
------
文件所有者st_uid,组所有者st_gid
st_mode中设置特殊标志的话，可以实现文件其他属SetUid和SetGid
用S_ISUID和S_ISGID来测试是否设置了setuid或setgid

---------------------------------------文件访问权限-----------------------
st_mode同时包含了文件的访问权限

S_IRUSR 				用户读
S_IWUSR 				用户写
S_IXUSR 				用户执行

S_IRGRP 				用户组读
S_IWGRP 				用户组写
S_IXGRP 				用户组执行

S_IROTH 				其他读
S_IWOTH					其他写
S_IXOTH 				其他执行

---------------------------------新文件和目录的所有权------------
新文件的用户id设置为进程的有效用户id, 组id取决于实现
1.新文件的组id可以是进程的有效组id
2.新文件的组id可以是它所在的目录的组id(linux中新文件的组id默认为进程的有效id，除非所在目录设置了setGid)

---------------------------------函数access和faccessat----------------
当open函数打开一个文件时，默认是用有效用户id和有效组id来执行权限测试，但有时希望按照实际的(所登录的当前用户用户组)
#include <unistd.h>
int access(const char* pathname, int mode);
int faccessat(int dirfd, const char * pathname, int mode, int flag);
//返回值 成功0 错误-1

dirfd为AT_FDCWD时，pathname为当前目录的相对路径（否则就以dirfd的目录作为相对)
pathname为绝对路径时忽略dirfd

mode R_OK 测试读权限
	 W_OK 测试写权限
	 X_OK 测试执行权限
	 F_OK 测试是否存在

flag参数为AT_EACCESS的话则为有效用户id和有效组id
	     AT_SYMLINK_NOFOLLOW
               如果pathname是符号链接，请不要取消引用它：而是返回有关链接本身的信息
			0是默认实际

----------------------------------函数umask-----------------
#include <sys/stat.h>
mode_t umask(mode_t cmask);//返回值之前的umask
参数cmaks为文件访问权限的按位|

!!注意点:当创建文件时，若想要确保指定的文件访问权限已经有，最好先使用umask来修改当前的umask值，否则可能会因为当前的umask值关闭对应权限

---------------------------------函数chmod和fchmod和fchmodat
#include <sys/stat.h>
//为了修改文件权限，进程的有效用户id必须等于文件的所有者id，或者该进程具有超级用户权限
int chmod(const char* pathname, mode_t mode); //在指定文件上操作
int fchmod(int fd, mode_t mode); //在已经打开的文件进行操作
int fchmodat(int dirfd, const char*pathname, mode_t mode, int flag); //flag设置了AT_SYMLINK_NOFOLLOW时不会跟随链接文件，而是链接文件本身
//返回值 成功0 错误-1
mode为上述9个文件访问权限以及S_ISUID S_ISGID S_ISVTX 分别对应setuid setgid sbit
							 S_IRWXU S_IRWXG S_IRWXO

!!注意点:需要注意的是进程所属的有效用户id必须和文件拥有者id相匹配，否则错误
		 其次，若进程的有效gid或者附属gid不等于文件的gid则mode若是setuid和setgid会失效，但是返回成功

---------------------------------粘着位--------
S_ISVTX setbit (历史原因叫做S_IsSaved-text bit,最初因为加载文件速度的原因，将一份程序的.text段放在了交换空间里，以便下次执行程序更快地加载到内存里)

---------------------------函数chown,fchown,fchownat,lchown--------------------
#include <unistd.h>

int chown(const char *pathname, uid_t owner, gid_t group); //chown会dereference
int fchown(int fd, uid_t owner, gid_t group);
int fchownat(int dirfd, const char* pathname, uid_t owner, gid_t group, int flag); //flag
  AT_EMPTY_PATH (since Linux 2.6.39) //如果pathname是空字符串，则对dirfd引用的文件（可能是使用open（2）O_PATH标志获取）进行操作。 在这种情况下，dirfd可以引用任何类型的文件，而不仅仅是目录。 如果dirfd是AT_FDCWD，则该调用将在当前工作目录上运行。 该标志是特定于Linux的; define _GNU_SOURCE以获取其定义。
  AT_SYMLINK_NOFOLLOW
int lchown(const char *pathname, uid_p owner, gid_t group); // lchown() is like chown(), but does not dereference symbolic links.

owner或group任意一个是-1则对应的ID不变 //返回值 成功0 错误-1
!!注意点:当_POSIX_CHOWN_RESTRICTED可选地定义在<unistd.h>中，若定义了则不能更改其他用户文件的uid但是可以修改自己所拥有的文件的gid，不过只能修改成自己所属的组

---------------------------文件长度----------------------
stat结构中st_size记录了以字节为单位的文件长度，只对普通文件、目录文件、符号链接有意义

!!注意点:符号链接的长度等于所指向的文件名的实际长度


---------------------------文件中的空洞--------------------------
如何产生：偏移量超过文件尾部，并且写入了部分数据
空洞文件作用很大，例如迅雷下载文件，在未下载完成时就已经占据了全部文件大小的空间，这时候就是空洞文件。下载时如果没有空洞文件，多线程下载时文件就都只能从一个地方写入，这就不是多线程了。如果有了空洞文件，可以从不同的地址写入，就完成了多线程的优势任务

--------------------------文件截取-------------------------
#include <unistd.h>
int truncate(const char* pathname, off_t length);
int ftruncate(int fd, off_t length);
//返回值 成功0 错误-1
将现有文件截断成length
1.length > 实际的则文件长度增加（可能在以前的文件尾和新的文件尾之间产生空洞)
2.length < 实际的则超过部分不能再被访问

---------------------------文件系统----------------------------------
目录项(inode编号和文件名)不等于目录，目录是一系列目录项的列表
每一个inode中都有一个链接计数（指向该inode的目录项数，只有当链接计数为0时才会删除该文件也就是释放该文件所占用的block)

在stat结构中，链接计数在st_nlink成员中，该成员类型为nlink_t，这种链接为硬链接，软链接（符号链接）则block中记录了该符号链接所指向的文件的名字

数据类型为ino_t inode包含了文件的所有信息：文件类型，文件访问权限，文件长度和指向文件block的指针，stat结构中的大多数数据来自于inode，只有两项重要数据放在目录项中(包含的文件的文件名和该文件的inode编号)

---------------------------函数link, linkat, unlink, unlinkat和remove----------
创建一个指向现有文件的硬链接的方法是使用link或linkat
#include <unistd.h>
int link(const char*existingpath, const char* newpath);
int linkat(int efd, const char*existingpath, int nfd, const char* newpath, int flag); 
//返回值 成功0 错误-1

!!注意点:若newpath已经存在则返回错误，只创建newpath中最后一级，路径中其他部分应该是已经存在的
at同上述at后缀的函数
当现有文件是符号链接时，flag设置了AT_SYMLINK_NOFOLLOW则不会对符号链接进行解引用，则创建的是指向符号链接的链接
!!注意点:创建新目录项和增加链接计数应当是原子操作 
!!为了避免造成文件系统中的循环，大多数文件系统不允许创建对于目录的硬链接

//删除一个现有的文件，并将pathname所引用文件的链接计数-1
#include <unistd.h>
int unlink(const char*pathname);
int unlinkat(int dirfd, const char*pathname, int flag); //flag为AT_REMOVEDIR时unlinkat的行为如同rmdir函数一样删除目录，否则如同unlink
//返回值 成功0 错误-1
!!注意点:当有进程打开了该文件时，该文件也不会被删除，删除一个文件时，内核会率先检查打开该文件的进程个数（推测可能是统计文件表项的个数)，然后再检查链接计数，只有当这两个数值都是0时才会删除该文件的内容

标准库中#include <stdio.h> int remove(const char*pathname); 对于文件达到unlink对于目录达到rmdir

----------------------------函数rename和renameat-----------------------
#include <stdio.h>
int rename(const char* oldname, const char*newname);
int renameat(int oldfd, const char*oldname, int newfd, const char*newname);
//返回值 成功0 错误-1

1.如果oldname指的是一个文件而不是目录，那么为这个文件或符号链接重命名，如果newname已经存在则它不能引用为一个目录，而且会删除重名的目录项，对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限
2.如果oldname指的是一个目录，那么为该目录重命名，如果newname已经存在，则必须引用一个目录，而且该目录只能是空目录（只有.和..)，并且会删除重名的目录，然后修改目录名!!注意点:oldname不能是newname前缀，比如/usr/foo /usr/foo/test不能这样子
3.若oldname或newname引用的符号链接，那么处理的符号链接本身
4.不能对.和..重名
5.oldname和newname一样时不做操作返回成功

--------------------------------符号链接-----------------------
符号链接是对文件的间接指针(推测block中记录了所指向的文件名)
并且可以指向不同的文件系统

--------------------------------创建和读取符号链接-------------------
#include <unistd.h>
int symlink(const char*actualpath, const char *sympath);
int symlinkat(const char*actualpath, int dirfd, const char*sympath);
//返回值 成功0 错误-1
//不要求actualpath已经存在，并且可以位于不同的文件系统

因为open函数会对符号链接进行解引用，所以readlink和readlinkat产生可以读取该链接本身
#include <unistd.h>
ssize_t readlink(const char*restrict pathname, char *restrict buf, size_t bufsize);
ssize_t readlinkat(int dirfd, const char* restrict pathname, char *restrict buf, size_t bufsize);
//返回值 成功读取到的字节数 失败-1

--------------------------------文件的时间---------------------
字段	说明					例子		ls选项
st_atim 文件数据的最后访问时间	read 		ls -u
st_mtim 文件数据的最后修改时间  write 		默认
st_ctim i节点状态的最后修改时间 chmod,chown ls -c

文件系统并不会维护inode的最后访问时间

---------------------------------函数futimens,utimennsat和utimes-------
#include <sys/stat.h>
int futimens(int fd, const struct timespec times[2]);
int utimensat(int dirfd, const char*path, const struct timespec times[2], int flag);//flag设置AT_SYMLINK_NOFOLLOW则符号链接本身就会被修改，默认是对符号链接进行解引用，并把文件的时间改成符号链接的时间

数组一个元素是访问时间，第二个元素是修改时间，（都是自从1970:1:1 00:00:00)以来所经过的秒数
  struct timespec {
      time_t tv_sec;        /* seconds */
      long   tv_nsec;       /* nanoseconds */
  };
times的解读:
1.times为NULL,则访问时间和修改时间两者都设置成当前时间
2.times指向timespec的数组，任一数组元素的tv_nsec的值为UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的tv_sec字段
3.times中任一数组元素的tv_nesc字段的值为UTIME_OMIT，则相应的时间戳保持不变，忽略相应的tv_sec字段
4.times中的元素是正常数值则设置对应时间戳

执行这些函数所要求的权限取决于times的值:
1.NULL时，或者两个元素的tv_nsec字段为UTIME_NOW时，进程的有效用户id必须等于该文件的所有者id或进程对该文件有写的权限，或者进程是超级用户进程
2.如果times非空并且任一tv_nsec字段不为UTIME_NOW或UTIME_OMIT，则进程的有效用户id必须等于该文件的所有者id同时进程对文件有写的权限，或者必须是超级用户进程
3.times非空并且两个元素的tv_nesc字段都为UTIME_OMIT，就不执行权限检查

#include <sys/time.h>
int utimes(const char *filename, const struct timeval times[2]);
//返回值 成功0 错误-1
struct timeval {
               long tv_sec;        /* seconds */
               long tv_usec;       /* microseconds */
};

但是无法修改ctime，因为调用了utimes函数会自动更新ctime

-------------------------------------函数mkdir,mkdirat和rmdir-------------
#include <sys/stat.h>
int mkdir(const char*pathname, mode_t mode);
int mkdirat(int dirfd, const char *pathname, mode_t mode);
//返回值 成功 0 错误-1
创建空目录（自动创建.和..)所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改（umask)

#include <unistd.h>
int rmdir(const char*pathname); //返回值 成功 0 错误-1
//必须是空目录才能执行成功，为此即使有另外进程打开此目录后也无法创建新文件

---------------------------------------读取目录-------------------
对某个目录具有访问权限的任一用户都可以读目录，但是为了防止文件系统产生混乱只有内核能够写目录本身
#include <dirent.h>
struct dirent {
       ino_t          d_ino;       /* Inode number */
       off_t          d_off;       /* Not an offset; see below */
       unsigned short d_reclen;    /* Length of this record */
       unsigned char  d_type;      /* Type of file; not supported
                                     by all filesystem types */
       char           d_name[256]; /* Null-terminated filename */
};

DIR *opendir(const char*pathname);
DIR *fdopendir(int fd); //返回值 成功 返回指针错误NULL(将已经打开的文件描述符转换成DIR结构)

struct dirent *readdir(DIR *dp); //返回值 成功 返回指针 错误或在目录尾部返回NULL(推测内部维护了当前要读取的指针,执行一次readdir后当前指针后移)

void rewinddir(DIR *dp); // The rewinddir() function resets the position of the directory stream dirp to the beginning of the directory.

int  closedir(DIR *dp); //返回值 成功 返回0，错误返回-1

long telldir(DIR *dp); //返回值与dp关联的目录中的当前位置   On success, the telldir() function returns the current location in the directory stream.  On error, -1 is returned, and errno is set appropriately.

void seekdir(DIR *dp, long loc);   seekdir - set the position of the next readdir() call in the directory stream.



#include <sys/types.h>
#include <dirent.h>

int dirfd(DIR *dirp); //dirfd - get directory stream file descriptor 返回值成功返回dirfd 失败返回-1

---------------------------函数chdir, fchdir和getcwd-------------------
当前工作目录是进程的一个属性
#include <unistd.h>
int chdir(const char* pathname);
int fchdir(int fd); //返回值 成功 0 错误-1
指定新的工作目录
#include <unistd.h>
char* getcwd(char *buf, size_t size); //返回值 成功 返回buf， 错误NULL get current working directory
缓冲区地址buf，缓冲区size
buf需要足以容纳绝对路径+空字符的大小


#include <unistd.h>
int chroot(const char *path); 
增加了系统的安全性，限制了用户的权力；
在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。

建立一个与原系统隔离的系统目录结构，方便用户的开发；
使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。

切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。
chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。


---------------------------设备特殊文件--------------------------
每个文件系统所在的存储设备都有主次设备号(dev_t类型)
主设备号标识设备驱动程序，此设备号标识特定的子设备
  #include <sys/sysmacros.h>

       dev_t makedev(unsigned int maj, unsigned int min);

       unsigned int major(dev_t dev); //返回主设备号
       unsigned int minor(dev_t dev); //返回次设备号

stat结构中st_dev是文件系统的设备号, st_rdev则是只有字符和块设备文件才有，包含了实际设备的设备号

---------------------------文件访问权限小结------------------------

S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSR
S_IRWXG = S_IRGRP | S_IWGRP | S_IXGRP
S_IRWXO = S_IROTH | S_IWOTH | S_IXOTH
常量		说明		对普通文件的影响				对目录的影响
S_ISUID 	setuid		执行时设置有效用户id 			(未使用)
S_ISGID 	setgid 		若S_IXGRP被设置则执行时setgid 	将在目录中创建的新文件的组id设置为目录的组id
						否则使强制性锁起作用（若支持)
S_ISVTX	    setbit 		在交换区缓存.text段(若支持)		限制在目录中删除和重命名文件


=================================第五章 标准I/O------------------
标准io是针对流进行的，而之前是采用文件描述符，当用标准IO库打开或创建一个文件时，是使得流和文件相关联
#include <stdio.h>
#include <wchar.h>
流的定向决定了所读写的字符是单字节还是多字节（宽）

//设置流的定向
int fwide(FILE *fp, int mode); //返回值 若流是宽字符则返回正值，若是窄则返回负，若流未定向则返回0
mode为负，则fwide则试图使得指定的流是窄定向（字节定向）
mode为正，则fwide则试图使得指定的流是宽定向
mode==0， 则fwide不试图设置流的定向，但返回标识该流定向的值
!!注意点:fwide并不改变已定向的流

-----------------------------标准输入输出错误---------------------
#include <stdio.h>
stdin, stdout, stderr对应了系统调用中常用的
STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO(#include <unistd.h>)

------------------------------缓冲-------------------------
标准I/O提供了三种类型的缓冲
1.全缓冲:
	在填满标准I/O缓冲区后才实际进行I/O操作，对于驻留在磁盘上的文件(当流涉及到文件)通常是由标准I/O实施全缓冲
	fflush()可以人为地冲洗流,!!注意点:在UNIX中，flush有两种意思，在标准I/O库方面，flush意味着将缓冲区的内容写到磁盘上（哪怕缓冲区没有满)，而在终端驱动程序方面意味着丢弃缓冲区的数据
2.行缓冲:
	在输入和输出遇到换行符时，标准I/O库执行实际的I/O操作，当流涉及到一个终端时（标准输入和标准输出）通常实施行缓冲
	!!注意点:因为缓冲区固定（所以只要填满了缓冲区哪怕没有写一个换行符也会进行实际的I/O）
			 任何时候只要通过标准I/O库要求从一个不带缓冲的流或者一个带着行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流(标准输入时,或者read(STDIN_FILENO)(不带缓冲的流)从内核中获取数据，会冲刷所有标准输出流)
3.不带缓冲:
	stderr一般是不带缓冲的
	上述一般是因为ISO C中要求的是:
	(1):当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲
	(2):标准错误绝对不是全缓冲
	所以一般系统是：标准错误是不带缓冲，指向终端设备的流是行缓冲，否则是全缓冲

//更改缓冲类型
#include <stdio.h>
void setbuf(FILE* restrict fp, char *restrict buf); //设置或关闭缓冲，带缓冲的话buf的大小必须为BUFSIZ（#include <stdio.h>)，NULL则为不带缓冲，当设置了buf为BUFSIZ后一般就变成了全缓冲，但是流和终端设备有关的话，某些系统仍然会将其设置为行缓冲
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
//mode:
	1._IOFBF   	全缓冲 //buff为NULL时则系统会自动选择合适的缓冲区
	2._IOLBF 	行缓冲 //buff为NULl时则系统会自动选择合适的缓冲区
	3._IONBF 	不缓冲 
//返回值 成功 0 错误非0


#include <stdio.h>
int fflush(FILE *fp); //fp为NULL时将所有输出流被刷新，否则刷新该流所有为写的数据进入内核，返回值 成功0 失败EOF

----------------------------------打开流--------------------------
#include <stdio.h>
FILE* fopen(const char *restrict pathname, const char *restrict type);
FILE* freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE* fdopen(int fd, const char* type);
//返回值 成功返回FILE*指针，失败NULL

freopn若fp已经打开则会关闭，若fp已经定向则会清除定向

(POSIX才有)fdopen会让fd和标准的I/O流相关联
!!注意点：fdopen不能对文件截断（因为fd已经打开)，fdopen也不能用追加来创建文件，因为fd存在则文件一定存在

type:
字符串	含义		解释			若文件已存在的动作	若文件不存在的动作 对应open系统调用中的mode
"r"		读			打开文件以读取	从头读				打开失败			O_RDONLY
"w"		写			创建文件以写入	销毁内容			创建新文件			O_WRONLY | O_CREAT | O_TRUNC
"a"		后附		后附到文件		写到结尾			创建新文件			O_WRONLY | O_CREAT | O_ADDEND
"r+"	读扩展		打开文件以读/写	从头读				错误				O_RDWR
"w+"	写扩展		创建文件以读/写	销毁内容			创建新文件		    O_RDWR   | O_CREAT | O_TRUNC
"a+"	后附扩展	打开文件以读/写	写到结尾			创建新文件			O_RDWD 	 | O_CREAT | O_APPEND
b的含义二进制文件(但是UNIX不区分)
!!注意点:
1.当文件以更新模式打开时（ '+' 作为上述模式参数值列表的第二或第三个字符），访问流可以进行输入和输出。然而输出不应直接紧随输入，而中间无对 fflush 函数或对文件定位函数（ fseek 、 fsetpos 或 rewind ）的调用，且输入不应直接紧随输出，而中间无对文件定位函数的调用，除非输入操作遇到文件尾。      ----------原因内部只记录了一个文件偏移量，若不进行文件偏移量重新设置，否则下一次读或写都是对于当前的文件偏移量
2.w或a当文件不存在时，不能确定新文件的访问权限（而open和creat则可以)

#include <stdio.h>
int fclose(FILE *fp); //返回值 成功 0 错误EOF
//在关闭之前会冲洗缓冲区的输出数据，缓冲区中的任何输入数据被抛弃
//当进程结束时（exit或main返回），所有打开的标准I/O流都关闭，所有不带缓冲的流都被刷新

--------------------------------读和写流------------------
1.每次读写一个字符
2.每次读写一行
3.每次读写一定长度

1.--------输入函数
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
//成功返回读取到字符，失败或到达文件尾部返回EOF
//getchar等同于getc(stdin) ,getc一般实现为宏
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp); //用于鉴定流是抵达了文件尾部还是错误  返回值 对应条件为真则返回非0，否则返回0

void clearerr(FILE *fp);//清除错误和文件结束标记

#include <stdio.h>
int ungetc(int c, FILE *fp); //将字符压回到读取的流(存在于缓冲区)中 返回值 成功返回c，错误EOF  内部会调用clearerr以便支持在文件尾部后压回
//scanf中的回车残留在缓冲区则是使用了这种技术

2.--------输出函数
#include <stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
putchar = putc(c, stdout) putc一般为宏

---------------------------------------------每次一行I/O---------------------------
#include <stdio.h>
char* fgets(char *restrict buf, int n, FILE *restrict fp); //n -1个字符送入buf，最后一个为空字符 fgets保留换行符
char* gets(char *buf); //返回值 成功返回buf，错误或到达文件尾返回NULL  gets不保留换行符  !!不推荐使用，缓冲区溢出问题

#include <stdio.h>
int fputs(const char *restrict str, FILE *restrict fp); //遇到0会停止
int puts(const char *str);  //输出会增加换行符
//返回值 成功 非负 失败EOF

fgets和fputs需要自己处理换行符

--------------------------------标准I/O效率----------
标准I/O库并不比read和write函数相比慢很多  通常系统调用与普通函数调用相比需要花费更多时间

------------------------------------二进制I/O(每次读写一定长度)-------------------------
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp); //nobj是读或写的对象个数 
//返回值 成功读或写的对象数  错误读可能是失败或者到达文件尾则返回少于nobj具体使用ferror或feof来判断， 写错误则返回少于nobj
eg:
 int arr[2];
 fread(arr, sizeof(int), 2, fp)
!!注意点：跨系统跨平台读取二进制的话需要注意内存对齐以及大小端，甚至是数据二进制的存储格式

-----------------------------------定位流--------------
1.ftell fseek long类型的偏移量
2.ftello fseeko off_t类型代替long
3.fgetpos fsetpos (便于移植)

#include <stdio.h>
long ftell(FILE *fp); //返回值 成功 当前文件偏移量 失败-1L
off_t ftello(FILE *fp); //返回值 成功 当前文件偏移量 失败(off_t)-1
int fgetpos(FILE *restrict fp, fpos_t *restrict pos); // 返回值 成功 0 错误 非0

int fseek(FILE *fp, long offset, int whence); //返回值 成功 0 失败 -1 
int fseeko(FILE *fp, off_t offset, int whence); //返回值 成功 0 错误 -1
int fsetpos(FILE *fp, const fpos_t* pos); //返回值 成功 0 错误 -1

void rewind(FILE *fp); //将流设置到文件起始位置

!!注意点:对于文本文件（win上面存在，unix/linux无视), whence只能设置为SEEK_SET，offset只能为0或ftell的返回值，因为当前偏移量可能不是以字节为单位来度量的

!!注意点:以上重新设置文件偏移量的函数，都会在执行之前刷先fflush(fp)
----------------------------------格式化I/O---------------
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char*restrict format, ...);
int dprintf(int fd, const char *restrict format, ...); 
			//返回值 成功 返回输出字符数，失败负数
int sprintf(char *restrict buf, const char* restrict format, ...);
			//返回值 返回存入到buf中的字符数， 若编码错误，返回负数
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
			//返回值，若buf足够大，则返回要存入数组的字符数目，否则是n，若编码错误，则负数

s系列中的buf会自动包含0，但是0不算在返回值内

format:
	%[flags][fldwidth][.precision][lenmodifier]convtype
	flags:
		'    	 将整数按千分位分组字符(大多数实现不支持)
		-	 	 在字段内左对齐输出（默认右边)
		+	 	 总是带符号的正负号
		' '(空格)如果第一个字符不是正负号，则在前面加入一个空格
		#	     加上进制的前缀如16进制0x
	
	fldwidth 	 表示字段最小宽度
	precision    表示字段最少位数，或者字符最大字节数 以上两个可以用*来代替，以便后面用变量来控制精度
																						eg:
																						printf("%*d", 3, i); 3替换*
	lenmodifier  说明参数类型
	     hh 	 signed / unsigned char
		 h       signed / unsigned short
		 l       signed / unsigned long 
		 ll      signed / unsigned long long 
		 j       intmax_t / uintmax_t
		 z       size_t
		 t       ptrdiff_t
		 L 	     long double

	convtype:
		d,i      有符号十进制
		o	     无符号八进制
		u		 无符号十进制
		x, X 	 无符号十六进制
		f,F 	 双精度浮点数
		e,E      指数格式双精度浮点数
		g,G 	 根据占位符对应的数据解释为f,F,e或E
		a,A 	 十六进制指数格式双精度浮点数
		c 	     字符(若lenmodifier指定为1则为宽字符)
	    s        字符串（若lenmodifier指定为1，则为宽字符)
		p        指向void的指针
		n        到目前为止，printf已经输出的字符数目将被写入到指针所指向带符号整形变量中， eg:
																							int i = 0;
																							printf("%s%n", "123", &i); // i = 3
		%        输出%
		C		 宽字符(XSL扩展)
		S        宽字符串(XSL扩展)


2.格式化输入-----------------
#include <stdio.h>
int scanf(const char*restrict format, ...);
int fscanf(FILE *restrict fp, const char* restrict format, ...);
int sscanf(const char* restrict buf, const char*restrict format, ...);
//返回值 赋值的输入项的个数，若出错或已经到达文件尾则返回EOF
 
%[*][fldwidth][m][lenmodifier]convtype
*可选：用于抑制转换，仍然按照转换说明的其余部分对输入进行转换，但是不放入参数中
fldwidth: 最大宽度
m可选: 用于%c或%s(迫使标准I/O缓冲区为其分配内存)，参数必须是指针地址，由调用者负责管理该内存
eg:
	char* ptr = NULL;
	scanf("%ms", &ptr);
	free(ptr);

convtype:
	d 	             有符号十进制数, 基数10
	i                有符号十进制，基数可以由输入格式决定
	O 				 无符号八进制（输入可以为有符号，但是会被强转)
	u 				 无符号十进制，基数为10（输入可以为有符号，但是会被强换)
	x,X              无符号十六进制（输入可以为有符号，但是会被强转)
	a,A,e,E,f,F,g,G  浮点数
	c
	s
	[                匹配列出的字符序列以]终止(对应的参数应该为char*并且具有内存) //效果为该参数必须为这个值，否则视为不匹配
	[^               匹配除字符以外的所有字符，以]终止   //效果为该参数一定不含有[^中的任意字符]
	p                指向void的指针
	n                同printf中的convtype:n
	%
	C
	S


----------------------------------实现细节-----------------------------
#include <stdio.h>
int fileno(FILE* fp); //返回值 与该流相关的文件描述符 POSIX扩展

---------------------------------临时文件-------------------
#include <stdio.h>
XXXXXXXXXXXXXXXXXXXXX不推荐使用 char* tmpnam(char *ptr);  //返回指向唯一路径名的指针 //不推荐使用，当多个进程都使用时可能会返回一个结果（尽管在每个进程看来都是唯一的）
XXXXXXXXXXXXXXXXXXXXX不推荐使用 FILE* tmpfile(void);  //若成功返回文件指针，失败NULL  创建临时文件（内部实现可能是creat(tmpnam(ptr), FILE_MODE); unlink(ptr))
tmpfile因为不是原子操作，所以可能有其他进程创建同名文件导致被删除的可能，所以也不推荐使用

#include <stdlib.h>
//随机创建目录
char* mkdtemp(char *template);  //返回值 成功返回指向目录名的指针，失败NULL   The directory is then created with  
permissions  0700.

//随机创建文件
int mkstemp(char *template); //返回值 成功返回文件描述符，错误-1 //template函数会将后6位替换成随机的唯一路径名 !!注意点:与tempfile不同，所创建的文件不会被自动删除，需要自己unlink.  The  file  is  created with permissions 0600, that is, read plus write for owner only.and returns an open(w+权限)
       file descriptor for the file.(因此需要自己close())
permissions 0600

以上两个template的最后6个字符必须是XXXXXX

------------------------------内存流---------------
#include <stdio.h>
//open memory as stream
FILE* fmemopen(void *restrict buf, size_t size, const char*restrict type);
//返回值 成功 返回流指针 失败NULL

如果buf为空，则fmemopen会分配size个字节数的缓冲区，当流关闭时缓冲区会被释放
type:
	r rb
	w wb           内存流被截断（第一个字节而填充0)与fopen中w的不同
	a ab            为在第一个null字节处写而打开
	r+ r+b rb+  
	w+ w+b wb+
	a+ a+b ab+      为在第一个null字节处读和写而打开
不适合二进制数据（fwrite中若有数据存在0)

#include <stdio.h>
FILE* open_memstream(char **bufp, size_t *sizep); 
#include <wchar.h>
FILE* open_wmemstream(wchar_t **bufp, size_t *sizep);
//返回值 成功 返回流指针 失败NULL
与fmemopen的不同:
1.只能写打开
2.不能指定自己的缓冲区，但是可以通过两个参数获取缓冲区地址和大小
3.关闭流后需要释放缓冲区
4.对流添加字节会增加缓冲区大小(继续写入)
	!!注意点:由于缓冲区是动态增长（推测std::vector如同)，所以当下一次写入数据时可能让之前的内存失效


======================================第六章：系统数据文件和信息================
-------------------口令文件-----------------------
/etc/passwd文件中的数据来源于<pwd.h>中的passwd结构体

 struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
//通过uid或用户名查询/etc/passwd下面的指定记录
#include <pwd.h>
struct passwd* getpwuid(uid_t uid);
struct passwd* getpwnam(const char* name); //返回值 成功返回指针 失败NULL

!!注意点：passwd结构信被定义为函数内部的静态变量
//查看passwd文件中的信息
#include <pwd.h>
struct passwd* getpwent(void) //返回值 成功返回指针 失败或达到文件尾部返回NULL  
返回/etc/passwd中下一个记录项

void setpwent(void); //返回/etc/passwd的开头
void endpwend(void); //关闭文件

-------------------------shadow密码------------------
单向加密:不能从加密口令中猜到原来的口令
但是可以通过猜测明文然后采用单向加密算法后来比较加密口令

  struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */  //可以更改的最小天数
               long  sp_max;      /* Max # of days between changes */  //必须更改的最大天数
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */  //一般比sp_max小7左右
               long  sp_inact;    /* # of days after password expires   expire到期
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
#include <shadow.h>
struct spwd* getspnam(const char* name);
struct spwd* getspent(void);
//返回值 成功返回指针 失败NULL

struct spwd *getspent(void);
void setspent(void);
void endspent(void);


-----------------------------------------组文件--------------
#include <grp.h>
 struct group {
               char   *gr_name;        /* group name */
               char   *gr_passwd;      /* group password */
               gid_t   gr_gid;         /* group ID */
               char  **gr_mem;         /* NULL-terminated array of pointers
                                          to names of group members */
           };

struct group
#include <grp.h>
struct group* getgrgid(gid_t gid);
struct group* getgrnam(const char* name); //返回值 成功指针 失败NULL

#include <grp.h>
struct group* getgrent(void);  //返回值 成功 指针 失败或到达文件尾部 NULL
void setgrent(void);
void endgrent(void);

-------------------------------------------附属组id--------------
一个用户可以参与多个组
#include <unistd.h>
//gidsetsize最大获取个数 grouplist会被填入调用进程的各个附属组id
//若gidsetsize为0则返回附属组的个数，以便用户确定传入数组的大小
int getgroups(int gidsetsize, gid_t groupllist[]); //返回值 成功 返回附属组id数目 失败-1

#include <grp.h> //linux
//ngroups说明了数组的元素个数，由root调用后会修改调用进程的附属组id表
//ngroups不能超过NGROUPS_MAX
int setgroups(int ngroups, const gid_t grouplist[]);

#include <grp.h>
//会调用getgrent找到username，然后初始化附属组id表，以basegid为开始
int initgroups(const char* username, gid_t basegid); //以上两个返回值 成功0 失败-1

----------------------------------------其他数据文件---------------
1.get函数:
	读取下一个记录，通常返回指向一个结构体的指针，若已经到达文件尾部就NULL(内部维护了一个静态结构体成员，如list，get则返回current)
2:set函数:
	设置读取记录为数据文件开始处
3:end函数:
	关闭数据文件

------------------------------------------登录账号记录
utmp文件记录了当前登录到系统的各个用户(man 5)
wtmp文件跟踪各个登录和注销事件(man 5)
/var/run/utmp /var/log/wtmp

-------------------------------------------系统标识--------------------
#include <sys/utsname.h>

//通过该参数赋值
int uname(struct utsname* name); //成功返回非负数 失败-1
     struct utsname {
               char sysname[];    /* Operating system name (e.g., "Linux") */
               char nodename[];   /* Name within "some implementation-defined
                                     network" */
               char release[];    /* Operating system release (e.g., "2.6.28") */
               char version[];    /* Operating system version */
               char machine[];    /* Hardware identifier */
           #ifdef _GNU_SOURCE
               char domainname[]; /* NIS or YP domain name */
           #endif
           };

#include <unistd.h>
int gethostname(char* name, int namelen); //返回值 成功 0 错误-1
主机名通常在系统自举时设置/etc/rc或init取自一个启动文件

----------------------------------------时间和时间例程------------------
#include <time.h>
//返回当前时间和日期
time_t time(time_t* calptr); //成功返回时间值 失败-1
如果参数非空则将记录在calptr所指向的内存中

#include <sys/time.h>
 struct timespec {
               time_t   tv_sec;        /* seconds */
               long     tv_nsec;       /* nanoseconds */  毫秒ms 微秒us 纳秒ns
           };

int clock_gettiem(clockid_t clock_id, struct timespec* tsp);
//返回值 成功 0 出错-1
clock_id:
	  CLOCK_REALTIME
              System-wide  clock  that  measures  real (i.e., wall-clock) time.  (1970-01-01 00:00)
	  CLOCK_MONOTONIC(单调时间)
		      不受系统管理员手动更改时间导致的时间不连续跳跃的系统时间 
      CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)
              Per-process CPU-time clock (measures CPU time consumed by all threads in the process).

      CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12)
              Thread-specific CPU-time clock.

	







============================================
第七章:进程环境

进程终止的方法:
1.main返回(c99才规定main的返回值为0)
2.调用exit
3.调用_exit 或者_Exit
4.最后一个线程从其启动例程返回
5.从最后一个线程调用pthread_exit

(异常退出)
	6.调用abort
	7.接到一个信号
	8.最后一个线程对取消请求做出响应

在调用main函数前先调用一个特殊的启动例程，可执行程序会将此启动例程指定为该程序的起始地址
如果将启动例程(系统调用exec函数)用c代码写exit(main(argc, argv)) 通常汇编实现（通过编译器)

1.退出函数
#include <stdlib.h>
void exit(int status);(执行一些清理处理，先对于atexit()函数记录的函数指针进行执行，然后对于所有打开流调用fclose(),最后调用_exit 或者_Exit)  main中return等价

void _Exit(int status);(直接返回内核)
#include <unistd.h>
void _exit(int status);(直接返回内核)

2.函数atexit
#include <stdlib.h>
int atexit(void (*func)(void));(记录使用exit函数后需要调用的函数指针)
!!注意点:内核执行某一个程序的唯一方法是调用exec函数
进程自愿终止的唯一方式是显示或者隐式（exit())调用_exit或者_Exit

ISO c 和 posix.1都规定argv[argc]是NULL

------------------环境表------------------
如同命令参数表argv一样，每个程序都接收到一个环境表，extern char **environ记录
历史上int main(int argc, char *argv[], char *envp[]); //但不符合ISO C的规定，所以通常使用environ或者getenv和putenv来操作

------------------------c程序的存储空间布局----------------

1. .text 
	cpu执行的机器指令部分，可共享（文本编辑器，c编译器和shell）相同的指令在存储器中只需要一个部分即可，一般只读
2. 初始化数据段(.data数据段)
	明确地赋初值的全局变量:int max = 0;
3. 未初始化数据段 .bss段
	在程序开始执行之前，内核将此段中的数据初始化为0或者为NULL: long sum[100];	
4. 栈区
	向下伸长逐渐变小)	
5. 堆区
	向上伸长(逐渐变大)
//size a.out无法得出栈和堆的大小，因为在运行时(exec函数执行时)才知道
//a.out中还有若干其他类型的段，例如，包含符号表的段、包含调试信息的段以及包含动态共享库链接表的段等等。在程序执行时是直接忽略这些段
//a.out只会记录.text和初始化数据段
//可以使用size命令查看
//栈帧不一定是要向下伸展逐渐变小
	//可能是用链表来实现的
------------------------------共享库----------------------------
库的存在会增加部分运行时的开销（当调用库函数时)但是优点是可以替换库文件而不需要修改源文件代码或者重新编译可执行程序

gcc -static //阻止gcc使用共享库,默认使用

--------------------------------存储空间分配---------------------
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);//该空间中的每一bit都会初始化为0,由于存在内存对其，所以所分配的大小应该是大于等于nobj*size的
void *realloc(void* ptr, size_t newsize);
//返回的指针一定是适当内存对齐的
void free(void *ptr);

----------------------------环境变量--------------------
#include <stdlib.h>
char* getenv(const char *name); //获取该name所对应的环境变量值
int putenv(char* str); //name=value的字符串放入到环境表中
int setenv(const char* name, const char* value, int rewrite); //rewirte为0则不删除已有的定义，否则删除
int unsetenv(const char* name); //删除name的定义，即使不存在也不会错

----------------------------函数setjmp和longjmp--------------
#include <setjmp.h>
int setjmp(jmp_buf env); //直接调用返回0，否则返回longjmp中val的值

void longjmp(jmp_buf env, int val); //设置env，并且使得栈帧回到调用setjmp的栈帧中
!!注意点:跳转的后变量的值:全局 静态 volatite(不让编译器进行优化)修饰的变量值不变，放在寄存器中的变量则会复原到调用setjmp之前的值

-------------------------函数getrlimit和setrlimit---------------
//进程的资源限制,由0号进程建立然后由后续进程继承
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);

       struct rlimit {
               rlim_t rlim_cur;  /* Soft limit */
               rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
           };
resource的取值:
	RLIM_INFINITY 无限制
	RLIMIT_AS 进程总的可用存储空间的最大字节
	RLIMIT_CORE core文件的最大字节数, ulimit -a
				core file size          (blocks, -c) 0
	RLIMIT_CPU CPU时间的最大量值（秒），当超过该软限制时，向进程发送SIGXCPU信号
	RLIMIT_DATA 数据段的最大字节长度(初始化数据，未初始化数据，以及堆的总和
	RLIMIT_FSIZE 可以创建的文件的最大字节长度，超过软限制时，发送SIGXFSZ信号
	RLIMIT_MEMLOCK 一个进程使用mlock能够锁定在存储空间中的最大字节长度
	RLIMIT_MSGQUEUE 进程为POSIX消息队列可分配的最大存储字节数
	RLIMIT_NICE nice的值影响进程的调度优先级,nice可以设置最大限制,ps -fl中的nice
	RLIMIT_NOFILE 每个进程能打开的最多文件数，会影响sysconf函数在参数_SC_OPEN_MAX中的返回值
	RLIMIT_NPROC 每个实际用户ID可拥有的最大子进程数，
	RLIMIT_NPTS 用户可同时打开的伪终端的最大数量
	RLIMIT_RSS 最大驻内存集字节长度（RSS),如果可用的物理存储器非常少，则内核将从进程处取回超过RSS的部分
	RLIMIT_SBSIZE 在任一给定时刻，一个用户可以占用的套接字缓冲区的最大字节
	RLIMIT_SIGPENDING 一个进程可排队的信号最大数量
	RLIMIT_STACK 栈的最大字节长度
	RLIMIT_SWAP 用户可消耗的交换空间的最大字节
	RLIMIT_VMEM 等价于RLIMIT_AS
	资源限制影响到调用进程并由子进程继承

============================================第八章 进程控制=====================
通常PID0 为调度进程，也称交换进程是内核的一部分不执行任何磁盘的程序，也称系统进程
ps:自举 计算机必须具备自举能力将自己所有的元件激活，以便能完成加载操作系统这一目的，然后再由操作系统承担起那些单靠自举代码无法完成的更复杂的任务
PID1 为init进程，在自举过程结束时由内核调用，负责在自举内核后启动系统，读取与系统相关的初始化文件(/etc/rc* /etc/inittab /etc/init.d ，并将系统引导到一个状态（如多用户，单用户，维护...)，init进程绝不会终止，虽然是普通的用户进程（但是是root来执行)，将成为所有孤儿进程的父进程

#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
uid_t geteuid(void); e是有效的缩写
gid_t getgid(void);
gid_t getegid(void);

#include <unistd.h>
pid_t fork(void); //出错返回-1，否则父进程返回子进程pid，子进程返回0
fork后的子进程享有父进程中数据空间，堆和栈的副本，但共享.text字段

!!!注意点:由于fork后一般加上exec,所以很多实现并不执行一个父进程的拷贝，而是使用了写时复制(COW Copy-On-Write)技术，内核将数据空间，堆栈设置为只读权限，写时制作副本，父进程所有打开的文件描述符都被复制到子进程中,文件共享（文件状态标志，文件偏移量，v节点指针)
!!fork共享的有:
	文件共享
	实际用户id，实际组id，有效用户id，有效组id
	附属组id
	进程组id
	会话id
	控制终端
	设置用户id标志和设置组id标志
	当前工作目录
	根目录
	文件模式创建屏蔽字
	信号屏蔽和安排
	对任意打开文件描述符的执行时关闭标志
	环境
	连接的共性存储段
	存储映像
	资源限制

vfork()允许调用者控制哪些部分共享
vfork和fork的区别:
	1.不将父进程的地址空间完全复制到子进程中，因为用vfork通常后面接exec，在调用exec或者exit之前，在父进程的空间运行(注意!!)
	2.vfork保证子进程先执行（但是要是子进程依赖于父进程的动作，则会导致死锁)，子进程调用exec或者exit后父进程才可能被调度

!!!注意点:sizeof是编译期得知

--------------------------------------函数exit-----------
exit是否对标准io流刷新是未定义行为（取决于实现），但目前不刷新，因为最后仍然会由内核关闭所有已经打开的文件描述符

不管进程如何终止，都会执行内核中的一段代码，这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器

僵尸进程:一个已经终止，但是父进程尚未对起进行善后处理（wait waitpid获取终止进程的有关信息，释放它仍占用的资源) ps可以打印

一个init的子进程：可能是init直接产生的，也可能是由init收养的（其父进程已经终止)

------------------------------------函数wait和waitpid------------------
wait waitpid 如果其所有子进程还在运行，则阻塞
			 如果一个子进程已经终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立刻返回
			 如果它没有任何子进程，则错误返回

#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);
waitpid中pid的作用
1. pid == -1 等待任意子进程，同wait
2. pid > 0   等待与pid相等的子进程
3. pid == 0 等待组id等于调用进程组ID的任意子进程
4. pid < -1 等待组id等于pid绝对值号的任意子进程

options 为0或者按位或
	WCONTINUED 若实现支持作业控制，那么由pid指定的任意子进程在停止后已经继续，但其状态尚未报告，返回其状态
	WNOHANG 若pid指定的子进程不是立即可用的，则waitpid不阻塞，此时返回0
	WUNTRACED 若实现支持作业控制，而由pid指定的任意子进程已处于停止状态，并且状态自停止以来为报告过，则返回其状态，WIFSTOPPED宏确定返回值是否对应于一个停止的进程

错误返回0或-1,成功返回终止的进程号
waitpid可以控制是否阻塞

status宏 
WIFEXITED(status)	若为正常终止子进程返回的状态，则为真，对于这种情况可执行WEXITSTATUS(status)获取子进程传递给exit或_exit参数的低8位
WIFSIGNALED(status)  若为异常终止子进程返回的状态，则为真，执行WTERMSIG(status)获取使子进程终止的信号编号,另外定义了宏WCOREDUMP的话，若已产生core文件，则为真
WIFSTOPPED(status) 若为当前暂停子进程的返回的状态，则为真，执行WSTOPSIG(status)获取使得子进程暂停的信号编号
WIFCONTINUED(status) 若在作业控制暂停后已经继续的子进程返回了状态，则为真

--------------------------------函数waitid---------------------
#include <sys/wait.h>
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
	成功返回0，错误返回-1
idtype:
	P_PID 等待一特定进程：id包含要等待子进程的进程id
	P_PGID 等待一特定进程组中的任意进程：id包含要等待子进程的进程组id
	P_ALL 等待任一子进程: 忽略id

options 按位或来操作
WCONTINUED 等待一进程，它以前曾被停止，此后又继续，但状态为报告
WEXITED 等待已经退出的进程
WNOHANG 如无可用的子进程退出状态，立刻返回而非堵塞
WNOWAIT 不破坏子进程退出状态，该子进程退出状态可以由后续的wait waitpid waitid来调用
WSTOPPED 等待一进程，它已经停止，但状态未报告

--------------------------------函数wait3 wait4-----------------------
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

pid_t wait3(int *statloc, int options, struct rusage *resage); resage资源统计信息包括用户cpu时间总量，系统cpu时间总量，缺页次数，接收到信号的次数(man getrusage)
pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);
成功返回进程id，否则返回-1

----------------------------------竞争条件-----------------
轮询polling
	while (getppid() != 1)
		sleep(1); //浪费cpu时间

---------------------------------函数exec---------------
exec不创建新进程，直接让磁盘上的一个程序替换当前进程的.text .data heap stack
需要注意必须对该文件有执行权限，然后必须是普通文件
 #include <unistd.h>

 extern char **environ;

 //若在使用ISO C之前，应该让最后一个参数为(char *)NULL
 int execl(const char *path, const char *arg, ...
                       /* (char  *) NULL */);

 int execv(const char *path, char *const argv[]);

 int execle(const char *path, const char *arg, ...
                      /*, (char *) NULL, char * const envp[] */);

 int execve(const char *pathname, char *const argv[], char *const envp[]);

 int execlp(const char *file, const char *arg, ...
                       /* (char  *) NULL */);
 int execvp(const char *file, char *const argv[]);

 int fexecve(int fd, char *const argv[], char *const envp[]);  成功不返回，错误返回-1

 file会根据PATH环境变量来找可执行文件若该文件不是二进制文件而视为shell脚本

 如何记忆:p表示参数为filename使用PATH环境变量，l表示取参数表，v表示argv[],e表示envp[],f表示fd


