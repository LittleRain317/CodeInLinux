第一章:Unix基础

1.内核的接口被称之为系统调用(System call)
	公用函数库建立在系统调用接口之上（进一步封装）

时钟时间:进程运行的时间总量
用户cpu时间:执行用户指令的时间量
系统时间为该进程执行内核程序所经历的时间可用time命令查看

================================打印错误码===================
    #include <stdio.h>

       void perror(const char *s);
  #include <string.h>

       char *strerror(int errnum);

======================================第三章:文件I/O===================
所有打开的文件都通过文件描述符来引用

文件描述符中特殊的三个数值0 stdin 1 stdout 2 stderr
STDIN_FILENO STDOUT_FILENO STDERR_FILENO 定义在<unistd.h>

范围是0 ~ OPEN_MAX - 1

---------------------函数open和openat------------
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */); //即使参数完全一致，open的返回值也会是一个新的文件描述符，开启一个新的文件表项，但参数相同时，文件表项中的v节点指针指向同一个v节点
//内核会以进程的有效用户id和有效组id来检查权限
int openat(int dirfd, const char *path, int oflag, ... /* mode_t mode */);
成功返回文件描述符，否则返回-1

!!注意点:用open或creat创建文件时（若文件已经存在，则文件的访问权限不会因为mode的参数而改变)

按位或来操作oflag
O_RDONLY	只读打开 (需要有读权限)
O_WRONLY	只写打开 (需要有写权限)
O_RDWR      读、写打开 (需要有读写权限)
O_EXEC		只执行打开
O_SEARCH	只搜索打开（应用于目录)
以上必须执行一个，下面是可选的(使用|来连接)

O_APPEND	每次写时追加到文件的尾端,（即在write操作时会修改文件表项中的文件偏移量为文件尾部，将lseek(fd, 0, SEEK_END)和open(path, O_WRONLY)封装成一个原子操作)
O_CLOEXEC	把FD_CLOEXEC常量设置为文件描述符标志,(若设置了则在exec时关闭该文件描述符)
O_CREAT		若文件不存在则创建它，使用此选项时，open函数需要mode参数，使用mode指定该新文件的访问权限
O_DIRECTORY	如果path引用的不是目录，则出错
O_EXCL		如果同时指定了O_CREAT，而文件已经存在，则出错，用此可以测试一个文件是否存在，如果不存在则创建该文件
O_NOCTTY 	如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端
O_NOFOLLOW 	如果path引用的是一个符号链接，则出错
O_NONBLOCK 	如果path引用的是一个FIFO，一个块文件或一个字符文件则此选项为文件的本次打开操作和后续的io操作设置非阻塞方式
O_SYNC 		使每次write等待物理i/o完成，包括该write操作引起的文件属性更新的i/o
O_TRUNC 	如果此文件存在，而且为只写或读-写成功打开，则将其长度截断为0(需要有写权限，猜想:>重定向使用了O_TRUNC
O_TTY_INIT 	如果打开一个还未打开的终端设备，设置非标准termios参数值，使其符合single unix specificaion标准
O_DSYNC 	使每次write要等待物理io操作完成，但是如果该写操作并不影响读取刚写入的数据，则不需要等待文件属性被更新
O_RSYNC		使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作完成

dirfd参数说明:
1.当path指定的是绝对路径时，dirfd参数被忽略，openat相当于open
2.path为相对路径时，dirfd参数指出了相对路径名在文件系统中的开始地址，dirfd参数是通过打开相对路径名所在的目录来获取的
3.path为相对路径名，dirfd参数为AT_FDCWD，路径名在当前工作目录中获取，openat函数在操作上和open函数相同

概念:TOCTTOU time-of-check-to-time-of-use
如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的,因为两个调用非原子操作

--------------------------------------------函数creat-----------------
#include <fcntl.h>
int creat(const char *path, mode_t mode);
等价于open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);

---------------------------------------------函数close-----------------------
#include <unistd.h>
int close(int fd); //返回值 若成功返回0 失败-1
关闭一个文件时还会释放该进程加在该文件上的所有记录锁
当一个进程结束时，内核自动关闭它所有打开的文件

-------------------------------------函数lseek----------------------
文件偏移量：相对于开始处的计算的字节数
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence); //返回值 成功：新的文件偏移量，失败-1  !!注意点:这影响了下一次read或者write的位置，在调用lseek后未使用read或者write的话文件偏移量还是不会变的

若whence是SEEK_SET,	则文件的偏移量设置为距离文件开始处offset个字节
		  SEEK_CUR, 则文件的偏移量设置为当前值加offset，offset可正负
		  SEEK_END, 则文件的偏移量设置为文件长度加offset，offset可正负(若文件偏移量大于文件长度，则下一次写的操作会加长该文件并在文件中构成一个空洞（所有中间都被置位0，但这一部分是否占用磁盘空间取决于文件系统)

---------------------------------------函数read----------------------
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes); //返回值 成功:读取到的字节数若到文件尾部返回0，错误返回-1

-----------------------------------------函数write-----------------
#include <unistd.h>
ssize_t write(int fd, const void* buf, size_t nbytes); //返回值 成功:以写的字节数，错误返回-1

------------------------------------I/O的效率-----------------
操作系统试图使用高速缓存技术来将相关文件放在内存中以便重复数据的读写

大多数文件系统为了改善性能都是用预读技术

所谓不带缓冲是指用户层没有缓存，通过系统调用直接对磁盘文件进行读写，但是对于内核来说，还是进行了缓存，内核现将数据写到内核缓冲存储器中，当缓冲存储器溢出时再进行实际的IO操作

标准IO（带缓冲的IO）,标准IO通过库函数提供了无缓冲IO的带缓冲IO接口,在用户层建立一个流缓存区，库函数向流缓存区读写数据，流缓存区溢出时进行系统调用，即再调用无缓冲的IO

无缓冲的IO操作数据流向路径：数据——内核缓存区——磁盘

标准IO操作的数据流向：数据——流缓存区——内核缓存区——磁盘

-------------------------------------文件共享--------------------
每个进程在进程表中有一个记录项，记录项包含文件描述符和指向文件表项的指针

--------------------------------原子操作-------------------
原子操作:由多步组成的一个操作，如果该操作原子地执行则要不执行完，要不不执行，不可能执行所有步骤的一个子集
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset); //返回值 成功读到的字节数，到达文件尾返回0，错误返回-1
ssize_t pwrite(int fd, const void* buf, size_t nbytes, off_t offset); //返回值 成功返回已写的字节数，失败返回-1
以上两个函数将lseek和read或write进行了原子操作的封装

----------------------------函数dup和dup2-----------------------

#include <unistd.h>
int dup(int fd); //返回当前可用的文件描述符的最小值
int dup2(int fd, int fd2); 返回值 成功返回新的文件描述符，出错则返回-1 //原子操作
fd2来指定新的文件描述符，如果fd2已经打开，则先关闭，如果fd == fd2则直接返回fd2不关闭，否则fd2的FD_CLOEXEC文件描述符标志就被清除，这样子fd2在进程调用exec是打开状态

!!注意点:每一个文件描述符都有自己的一套文件描述符标志(文件描述符标志目前只有FD_CLOEXEC)
!!注意点:文件描述符标志和文件状态标志不同，文件状态标志取决于open函数中oflag参数

输入输出重定向的实现与dup有关，2>&1表示的是将fd2重定向至fd1所指向的文件表项 eg: dup2(fd1, fd2);这番操作后文件指针指向同一个文件表项
-----------------------------函数sync,fsync,fdatasync------------------
延迟写(delayed write):向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些时候(当要重新使用该缓冲区时)再写入磁盘

#include <unistd.h>
int fsync(int fd);  //只对由文件描述符fd指定的一个文件起作用，并且等待写入到磁盘结束才返回,会同步更新文件的属性
int fdatasync(int fd); //返回值 成功0 错误-1,类似fsync，但是只影响文件的数据部分
void sync(void); //只是将所有修改过的块缓冲区写入到队列中，并不等待实际的硬盘写入(update守护进程周期性调用sync函数，sync命令也会调用该函数)

---------------------------函数fcntl-------------------
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */); //修改已经打开的文件属性，返回值 成功依赖于cmd，失败-1
五种功能:
1.复制一个已有的文件描述符cmd = F_DUPFD 或 cmd = F_DUPFD_CLOEXEC)
2.获取/设置文件描述符标志(cmd = F_GETFD 或 cmd = F_SETFD)
3.获取/设置文件状态标志(cmd = F_GETFL 或 cmd = F_SETFL)
4.获取/设置异步i/o所有权(cmd = F_GETOWN 或 cmd = F_SETOWN)
5.获取/设置记录锁(cmd = F_GETLK, F_SETLK F_SETLKW)


	F_DUPFD 			复制文件描述符fd，如同dup(fd, fd2),
	F_DUPFD_CLOEXEC 	复制文件描述符，设置与新描述符关联的FD_CLOEXEC文件描述符标志，返回新的文件描述符
	F_GETFD				对应于fd的文件描述符标志作为函数值返回，(目前实现当前只定义了FD_CLOEXEC, 该项数据在进程表项中)
	F_SETFD				对于fd设置文件描述符标志，新标志值按照第3个参数设置
	F_GETFL 			对应于fd的文件状态标志作为函数值返回
						O_RDONLY
						O_WRONLY
						O_RDWR
						O_EXEC
						O_SEARCH
						O_APPEND
						O_NONBLOCK
						O_SYNC 等待写完成（数据和属性)
						O_DSYNC 等待写完成(仅数据)
						O_RSYNC 同步读和写
						O_FSYNC	等待写完成
						O_ASYNC 异步I/O
		
						如何检验:
			if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)
			{
				err_sys("fcntl error for fd %d", atoi(argv[1]));
			}
			switch (val & O_ACCMODE)
			{
			case O_RDONLY:
				printf("read only");
				break;
			case O_WRONLY:
				printf("write only");
				break;
			default:
				err_dump("unknown access mode");
			}

			if (val & O_APPEND)
				printf(", append");
			if (val & O_NONBLOCK)
				printf(", nonblocking");
			if (val & O_SYNC)
				printf(", synchronous writes");
#if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)
			if (val & O_FSYNC)
				printf(", synchronous writes");
#endif
	F_SETFL 			可以修改的有O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, O_ASYNC	

	!!注意点在设置FL或者FD时，应该先获取当前的值，然后采用位运算计算出新的标志，之后再来设置
	F_GETOWN 			获取当前接收SIGIO和SIGURG信号的进程id或进程组id
	F_SETOWN 			设置接收SIGIO和SIGURG信号的进程id或进程组id，arg为正则表示进程id，负则表示arg绝对值的进程组id

----------------------------函数ioctl--------------------
 #include <sys/ioctl.h>

 int ioctl(int fd, unsigned long request, ...); //返回值 出错返回-1，成功返回其他
通常，需要包含设备专用的头文件比如终端i/o的ioctl命令需要头文件<termios.h>


=====================================第四章：文件和目录====================
-----------------函数stat, fstat, fstatat和lstat------------------
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf); //文件有关信息的数据结构 ls -l
int fstat(int fd, struct stat *buf); //fd上打开文件的有关信息
int lstat(const char *restrict pathname, struct stat *restrict buf); //pathname为符号链接时返回符号连接信息,而非所链接的文件信息
int fstatat(int dirfd, const char *restrict pathname, struct stat *restrict buf, int flag); //对于当前打开目录dirfd的路径名返回文件信息
flag 控制是否跟随者一个符号链接
//flag为AT_SYMLINK_NOFOLLOW时，返回链接本身信息
//dirfd为AT_FDCWD时，且pathname为相对路径时，fstatat会计算相对于当前目录的pathname参数，否则是相对于dirfd的相对路径
//如果pathname为绝对路径时，dirfd参数会被忽略

 //返回值 成功0 失败-1

----------------------------文件类型-------------
struct stat中st_mode记录了下列信息
1.普通文件(文本或者二进制数据，有别于二进制可执行文件二进制可执行文件需要elf)
2.目录文件:对于一个目录文件具有读权限的任一进程都可以读该目录的内容，但只有内核可以直接写目录文件，进程需要使用函数来修改目录
3.块设备文件:每次访问以固定长度为单位进行，提供对设备带缓冲的访问
4.字符设备文件:不带缓冲的访问
5.FIFO:（pipe）进程间通信
6.Socket:进程的网络通信，也可用于在一台主机上进程之间的非网络通信
7.符号连接
<sys/stat.h>下的宏用于判断文件类型
参数为st_mode
S_ISREG() ：普通文件
S_ISDIR() ：目录文件
S_ISCHR() ：字符文件
S_ISBLK() ：块文件
S_ISFIFO() ： 管道文件或队列文件
S_ISLNK() : 软链接符号连接
S_ISSOCK() : 套接字

S_ISUID S_IDGID常量可以&st_mode来判断文件是否具有其他属性（setuid和setgid,linux笔记中有提及)

从stat结构中确定进程间通信（IPC)对象的类型
参数为stat结构的指针
S_TYPEISMQ() : 消息队列
S_TYPEISSEM() : 信号量
S_TYPEISSHM() : 共享存储对象

#define S_IFMT  00170000 //is file mask type
#define S_IFSOCK 0140000
#define S_IFLNK	 0120000
#define S_IFREG  0100000
#define S_IFBLK  0060000
#define S_IFDIR  0040000
#define S_IFCHR  0020000
#define S_IFIFO  0010000
#define S_ISUID  0004000
#define S_ISGID  0002000
#define S_ISVTX  0001000

#define S_ISLNK(m)	(((m) & S_IFMT) == S_IFLNK)
#define S_ISREG(m)	(((m) & S_IFMT) == S_IFREG)
#define S_ISDIR(m)	(((m) & S_IFMT) == S_IFDIR)
#define S_ISCHR(m)	(((m) & S_IFMT) == S_IFCHR)
#define S_ISBLK(m)	(((m) & S_IFMT) == S_IFBLK)
#define S_ISFIFO(m)	(((m) & S_IFMT) == S_IFIFO)
#define S_ISSOCK(m)	(((m) & S_IFMT) == S_IFSOCK)

----------------------------------------设置用户id和用户组id------------
进程包含了至少这些id:
|实际用户id
|实际组id 		我们实际上是谁(谁运行的进程)
------
|有效用户id
|有效组id
|附属组id 		用于文件访问权限检查(可以看做是进程对应的程序文件的拥有者,用户组)(一般等于实际用户id实际组id,当文件具有其他属性如setuid和setgid时则有效id就会变成setuid和setgid中的值)
------
|保存的设置用户id
|保存的设置组id	由exec函数保存包含了有效用户id和有效组id的副本
------
文件所有者st_uid,组所有者st_gid
st_mode中设置特殊标志的话，可以实现文件其他属SetUid和SetGid
用S_ISUID和S_ISGID来测试是否设置了setuid或setgid

---------------------------------------文件访问权限-----------------------
st_mode同时包含了文件的访问权限

S_IRUSR 				用户读
S_IWUSR 				用户写
S_IXUSR 				用户执行

S_IRGRP 				用户组读
S_IWGRP 				用户组写
S_IXGRP 				用户组执行

S_IROTH 				其他读
S_IWOTH					其他写
S_IXOTH 				其他执行

---------------------------------新文件和目录的所有权------------
新文件的用户id设置为进程的有效用户id, 组id取决于实现
1.新文件的组id可以是进程的有效组id
2.新文件的组id可以是它所在的目录的组id(linux中新文件的组id默认为进程的有效id，除非所在目录设置了setGid)

---------------------------------函数access和faccessat----------------
当open函数打开一个文件时，默认是用有效用户id和有效组id来执行权限测试，但有时希望按照实际的(所登录的当前用户用户组)
#include <unistd.h>
int access(const char* pathname, int mode);
int faccessat(int dirfd, const char * pathname, int mode, int flag);
//返回值 成功0 错误-1

dirfd为AT_FDCWD时，pathname为当前目录的相对路径（否则就以dirfd的目录作为相对)
pathname为绝对路径时忽略dirfd

mode R_OK 测试读权限
	 W_OK 测试写权限
	 X_OK 测试执行权限
	 F_OK 测试是否存在

flag参数为AT_EACCESS的话则为有效用户id和有效组id
	     AT_SYMLINK_NOFOLLOW
               如果pathname是符号链接，请不要取消引用它：而是返回有关链接本身的信息
			0是默认实际

----------------------------------函数umask-----------------
#include <sys/stat.h>
mode_t umask(mode_t cmask);//返回值之前的umask
参数cmaks为文件访问权限的按位|

!!注意点:当创建文件时，若想要确保指定的文件访问权限已经有，最好先使用umask来修改当前的umask值，否则可能会因为当前的umask值关闭对应权限

---------------------------------函数chmod和fchmod和fchmodat
#include <sys/stat.h>
//为了修改文件权限，进程的有效用户id必须等于文件的所有者id，或者该进程具有超级用户权限
int chmod(const char* pathname, mode_t mode); //在指定文件上操作
int fchmod(int fd, mode_t mode); //在已经打开的文件进行操作
int fchmodat(int dirfd, const char*pathname, mode_t mode, int flag); //flag设置了AT_SYMLINK_NOFOLLOW时不会跟随链接文件，而是链接文件本身
//返回值 成功0 错误-1
mode为上述9个文件访问权限以及S_ISUID S_ISGID S_ISVTX 分别对应setuid setgid sbit
							 S_IRWXU S_IRWXG S_IRWXO

!!注意点:需要注意的是进程所属的有效用户id必须和文件拥有者id相匹配，否则错误
		 其次，若进程的有效gid或者附属gid不等于文件的gid则mode若是setuid和setgid会失效，但是返回成功

---------------------------------粘着位--------
S_ISVTX setbit (历史原因叫做S_IsSaved-text bit,最初因为加载文件速度的原因，将一份程序的.text段放在了交换空间里，以便下次执行程序更快地加载到内存里)

---------------------------函数chown,fchown,fchownat,lchown--------------------
#include <unistd.h>

int chown(const char *pathname, uid_t owner, gid_t group); //chown会dereference
int fchown(int fd, uid_t owner, gid_t group);
int fchownat(int dirfd, const char* pathname, uid_t owner, gid_t group, int flag); //flag
  AT_EMPTY_PATH (since Linux 2.6.39) //如果pathname是空字符串，则对dirfd引用的文件（可能是使用open（2）O_PATH标志获取）进行操作。 在这种情况下，dirfd可以引用任何类型的文件，而不仅仅是目录。 如果dirfd是AT_FDCWD，则该调用将在当前工作目录上运行。 该标志是特定于Linux的; define _GNU_SOURCE以获取其定义。
  AT_SYMLINK_NOFOLLOW
int lchown(const char *pathname, uid_p owner, gid_t group); // lchown() is like chown(), but does not dereference symbolic links.

owner或group任意一个是-1则对应的ID不变 //返回值 成功0 错误-1
!!注意点:当_POSIX_CHOWN_RESTRICTED可选地定义在<unistd.h>中，若定义了则不能更改其他用户文件的uid但是可以修改自己所拥有的文件的gid，不过只能修改成自己所属的组

---------------------------文件长度----------------------
stat结构中st_size记录了以字节为单位的文件长度，只对普通文件、目录文件、符号链接有意义

!!注意点:符号链接的长度等于所指向的文件名的实际长度


---------------------------文件中的空洞--------------------------
如何产生：偏移量超过文件尾部，并且写入了部分数据
空洞文件作用很大，例如迅雷下载文件，在未下载完成时就已经占据了全部文件大小的空间，这时候就是空洞文件。下载时如果没有空洞文件，多线程下载时文件就都只能从一个地方写入，这就不是多线程了。如果有了空洞文件，可以从不同的地址写入，就完成了多线程的优势任务

--------------------------文件截取-------------------------
#include <unistd.h>
int truncate(const char* pathname, off_t length);
int ftruncate(int fd, off_t length);
//返回值 成功0 错误-1
将现有文件截断成length
1.length > 实际的则文件长度增加（可能在以前的文件尾和新的文件尾之间产生空洞)
2.length < 实际的则超过部分不能再被访问

---------------------------文件系统----------------------------------
目录项(inode编号和文件名)不等于目录，目录是一系列目录项的列表
每一个inode中都有一个链接计数（指向该inode的目录项数，只有当链接计数为0时才会删除该文件也就是释放该文件所占用的block)

在stat结构中，链接计数在st_nlink成员中，该成员类型为nlink_t，这种链接为硬链接，软链接（符号链接）则block中记录了该符号链接所指向的文件的名字

数据类型为ino_t inode包含了文件的所有信息：文件类型，文件访问权限，文件长度和指向文件block的指针，stat结构中的大多数数据来自于inode，只有两项重要数据放在目录项中(包含的文件的文件名和该文件的inode编号)

---------------------------函数link, linkat, unlink, unlinkat和remove----------
创建一个指向现有文件的硬链接的方法是使用link或linkat
#include <unistd.h>
int link(const char*existingpath, const char* newpath);
int linkat(int efd, const char*existingpath, int nfd, const char* newpath, int flag); 
//返回值 成功0 错误-1

!!注意点:若newpath已经存在则返回错误，只创建newpath中最后一级，路径中其他部分应该是已经存在的
at同上述at后缀的函数
当现有文件是符号链接时，flag设置了AT_SYMLINK_NOFOLLOW则不会对符号链接进行解引用，则创建的是指向符号链接的链接
!!注意点:创建新目录项和增加链接计数应当是原子操作 
!!为了避免造成文件系统中的循环，大多数文件系统不允许创建对于目录的硬链接

//删除一个现有的文件，并将pathname所引用文件的链接计数-1
#include <unistd.h>
int unlink(const char*pathname);
int unlinkat(int dirfd, const char*pathname, int flag); //flag为AT_REMOVEDIR时unlinkat的行为如同rmdir函数一样删除目录，否则如同unlink
//返回值 成功0 错误-1
!!注意点:当有进程打开了该文件时，该文件也不会被删除，删除一个文件时，内核会率先检查打开该文件的进程个数（推测可能是统计文件表项的个数)，然后再检查链接计数，只有当这两个数值都是0时才会删除该文件的内容

标准库中#include <stdio.h> int remove(const char*pathname); 对于文件达到unlink对于目录达到rmdir

----------------------------函数rename和renameat-----------------------
#include <stdio.h>
int rename(const char* oldname, const char*newname);
int renameat(int oldfd, const char*oldname, int newfd, const char*newname);
//返回值 成功0 错误-1

1.如果oldname指的是一个文件而不是目录，那么为这个文件或符号链接重命名，如果newname已经存在则它不能引用为一个目录，而且会删除重名的目录项，对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限
2.如果oldname指的是一个目录，那么为该目录重命名，如果newname已经存在，则必须引用一个目录，而且该目录只能是空目录（只有.和..)，并且会删除重名的目录，然后修改目录名!!注意点:oldname不能是newname前缀，比如/usr/foo /usr/foo/test不能这样子
3.若oldname或newname引用的符号链接，那么处理的符号链接本身
4.不能对.和..重名
5.oldname和newname一样时不做操作返回成功

--------------------------------符号链接-----------------------
符号链接是对文件的间接指针(推测block中记录了所指向的文件名)
并且可以指向不同的文件系统

--------------------------------创建和读取符号链接-------------------
#include <unistd.h>
int symlink(const char*actualpath, const char *sympath);
int symlinkat(const char*actualpath, int dirfd, const char*sympath);
//返回值 成功0 错误-1
//不要求actualpath已经存在，并且可以位于不同的文件系统

因为open函数会对符号链接进行解引用，所以readlink和readlinkat产生可以读取该链接本身
#include <unistd.h>
ssize_t readlink(const char*restrict pathname, char *restrict buf, size_t bufsize);
ssize_t readlinkat(int dirfd, const char* restrict pathname, char *restrict buf, size_t bufsize);
//返回值 成功读取到的字节数 失败-1

--------------------------------文件的时间---------------------
字段	说明					例子		ls选项
st_atim 文件数据的最后访问时间	read 		ls -u
st_mtim 文件数据的最后修改时间  write 		默认
st_ctim i节点状态的最后修改时间 chmod,chown ls -c

文件系统并不会维护inode的最后访问时间

---------------------------------函数futimens,utimennsat和utimes-------
#include <sys/stat.h>
int futimens(int fd, const struct timespec times[2]);
int utimensat(int dirfd, const char*path, const struct timespec times[2], int flag);//flag设置AT_SYMLINK_NOFOLLOW则符号链接本身就会被修改，默认是对符号链接进行解引用，并把文件的时间改成符号链接的时间

数组一个元素是访问时间，第二个元素是修改时间，（都是自从1970:1:1 00:00:00)以来所经过的秒数
  struct timespec {
      time_t tv_sec;        /* seconds */
      long   tv_nsec;       /* nanoseconds */
  };
times的解读:
1.times为NULL,则访问时间和修改时间两者都设置成当前时间
2.times指向timespec的数组，任一数组元素的tv_nsec的值为UTIME_NOW，相应的时间戳就设置为当前时间，忽略相应的tv_sec字段
3.times中任一数组元素的tv_nesc字段的值为UTIME_OMIT，则相应的时间戳保持不变，忽略相应的tv_sec字段
4.times中的元素是正常数值则设置对应时间戳

执行这些函数所要求的权限取决于times的值:
1.NULL时，或者两个元素的tv_nsec字段为UTIME_NOW时，进程的有效用户id必须等于该文件的所有者id或进程对该文件有写的权限，或者进程是超级用户进程
2.如果times非空并且任一tv_nsec字段不为UTIME_NOW或UTIME_OMIT，则进程的有效用户id必须等于该文件的所有者id同时进程对文件有写的权限，或者必须是超级用户进程
3.times非空并且两个元素的tv_nesc字段都为UTIME_OMIT，就不执行权限检查

#include <sys/time.h>
//改变文件访问和修改内容时间
int utimes(const char *filename, const struct timeval times[2]);
//返回值 成功0 错误-1
struct timeval {
               long tv_sec;        /* seconds */
               long tv_usec;       /* microseconds */
};

但是无法修改ctime，因为调用了utimes函数会自动更新ctime

-------------------------------------函数mkdir,mkdirat和rmdir-------------
#include <sys/stat.h>
int mkdir(const char*pathname, mode_t mode);
int mkdirat(int dirfd, const char *pathname, mode_t mode);
//返回值 成功 0 错误-1
创建空目录（自动创建.和..)所指定的文件访问权限mode由进程的文件模式创建屏蔽字修改（umask)

#include <unistd.h>
int rmdir(const char*pathname); //返回值 成功 0 错误-1
//必须是空目录才能执行成功，为此即使有另外进程打开此目录后也无法创建新文件

---------------------------------------读取目录-------------------
对某个目录具有访问权限的任一用户都可以读目录，但是为了防止文件系统产生混乱只有内核能够写目录本身
#include <dirent.h>
struct dirent {
       ino_t          d_ino;       /* Inode number */
       off_t          d_off;       /* Not an offset; see below */
       unsigned short d_reclen;    /* Length of this record */
       unsigned char  d_type;      /* Type of file; not supported
                                     by all filesystem types */
       char           d_name[256]; /* Null-terminated filename */
};

DIR *opendir(const char*pathname);
DIR *fdopendir(int fd); //返回值 成功 返回指针错误NULL(将已经打开的文件描述符转换成DIR结构)

struct dirent *readdir(DIR *dp); //返回值 成功 返回指针 错误或在目录尾部返回NULL(推测内部维护了当前要读取的指针,执行一次readdir后当前指针后移)

void rewinddir(DIR *dp); // The rewinddir() function resets the position of the directory stream dirp to the beginning of the directory.

int  closedir(DIR *dp); //返回值 成功 返回0，错误返回-1

long telldir(DIR *dp); //返回值与dp关联的目录中的当前位置   On success, the telldir() function returns the current location in the directory stream.  On error, -1 is returned, and errno is set appropriately.

void seekdir(DIR *dp, long loc);   seekdir - set the position of the next readdir() call in the directory stream.



#include <sys/types.h>
#include <dirent.h>

int dirfd(DIR *dirp); //dirfd - get directory stream file descriptor 返回值成功返回dirfd 失败返回-1

---------------------------函数chdir, fchdir和getcwd-------------------
当前工作目录是进程的一个属性
#include <unistd.h>
int chdir(const char* pathname);
int fchdir(int fd); //返回值 成功 0 错误-1
指定新的工作目录
#include <unistd.h>
char* getcwd(char *buf, size_t size); //返回值 成功 返回buf， 错误NULL get current working directory
缓冲区地址buf，缓冲区size
buf需要足以容纳绝对路径+空字符的大小


#include <unistd.h>
int chroot(const char *path); 
增加了系统的安全性，限制了用户的权力；
在经过 chroot 之后，在新根下将访问不到旧系统的根目录结构和文件，这样就增强了系统的安全性。这个一般是在登录 (login) 前使用 chroot，以此达到用户不能访问一些特定的文件。

建立一个与原系统隔离的系统目录结构，方便用户的开发；
使用 chroot 后，系统读取的是新根下的目录和文件，这是一个与原系统根下文件不相关的目录结构。在这个新的环境中，可以用来测试软件的静态编译以及一些与系统不相关的独立开发。

切换系统的根目录位置，引导 Linux 系统启动以及急救系统等。
chroot 的作用就是切换系统的根位置，而这个作用最为明显的是在系统初始引导磁盘的处理过程中使用，从初始 RAM 磁盘 (initrd) 切换系统的根位置并执行真正的 init。另外，当系统出现一些问题时，我们也可以使用 chroot 来切换到一个临时的系统。


---------------------------设备特殊文件--------------------------
每个文件系统所在的存储设备都有主次设备号(dev_t类型)
主设备号标识设备驱动程序，此设备号标识特定的子设备
  #include <sys/sysmacros.h>

       dev_t makedev(unsigned int maj, unsigned int min);

       unsigned int major(dev_t dev); //返回主设备号
       unsigned int minor(dev_t dev); //返回次设备号

stat结构中st_dev是文件系统的设备号, st_rdev则是只有字符和块设备文件才有，包含了实际设备的设备号

---------------------------文件访问权限小结------------------------

S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSR
S_IRWXG = S_IRGRP | S_IWGRP | S_IXGRP
S_IRWXO = S_IROTH | S_IWOTH | S_IXOTH
常量		说明		对普通文件的影响				对目录的影响
S_ISUID 	setuid		执行时设置有效用户id 			(未使用)
S_ISGID 	setgid 		若S_IXGRP被设置则执行时setgid 	将在目录中创建的新文件的组id设置为目录的组id
						否则使强制性锁起作用（若支持)
S_ISVTX	    setbit 		在交换区缓存.text段(若支持)		限制在目录中删除和重命名文件


=================================第五章 标准I/O------------------
标准io是针对流进行的，而之前是采用文件描述符，当用标准IO库打开或创建一个文件时，是使得流和文件相关联
#include <stdio.h>
#include <wchar.h>
流的定向决定了所读写的字符是单字节还是多字节（宽）

//设置流的定向
int fwide(FILE *fp, int mode); //返回值 若流是宽字符则返回正值，若是窄则返回负，若流未定向则返回0
mode为负，则fwide则试图使得指定的流是窄定向（字节定向）
mode为正，则fwide则试图使得指定的流是宽定向
mode==0， 则fwide不试图设置流的定向，但返回标识该流定向的值
!!注意点:fwide并不改变已定向的流

-----------------------------标准输入输出错误---------------------
#include <stdio.h>
stdin, stdout, stderr对应了系统调用中常用的
STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO(#include <unistd.h>)

------------------------------缓冲-------------------------
标准I/O提供了三种类型的缓冲
1.全缓冲:
	在填满标准I/O缓冲区后才实际进行I/O操作，对于驻留在磁盘上的文件(当流涉及到文件)通常是由标准I/O实施全缓冲
	fflush()可以人为地冲洗流,!!注意点:在UNIX中，flush有两种意思，在标准I/O库方面，flush意味着将缓冲区的内容写到磁盘上（哪怕缓冲区没有满)，而在终端驱动程序方面意味着丢弃缓冲区的数据
2.行缓冲:
	在输入和输出遇到换行符时，标准I/O库执行实际的I/O操作，当流涉及到一个终端时（标准输入和标准输出）通常实施行缓冲
	!!注意点:因为缓冲区固定（所以只要填满了缓冲区哪怕没有写一个换行符也会进行实际的I/O）
			 任何时候只要通过标准I/O库要求从一个不带缓冲的流或者一个带着行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流(标准输入时,或者read(STDIN_FILENO)(不带缓冲的流)从内核中获取数据，会冲刷所有标准输出流)
3.不带缓冲:
	stderr一般是不带缓冲的
	上述一般是因为ISO C中要求的是:
	(1):当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲
	(2):标准错误绝对不是全缓冲
	所以一般系统是：标准错误是不带缓冲，指向终端设备的流是行缓冲，否则是全缓冲

//更改缓冲类型
#include <stdio.h>
void setbuf(FILE* restrict fp, char *restrict buf); //设置或关闭缓冲，带缓冲的话buf的大小必须为BUFSIZ（#include <stdio.h>)，NULL则为不带缓冲，当设置了buf为BUFSIZ后一般就变成了全缓冲，但是流和终端设备有关的话，某些系统仍然会将其设置为行缓冲
int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
//mode:
	1._IOFBF   	全缓冲 //buff为NULL时则系统会自动选择合适的缓冲区
	2._IOLBF 	行缓冲 //buff为NULl时则系统会自动选择合适的缓冲区
	3._IONBF 	不缓冲 
//返回值 成功 0 错误非0


#include <stdio.h>
int fflush(FILE *fp); //fp为NULL时将所有输出流被刷新，否则刷新该流所有为写的数据进入内核，返回值 成功0 失败EOF

----------------------------------打开流--------------------------
#include <stdio.h>
FILE* fopen(const char *restrict pathname, const char *restrict type);
FILE* freopen(const char *restrict pathname, const char *restrict type, FILE *restrict fp);
FILE* fdopen(int fd, const char* type);
//返回值 成功返回FILE*指针，失败NULL

freopn若fp已经打开则会关闭，若fp已经定向则会清除定向

(POSIX才有)fdopen会让fd和标准的I/O流相关联
!!注意点：fdopen不能对文件截断（因为fd已经打开)，fdopen也不能用追加来创建文件，因为fd存在则文件一定存在

type:
字符串	含义		解释			若文件已存在的动作	若文件不存在的动作 对应open系统调用中的mode
"r"		读			打开文件以读取	从头读				打开失败			O_RDONLY
"w"		写			创建文件以写入	销毁内容			创建新文件			O_WRONLY | O_CREAT | O_TRUNC
"a"		后附		后附到文件		写到结尾			创建新文件			O_WRONLY | O_CREAT | O_ADDEND
"r+"	读扩展		打开文件以读/写	从头读				错误				O_RDWR
"w+"	写扩展		创建文件以读/写	销毁内容			创建新文件		    O_RDWR   | O_CREAT | O_TRUNC
"a+"	后附扩展	打开文件以读/写	写到结尾			创建新文件			O_RDWD 	 | O_CREAT | O_APPEND
b的含义二进制文件(但是UNIX不区分)
!!注意点:
1.当文件以更新模式打开时（ '+' 作为上述模式参数值列表的第二或第三个字符），访问流可以进行输入和输出。然而输出不应直接紧随输入，而中间无对 fflush 函数或对文件定位函数（ fseek 、 fsetpos 或 rewind ）的调用，且输入不应直接紧随输出，而中间无对文件定位函数的调用，除非输入操作遇到文件尾。      ----------原因内部只记录了一个文件偏移量，若不进行文件偏移量重新设置，否则下一次读或写都是对于当前的文件偏移量
2.w或a当文件不存在时，不能确定新文件的访问权限（而open和creat则可以)

#include <stdio.h>
int fclose(FILE *fp); //返回值 成功 0 错误EOF
//在关闭之前会冲洗缓冲区的输出数据，缓冲区中的任何输入数据被抛弃
//当进程结束时（exit或main返回），所有打开的标准I/O流都关闭，所有不带缓冲的流都被刷新

--------------------------------读和写流------------------
1.每次读写一个字符
2.每次读写一行
3.每次读写一定长度

1.--------输入函数
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);
//成功返回读取到字符，失败或到达文件尾部返回EOF
//getchar等同于getc(stdin) ,getc一般实现为宏
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp); //用于鉴定流是抵达了文件尾部还是错误  返回值 对应条件为真则返回非0，否则返回0

void clearerr(FILE *fp);//清除错误和文件结束标记

#include <stdio.h>
int ungetc(int c, FILE *fp); //将字符压回到读取的流(存在于缓冲区)中 返回值 成功返回c，错误EOF  内部会调用clearerr以便支持在文件尾部后压回
//scanf中的回车残留在缓冲区则是使用了这种技术

2.--------输出函数
#include <stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);
putchar = putc(c, stdout) putc一般为宏

---------------------------------------------每次一行I/O---------------------------
#include <stdio.h>
char* fgets(char *restrict buf, int n, FILE *restrict fp); //n -1个字符送入buf，最后一个为空字符 fgets保留换行符
char* gets(char *buf); //返回值 成功返回buf，错误或到达文件尾返回NULL  gets不保留换行符  !!不推荐使用，缓冲区溢出问题

#include <stdio.h>
int fputs(const char *restrict str, FILE *restrict fp); //遇到0会停止
int puts(const char *str);  //输出会增加换行符
//返回值 成功 非负 失败EOF

fgets和fputs需要自己处理换行符

--------------------------------标准I/O效率----------
标准I/O库并不比read和write函数相比慢很多  通常系统调用与普通函数调用相比需要花费更多时间

------------------------------------二进制I/O(每次读写一定长度)-------------------------
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp); //nobj是读或写的对象个数 
//返回值 成功读或写的对象数  错误读可能是失败或者到达文件尾则返回少于nobj具体使用ferror或feof来判断， 写错误则返回少于nobj
eg:
 int arr[2];
 fread(arr, sizeof(int), 2, fp)
!!注意点：跨系统跨平台读取二进制的话需要注意内存对齐以及大小端，甚至是数据二进制的存储格式

-----------------------------------定位流--------------
1.ftell fseek long类型的偏移量
2.ftello fseeko off_t类型代替long
3.fgetpos fsetpos (便于移植)

#include <stdio.h>
long ftell(FILE *fp); //返回值 成功 当前文件偏移量 失败-1L
off_t ftello(FILE *fp); //返回值 成功 当前文件偏移量 失败(off_t)-1
int fgetpos(FILE *restrict fp, fpos_t *restrict pos); // 返回值 成功 0 错误 非0

int fseek(FILE *fp, long offset, int whence); //返回值 成功 0 失败 -1 
int fseeko(FILE *fp, off_t offset, int whence); //返回值 成功 0 错误 -1
int fsetpos(FILE *fp, const fpos_t* pos); //返回值 成功 0 错误 -1

void rewind(FILE *fp); //将流设置到文件起始位置

!!注意点:对于文本文件（win上面存在，unix/linux无视), whence只能设置为SEEK_SET，offset只能为0或ftell的返回值，因为当前偏移量可能不是以字节为单位来度量的

!!注意点:以上重新设置文件偏移量的函数，都会在执行之前刷先fflush(fp)
----------------------------------格式化I/O---------------
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char*restrict format, ...);
int dprintf(int fd, const char *restrict format, ...); 
			//返回值 成功 返回输出字符数，失败负数
int sprintf(char *restrict buf, const char* restrict format, ...);
			//返回值 返回存入到buf中的字符数， 若编码错误，返回负数
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);
			//返回值，若buf足够大，则返回要存入数组的字符数目，否则是n，若编码错误，则负数

s系列中的buf会自动包含0，但是0不算在返回值内

format:
	%[flags][fldwidth][.precision][lenmodifier]convtype
	flags:
		'    	 将整数按千分位分组字符(大多数实现不支持)
		-	 	 在字段内左对齐输出（默认右边)
		+	 	 总是带符号的正负号
		' '(空格)如果第一个字符不是正负号，则在前面加入一个空格
		#	     加上进制的前缀如16进制0x
	
	fldwidth 	 表示字段最小宽度
	precision    表示字段最少位数，或者字符最大字节数 以上两个可以用*来代替，以便后面用变量来控制精度
																						eg:
																						printf("%*d", 3, i); 3替换*
	lenmodifier  说明参数类型
	     hh 	 signed / unsigned char
		 h       signed / unsigned short
		 l       signed / unsigned long 
		 ll      signed / unsigned long long 
		 j       intmax_t / uintmax_t
		 z       size_t
		 t       ptrdiff_t
		 L 	     long double

	convtype:
		d,i      有符号十进制
		o	     无符号八进制
		u		 无符号十进制
		x, X 	 无符号十六进制
		f,F 	 双精度浮点数
		e,E      指数格式双精度浮点数
		g,G 	 根据占位符对应的数据解释为f,F,e或E
		a,A 	 十六进制指数格式双精度浮点数
		c 	     字符(若lenmodifier指定为1则为宽字符)
	    s        字符串（若lenmodifier指定为1，则为宽字符)
		p        指向void的指针
		n        到目前为止，printf已经输出的字符数目将被写入到指针所指向带符号整形变量中， eg:
																							int i = 0;
																							printf("%s%n", "123", &i); // i = 3
		%        输出%
		C		 宽字符(XSL扩展)
		S        宽字符串(XSL扩展)


2.格式化输入-----------------
#include <stdio.h>
int scanf(const char*restrict format, ...);
int fscanf(FILE *restrict fp, const char* restrict format, ...);
int sscanf(const char* restrict buf, const char*restrict format, ...);
//返回值 赋值的输入项的个数，若出错或已经到达文件尾则返回EOF
 
%[*][fldwidth][m][lenmodifier]convtype
*可选：用于抑制转换，仍然按照转换说明的其余部分对输入进行转换，但是不放入参数中
fldwidth: 最大宽度
m可选: 用于%c或%s(迫使标准I/O缓冲区为其分配内存)，参数必须是指针地址，由调用者负责管理该内存
eg:
	char* ptr = NULL;
	scanf("%ms", &ptr);
	free(ptr);

convtype:
	d 	             有符号十进制数, 基数10
	i                有符号十进制，基数可以由输入格式决定
	O 				 无符号八进制（输入可以为有符号，但是会被强转)
	u 				 无符号十进制，基数为10（输入可以为有符号，但是会被强换)
	x,X              无符号十六进制（输入可以为有符号，但是会被强转)
	a,A,e,E,f,F,g,G  浮点数
	c
	s
	[                匹配列出的字符序列以]终止(对应的参数应该为char*并且具有内存) //效果为该参数必须为这个值，否则视为不匹配
	[^               匹配除字符以外的所有字符，以]终止   //效果为该参数一定不含有[^中的任意字符]
	p                指向void的指针
	n                同printf中的convtype:n
	%
	C
	S


----------------------------------实现细节-----------------------------
#include <stdio.h>
int fileno(FILE* fp); //返回值 与该流相关的文件描述符 POSIX扩展

---------------------------------临时文件-------------------
#include <stdio.h>
XXXXXXXXXXXXXXXXXXXXX不推荐使用 char* tmpnam(char *ptr);  //返回指向唯一路径名的指针 //不推荐使用，当多个进程都使用时可能会返回一个结果（尽管在每个进程看来都是唯一的）
XXXXXXXXXXXXXXXXXXXXX不推荐使用 FILE* tmpfile(void);  //若成功返回文件指针，失败NULL  创建临时文件（内部实现可能是creat(tmpnam(ptr), FILE_MODE); unlink(ptr))
tmpfile因为不是原子操作，所以可能有其他进程创建同名文件导致被删除的可能，所以也不推荐使用

#include <stdlib.h>
//随机创建目录
char* mkdtemp(char *template);  //返回值 成功返回指向目录名的指针，失败NULL   The directory is then created with  
permissions  0700.

//随机创建文件
int mkstemp(char *template); //返回值 成功返回文件描述符，错误-1 //template函数会将后6位替换成随机的唯一路径名 !!注意点:与tempfile不同，所创建的文件不会被自动删除，需要自己unlink.  The  file  is  created with permissions 0600, that is, read plus write for owner only.and returns an open(w+权限)
       file descriptor for the file.(因此需要自己close())
permissions 0600

以上两个template的最后6个字符必须是XXXXXX

------------------------------内存流---------------
#include <stdio.h>
//open memory as stream
FILE* fmemopen(void *restrict buf, size_t size, const char*restrict type);
//返回值 成功 返回流指针 失败NULL

如果buf为空，则fmemopen会分配size个字节数的缓冲区，当流关闭时缓冲区会被释放
type:
	r rb
	w wb           内存流被截断（第一个字节而填充0)与fopen中w的不同
	a ab            为在第一个null字节处写而打开
	r+ r+b rb+  
	w+ w+b wb+
	a+ a+b ab+      为在第一个null字节处读和写而打开
不适合二进制数据（fwrite中若有数据存在0)

#include <stdio.h>
FILE* open_memstream(char **bufp, size_t *sizep); 
#include <wchar.h>
FILE* open_wmemstream(wchar_t **bufp, size_t *sizep);
//返回值 成功 返回流指针 失败NULL
与fmemopen的不同:
1.只能写打开
2.不能指定自己的缓冲区，但是可以通过两个参数获取缓冲区地址和大小
3.关闭流后需要释放缓冲区
4.对流添加字节会增加缓冲区大小(继续写入)
	!!注意点:由于缓冲区是动态增长（推测std::vector如同)，所以当下一次写入数据时可能让之前的内存失效


======================================第六章：系统数据文件和信息================
-------------------口令文件-----------------------
/etc/passwd文件中的数据来源于<pwd.h>中的passwd结构体

 struct passwd {
               char   *pw_name;       /* username */
               char   *pw_passwd;     /* user password */
               uid_t   pw_uid;        /* user ID */
               gid_t   pw_gid;        /* group ID */
               char   *pw_gecos;      /* user information */
               char   *pw_dir;        /* home directory */
               char   *pw_shell;      /* shell program */
           };
//通过uid或用户名查询/etc/passwd下面的指定记录
#include <pwd.h>
struct passwd* getpwuid(uid_t uid);
struct passwd* getpwnam(const char* name); //返回值 成功返回指针 失败NULL

!!注意点：passwd结构信被定义为函数内部的静态变量
//查看passwd文件中的信息
#include <pwd.h>
struct passwd* getpwent(void) //返回值 成功返回指针 失败或达到文件尾部返回NULL  
返回/etc/passwd中下一个记录项

void setpwent(void); //返回/etc/passwd的开头
void endpwend(void); //关闭文件

-------------------------shadow密码------------------
单向加密:不能从加密口令中猜到原来的口令
但是可以通过猜测明文然后采用单向加密算法后来比较加密口令

  struct spwd {
               char *sp_namp;     /* Login name */
               char *sp_pwdp;     /* Encrypted password */
               long  sp_lstchg;   /* Date of last change
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               long  sp_min;      /* Min # of days between changes */  //可以更改的最小天数
               long  sp_max;      /* Max # of days between changes */  //必须更改的最大天数
               long  sp_warn;     /* # of days before password expires
                                     to warn user to change it */  //一般比sp_max小7左右
               long  sp_inact;    /* # of days after password expires   expire到期
                                     until account is disabled */
               long  sp_expire;   /* Date when account expires
                                     (measured in days since
                                     1970-01-01 00:00:00 +0000 (UTC)) */
               unsigned long sp_flag;  /* Reserved */
           };
#include <shadow.h>
struct spwd* getspnam(const char* name);
struct spwd* getspent(void);
//返回值 成功返回指针 失败NULL

struct spwd *getspent(void);
void setspent(void);
void endspent(void);


-----------------------------------------组文件--------------
#include <grp.h>
 struct group {
               char   *gr_name;        /* group name */
               char   *gr_passwd;      /* group password */
               gid_t   gr_gid;         /* group ID */
               char  **gr_mem;         /* NULL-terminated array of pointers
                                          to names of group members */
           };

struct group
#include <grp.h>
struct group* getgrgid(gid_t gid);
struct group* getgrnam(const char* name); //返回值 成功指针 失败NULL

#include <grp.h>
struct group* getgrent(void);  //返回值 成功 指针 失败或到达文件尾部 NULL
void setgrent(void);
void endgrent(void);

-------------------------------------------附属组id--------------
一个用户可以参与多个组
#include <unistd.h>
//gidsetsize最大获取个数 grouplist会被填入调用进程的各个附属组id
//若gidsetsize为0则返回附属组的个数，以便用户确定传入数组的大小
int getgroups(int gidsetsize, gid_t groupllist[]); //返回值 成功 返回附属组id数目 失败-1

#include <grp.h> //linux
//ngroups说明了数组的元素个数，由root调用后会修改调用进程的附属组id表
//ngroups不能超过NGROUPS_MAX
int setgroups(int ngroups, const gid_t grouplist[]);

#include <grp.h>
//会调用getgrent找到username，然后初始化附属组id表，以basegid为开始
int initgroups(const char* username, gid_t basegid); //以上两个返回值 成功0 失败-1

----------------------------------------其他数据文件---------------
1.get函数:
	读取下一个记录，通常返回指向一个结构体的指针，若已经到达文件尾部就NULL(内部维护了一个静态结构体成员，如list，get则返回current)
2:set函数:
	设置读取记录为数据文件开始处
3:end函数:
	关闭数据文件

------------------------------------------登录账号记录
utmp文件记录了当前登录到系统的各个用户(man 5)
wtmp文件跟踪各个登录和注销事件(man 5)
/var/run/utmp /var/log/wtmp

-------------------------------------------系统标识--------------------
#include <sys/utsname.h>

//通过该参数赋值
int uname(struct utsname* name); //成功返回非负数 失败-1
     struct utsname {
               char sysname[];    /* Operating system name (e.g., "Linux") */
               char nodename[];   /* Name within "some implementation-defined
                                     network" */
               char release[];    /* Operating system release (e.g., "2.6.28") */
               char version[];    /* Operating system version */
               char machine[];    /* Hardware identifier */
           #ifdef _GNU_SOURCE
               char domainname[]; /* NIS or YP domain name */域名
           #endif
           };

#include <unistd.h>
int gethostname(char* name, int namelen); //返回值 成功 0 错误-1
主机名通常在系统自举时设置/etc/rc或init取自一个启动文件

----------------------------------------时间和时间例程------------------
#include <time.h>
//返回当前时间和日期
time_t time(time_t* calptr); //成功返回时间值 失败-1
如果参数非空则将记录在calptr所指向的内存中

#include <sys/time.h>
 struct timespec {
               time_t   tv_sec;        /* seconds */
               long     tv_nsec;       /* nanoseconds */  毫秒ms 微秒us 纳秒ns
           };

int clock_gettiem(clockid_t clock_id, struct timespec* tsp);
//返回值 成功 0 出错-1
clock_id:
	  CLOCK_REALTIME
              System-wide  clock  that  measures  real (i.e., wall-clock) time.  (1970-01-01 00:00)
	  CLOCK_MONOTONIC(单调时间)
		      不受系统管理员手动更改时间导致的时间不连续跳跃的系统时间 
      CLOCK_PROCESS_CPUTIME_ID (since Linux 2.6.12)
              Per-process CPU-time clock (measures CPU time consumed by all threads in the process).

      CLOCK_THREAD_CPUTIME_ID (since Linux 2.6.12)
              Thread-specific CPU-time clock.

#include <sys/time.h>
int clock_getres(clockid_t clock_id, struct timespec *tsp);
//返回值 成功0 失败-1

#include <sys/time.h>
int clock_settime(clockid_t clock_id, const struct timespec *tsp); //返回值成功0，错误-1

#include <sys/time.h>
int gettimeofday(struct timeval *restrict tp, void *restrict tzp); //返回值 总是返回0
   struct timeval {
               time_t      tv_sec;     /* seconds */
               suseconds_t tv_usec;    /* microseconds */
           };
tzp总是为NULL(某些平台支持用tzp说明时区)

#include <time.h>
struct tm* gmtime(const time_t *calptr);
struct tm* localtime(const time_t *calptr);
//两个函数的返回值: 指向分解的tm结构的指针，失败返回NULL
   struct tm {
               int tm_sec;    /* Seconds (0-60) */
               int tm_min;    /* Minutes (0-59) */
               int tm_hour;   /* Hours (0-23) */
               int tm_mday;   /* Day of the month (1-31) */
               int tm_mon;    /* Month (0-11) */
               int tm_year;   /* Year - 1900 */
               int tm_wday;   /* Day of the week (0-6, Sunday = 0) */
               int tm_yday;   /* Day in the year (0-365, 1 Jan = 0) */
               int tm_isdst;  /* Daylight saving time */
           };
唯一区别是localtime是转化为本地时间

#include <time.h>
time_t mktime(struct tm *tmptr);
//返回值 成功返回日历时间 错误-1

#include <time.h>
size_t strftime(char *restrict buf, size_t maxsize, const char *restrict format, const struct tm * restrict tmptr);
size_t strftime_l(char *restrict buf, size_t maxsize, const char* restrict format, const struct tm *restrict tmptr, locale_t locale);
//返回值 若有空间返回存入数组的字符数，否则0,因为时间的数据大小长度不一定

#include <time.h>
char* strptime(const char *restrict buf, const char* restrict format, struct tm* restrict tmptr);
//返回值 成功指向上次解析的字符的下一个字符的指针， 失败NULL


============================================
第七章:进程环境

进程终止的方法:
1.main返回(c99才规定main的返回值为0)
2.调用exit
3.调用_exit 或者_Exit
4.最后一个线程从其启动例程返回
5.从最后一个线程调用pthread_exit

(异常退出)
	6.调用abort
	7.接到一个信号
	8.最后一个线程对取消请求做出响应

在调用main函数前先调用一个特殊的启动例程，可执行程序会将此启动例程指定为该程序的起始地址
如果将启动例程(系统调用exec函数)用c代码写exit(main(argc, argv)) 通常汇编实现（通过编译器)

1.退出函数
#include <stdlib.h>
void exit(int status);(执行一些清理处理，先对于atexit()函数记录的函数指针进行执行，然后对于所有打开流调用fclose(),最后调用_exit 或者_Exit)  main中return等价

void _Exit(int status);(直接返回内核)
#include <unistd.h>
void _exit(int status);(直接返回内核)

2.函数atexit
#include <stdlib.h>
int atexit(void (*func)(void));(记录使用exit函数后需要调用的函数指针)
!!注意点:内核执行某一个程序的唯一方法是调用exec函数
进程自愿终止的唯一方式是显示或者隐式（exit())调用_exit或者_Exit

ISO c 和 posix.1都规定argv[argc]是NULL

------------------环境表------------------
如同命令参数表argv一样，每个程序都接收到一个环境表，extern char **environ记录
历史上int main(int argc, char *argv[], char *envp[]); //但不符合ISO C的规定，所以通常使用environ或者getenv和putenv来操作

------------------------c程序的存储空间布局----------------

1. .text 
	cpu执行的机器指令部分，可共享（文本编辑器，c编译器和shell）相同的指令在存储器中只需要一个部分即可，一般只读
2. 初始化数据段(.data数据段)
	明确地赋初值的全局变量:int max = 0;
3. 未初始化数据段 .bss段
	未初始化的全局变量在程序开始执行之前，内核将此段中的数据初始化为0或者为NULL: long sum[100];	
4. 栈区
	向下伸长逐渐变小)	
5. 堆区
	向上伸长(逐渐变大)
//size a.out无法得出栈和堆的大小，因为在运行时(exec函数执行时)才知道
//a.out中还有若干其他类型的段，例如，包含符号表的段、包含调试信息的段以及包含动态共享库链接表的段等等。在程序执行时是直接忽略这些段
//a.out只会记录.text和.data和.bss
//可以使用size命令查看
//栈帧不一定是要向下伸展逐渐变小
//可能是用链表来实现的
------------------------------共享库----------------------------
库的存在会增加部分运行时的开销（当调用库函数时)但是优点是可以替换库文件而不需要修改源文件代码或者重新编译可执行程序

gcc -static //阻止gcc使用共享库,默认使用库

--------------------------------存储空间分配---------------------
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);//该空间中的每一bit都会初始化为0,由于存在内存对其，所以所分配的大小应该是大于等于nobj*size的
void *realloc(void* ptr, size_t newsize);
//返回的指针一定是适当内存对齐的
void free(void *ptr);

----------------------------环境变量--------------------
#include <stdlib.h>
char* getenv(const char *name); //获取该name所对应的环境变量值
int putenv(char* str); //name=value的字符串放入到环境表中
int setenv(const char* name, const char* value, int rewrite); //rewirte为0则不删除已有的定义，否则删除 改变或添加一个环境变量
int unsetenv(const char* name); //删除name的定义，即使不存在也不会错

----------------------------函数setjmp和longjmp--------------
#include <setjmp.h>
int setjmp(jmp_buf env); //直接调用返回0，否则返回longjmp中val的值

void longjmp(jmp_buf env, int val); //设置env，并且使得栈帧回到调用setjmp的栈帧中
!!注意点:跳转的后变量的值:全局 静态 volatite(不让编译器进行优化)修饰的变量值不变，放在寄存器中的变量则会复原到调用longjmp之前的值

-------------------------函数getrlimit和setrlimit---------------
//进程的资源限制,由0号进程建立然后由后续进程继承
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);

       struct rlimit {
               rlim_t rlim_cur;  /* Soft limit */
               rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
           };
resource的取值:
	RLIM_INFINITY 无限制
	RLIMIT_AS 进程总的可用存储空间的最大字节
	RLIMIT_CORE core文件的最大字节数, ulimit -a
				core file size          (blocks, -c) 0
	RLIMIT_CPU CPU时间的最大量值（秒），当超过该软限制时，向进程发送SIGXCPU信号
	RLIMIT_DATA 数据段的最大字节长度(初始化数据，未初始化数据，以及堆的总和
	RLIMIT_FSIZE 可以创建的文件的最大字节长度，超过软限制时，发送SIGXFSZ信号
	RLIMIT_MEMLOCK 一个进程使用mlock能够锁定在存储空间中的最大字节长度
	RLIMIT_MSGQUEUE 进程为POSIX消息队列可分配的最大存储字节数
	RLIMIT_NICE nice的值影响进程的调度优先级,nice可以设置最大限制,ps -fl中的nice
	RLIMIT_NOFILE 每个进程能打开的最多文件数，会影响sysconf函数在参数_SC_OPEN_MAX中的返回值
	RLIMIT_NPROC 每个实际用户ID可拥有的最大子进程数，
	RLIMIT_NPTS 用户可同时打开的伪终端的最大数量
	RLIMIT_RSS 最大驻内存集字节长度（RSS),如果可用的物理存储器非常少，则内核将从进程处取回超过RSS的部分
	RLIMIT_SBSIZE 在任一给定时刻，一个用户可以占用的套接字缓冲区的最大字节
	RLIMIT_SIGPENDING 一个进程可排队的信号最大数量
	RLIMIT_STACK 栈的最大字节长度
	RLIMIT_SWAP 用户可消耗的交换空间的最大字节
	RLIMIT_VMEM 等价于RLIMIT_AS
	资源限制影响到调用进程并由子进程继承

============================================第八章 进程控制=====================
通常PID0 为调度进程，也称交换进程是内核的一部分不执行任何磁盘的程序，也称系统进程
ps:自举 计算机必须具备自举能力将自己所有的元件激活，以便能完成加载操作系统这一目的，然后再由操作系统承担起那些单靠自举代码无法完成的更复杂的任务
PID1 为init进程，在自举过程结束时由内核调用，负责在自举内核后启动系统，读取与系统相关的初始化文件(/etc/rc* /etc/inittab /etc/init.d ，并将系统引导到一个状态（如多用户，单用户，维护...)，init进程绝不会终止，虽然是普通的用户进程（但是是root来执行)，将成为所有孤儿进程的父进程
孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作

#include <unistd.h>
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
uid_t geteuid(void); e是有效的缩写
gid_t getgid(void);
gid_t getegid(void);

#include <unistd.h>
pid_t fork(void); //出错返回-1，否则父进程返回子进程pid，子进程返回0
fork后的子进程享有父进程中数据空间，堆和栈的副本，但共享.text字段

!!!注意点:由于fork后一般加上exec,所以很多实现并不执行一个父进程的拷贝，而是使用了写时复制(COW Copy-On-Write)技术，内核将数据空间，堆栈设置为只读权限，写时制作副本，父进程所有打开的文件描述符都被复制到子进程中,文件共享（文件状态标志，文件偏移量，v节点指针)
!!fork共享的有:
	环境
	文件共享
	实际用户id，实际组id，有效用户id，有效组id
	附属组id
	进程组id
	会话id
	控制终端
	setuid标志和setgid标志
	当前工作目录
	根目录
	umask
	信号屏蔽和安排
	对任意打开文件描述符的FD_CLOEXEC标志
	环境
	连接的共性存储段
	存储映像
	资源限制

vfork()允许调用者控制哪些部分共享
vfork和fork的区别:
	1.不将父进程的地址空间完全复制到子进程中，因为用vfork通常后面接exec，在调用exec或者exit之前，在父进程的空间运行(注意!!)
	2.vfork保证子进程先执行（但是要是子进程依赖于父进程的动作，则会导致死锁)，子进程调用exec或者exit后父进程才可能被调度

!!!注意点:sizeof是编译期得知,vfork由于是在父进程的地址空间中执行指令，因此若修改了父进程的栈帧容易导致不可预测的结果（如f1（）里面调用vfork后调用f2()，则父进程的f1栈帧被改写)
void f1()
{
	pid_t pid;
	if ((pid = vfork()) < 0)
	{
		err_sys("vfork error");
	}
}
void f2()
{
	printf("test\n");
}
int main(void)
{
	f1();
	f2();
	return 0;
}
-----------------					    -----------------
|	main栈帧 	|						|   main栈帧	|
-----------------	----------------> 	-----------------
|	f1栈帧		|						|   f2栈帧		|
-----------------						-----------------
vfork后调用f2之前的栈帧示意图		子进程结束后，父进程f1的栈帧可能会被f2覆盖


--------------------------------------函数exit-----------
exit是否对标准io流刷新是未定义行为（取决于实现），但目前不刷新，因为最后仍然会由内核关闭所有已经打开的文件描述符

不管进程如何终止，都会执行内核中的一段代码，这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器

僵尸进程:一个已经终止，但是父进程尚未对起进行善后处理（wait waitpid获取终止进程的有关信息，释放它仍占用的资源) ps可以打印
如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。

一个init的子进程：可能是init直接产生的，也可能是由init收养的（其父进程已经终止)

------------------------------------函数wait和waitpid------------------
wait waitpid 如果其所有子进程还在运行，则阻塞
			 如果一个子进程已经终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立刻返回
			 如果它没有任何子进程，则错误返回

#include <sys/wait.h>
pid_t wait(int *wstatus);
pid_t waitpid(pid_t pid, int *wstatus, int options);
waitpid中pid的作用
1. pid == -1 等待 任意子进程，同wait
2. pid > 0   等待 与pid相等的子进程
3. pid == 0 等待某一子进程，该子进程的进程gid等于调用进程的gid
4. pid < -1 等待某一子进程，该子进程的进程gid 等于pid这个值的绝对值

options 为0或者按位或
	WCONTINUED 若实现支持作业控制，那么由pid指定的任意子进程在停止后被SIGCONT恢复继续，但其状态尚未报告，返回其状态
	WNOHANG 若pid指定的子进程没有退出，则waitpid不阻塞立即返回，此时返回0
	WUNTRACED 若实现支持作业控制，而由pid指定的任意子进程已处于停止状态，并且状态自停止以来未报告过，则返回其状态，WIFSTOPPED宏确定返回值是否对应于一个停止的进程

错误返回0或-1,成功返回终止的进程号
waitpid可以控制是否阻塞(通过WNOHANG)

status宏 
WIFEXITED(status)	若为正常终止子进程返回的状态，则为真，对于这种情况可执行WEXITSTATUS(status)获取子进程传递给exit或_exit参数的低8位
WIFSIGNALED(status)  若为异常终止子进程返回的状态，则为真，执行WTERMSIG(status)获取使子进程终止的信号编号,另外定义了宏WCOREDUMP的话，若已产生core文件，则为真
WIFSTOPPED(status) 若为当前暂停子进程的返回的状态，则为真，执行WSTOPSIG(status)获取使得子进程暂停的信号编号
WIFCONTINUED(status) 若在作业控制暂停后已经继续的子进程返回了状态，则为真

--------------------------------函数waitid---------------------
#include <sys/wait.h>

siginfo_t {
    int      si_signo;     /* Signal number */
    int      si_errno;     /* An errno value */
    int      si_code;      /* Signal code */
    int      si_trapno;    /* Trap number that caused
                              hardware-generated signal
                              (unused on most architectures) */
    pid_t    si_pid;       /* Sending process ID */
    uid_t    si_uid;       /* Real user ID of sending process */
    int      si_status;    /* Exit value or signal */
    clock_t  si_utime;     /* User time consumed */
    clock_t  si_stime;     /* System time consumed */
    sigval_t si_value;     /* Signal value */
    int      si_int;       /* POSIX.1b signal */
    void    *si_ptr;       /* POSIX.1b signal */
    int      si_overrun;   /* Timer overrun count;
                              POSIX.1b timers */
    int      si_timerid;   /* Timer ID; POSIX.1b timers */
    void    *si_addr;      /* Memory location which caused fault */
    long     si_band;      /* Band event (was int in
                              glibc 2.3.2 and earlier) */
    int      si_fd;        /* File descriptor */
    short    si_addr_lsb;  /* Least significant bit of address
                              (since Linux 2.6.32) */
    void    *si_lower;     /* Lower bound when address violation
                              occurred (since Linux 3.19) */
    void    *si_upper;     /* Upper bound when address violation
                              occurred (since Linux 3.19) */
    int      si_pkey;      /* Protection key on PTE that caused
                              fault (since Linux 4.6) */
    void    *si_call_addr; /* Address of system call instruction
                              (since Linux 3.5) */
    int      si_syscall;   /* Number of attempted system call
                              (since Linux 3.5) */
    unsigned int si_arch;  /* Architecture of attempted system call
                              (since Linux 3.5) */
}

int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
	成功返回0，错误返回-1
idtype:
	P_PID 等待一特定进程：id包含要等待子进程的进程id
	P_PGID 等待一特定进程组中的任意进程：id包含要等待子进程的进程组id
	P_ALL 等待任一子进程: 忽略id

options 按位或来操作
WCONTINUED 等待一进程，它以前曾被停止，此后又继续，但状态为报告
WEXITED 等待已经退出的进程
WNOHANG 如无可用的子进程退出状态，立刻返回而非堵塞
WNOWAIT 不破坏子进程退出状态，该子进程退出状态可以由后续的wait waitpid waitid来调用
WSTOPPED 等待一进程，它已经停止，但状态未报告

--------------------------------函数wait3 wait4-----------------------
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

pid_t wait3(int *statloc, int options, struct rusage *resage); resage资源统计信息包括用户cpu时间总量，系统cpu时间总量，缺页次数，接收到信号的次数(man getrusage)
pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);
成功返回进程id，否则返回-1

----------------------------------竞争条件-----------------
轮询polling:
如果某一子进程等地父进程结束
	while (getppid() != 1)
		sleep(1); //浪费cpu时间

---------------------------------函数exec---------------
exec不创建新进程(所以exec打印pid仍然是调用exec的进程id)，直接让磁盘上的一个程序替换当前进程的.text .data heap stack
需要注意必须对该文件有执行权限，然后必须是普通文件
 #include <unistd.h>

 extern char **environ;
对于envp的格式为"name=value"
 //若在使用ISO C之前，应该让最后一个参数为(char *)NULL
 //第一个参数为程序名 
eg:
	execl("/usr/bin/ls", "ls", "-l", "/" , (char*)0);
 int execl(const char *path, const char *arg, ...
                       /* (char  *) NULL */);

 int execv(const char *path, char *const argv[]);

 int execle(const char *path, const char *arg, ...
                      /*, (char *) NULL, char * const envp[] */);

 int execve(const char *pathname, char *const argv[], char *const envp[]);

 int execlp(const char *file, const char *arg, ...
                       /* (char  *) NULL */);
 int execvp(const char *file, char *const argv[]);

 int fexecve(int fd, char *const argv[], char *const envp[]);  成功不返回，错误返回-1

 file会根据PATH环境变量来找可执行文件若该文件不是二进制文件而视为shell脚本

 如何记忆:p表示参数为filename使用PATH环境变量作为相对路径，l表示va_list表，v表示argv[],e表示envp[],f表示fd
		 没有e则会使用全局变量里面的environ作为当前进程的环境



--------------------------------更改用户id和更改组id------------------
一般而言，在设计应用时，我们总是视图用最小权限模型

#include <unistd.h>
int setuid(uid_t uid);
int setgid(gid_t gid); //两个函数返回值:若成功返回0，错误返回-1

!!注意点:(以下同gid)
1.若进程具有超级用户特权，则setuid函数将实际uid，有效uid和saved set-user-id 都设置为uid参数
2.若进程没有超级用户特权，但是uid参数等于实际uid或saved set-user-id  ,则setuid只将有效uid设置为uid参数，不更改实际uid和saved set-user-id
3.若都不满足则错误

!!注意点:
内核维护了三个用户id
ID	                        exec                                        setuid(uid)
	                    rws中没有设置s       rws中设置了s             root   一般用户
实际uid                 不变                 不变                     uid参数 不变
有效uid                 不变                 文件所有者uid            uid参数 uid参数
saved set-user-id       从有效uid复制        从有效uid复制            uid参数 不变
(为euid副本)

getresuid, getresgid - get real, effective and saved user/group IDs
#define _GNU_SOURCE         /* See feature_test_macros(7) */
#include <unistd.h>
int getresuid(uid_t *ruid, uid_t *euid, uid_t *suid);
int getresgid(gid_t *rgid, gid_t *egid, gid_t *sgid);

NAME
       setreuid, setregid - set real and/or effective user or group ID
SYNOPSIS
#include <sys/types.h>
#include <unistd.h>

int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid); //返回值以上四个成功返回0失败返回-1

-------------------------------函数seteuid和setegid-----------------------
NAME
       seteuid, setegid - set effective user or group ID

SYNOPSIS
       #include <sys/types.h>
       #include <unistd.h>

       int seteuid(uid_t euid);
       int setegid(gid_t egid);
	   //返回值 成功 0 失败 -1
	   //对于普通用户可以修改其euid为实际uid和saved set-user-id
	   //对于超级用户可以将euid设置为euid参数(不同与setuid将全部改变)

//以上uid都适用于gid,但是附属gid不受影响


--------------------------------解释器文件(文本文件)---------------------------
形式是:
#! pathname[optional-argument]//#! pathname中间的空格是可选项
#!/bin/bash 最常见的
pathname通常是绝对路径(内核才会识别解释器文件,内核通过调用exec函数执行的实际上不是解释器文件而是pathname所指定的文件(该程序叫做解释器))
//exec  如果未识别文件的标题（尝试的execve（2）因错误ENOEXEC而失败），则这些exec函数将执行shell（/ bin / sh），并将文件的路径作为其第一个参数。 （如果此尝试失败，则不再进行进一步搜索。）
//如果识别文件标题为解释器文件则内核会exec解释器文件中#!pathname, 然后将[optional-argument]传递给pathename,之后再将解释器文件绝对路径传递给pathename这个解释器程序作为后续的参数，如果解释器文件后面仍然有参数，则会继续将这些传递给解释器文件的参数作为解释器后续参数
eg:
解释器文件myls

#!/usr/bin/ls -l 

解释器/usr/bin/ls

myls需要具有可执行权限
./myls fild1 filed2 
则会等价于/usr/bin/ls -l myls的绝对路径 fild1 fild2

---------------------------------函数system----------------------------
#include <stdlib.h>
int system(const char *cmdstring);
//返回值 
1.参数为NULL,若有任一shell可用则返回非0值，否则返回0
2.fork失败或者waitpid返回除EINTR之外的错误，则system返回-1，并且设置errno以表示错误类型
3.如果exec失败(不能执行shell)，则返回值如同shell执行了_exit(127)
4.否则返回shell的终止状态（它所执行的最后一个命名的终止状态)

//在fork之后exec之前应该将有效用户id有效组id修改为实际uid实际组id,否则fork后子进程会继承父进程的环境而exec仅仅替换.data .txt stack heap .bss段


----------------------------------process accounting进程记账------------------------
启用该选项后，每当进程结束时内核就会写一个记录，一般包含命令名，所使用的CPU时间总量，用户id和组id，启动时间等.
acct(5)
打印comp_t数据的方法
static unsigned long 
compt2ulong(comp_t comptime)
{
	return (comptime & 0x1fff) << (((comptime >> 13) & 0x7) * 3);
}


	 #define ACCT_COMM 16
     typedef u_int16_t comp_t;
	   Linux 2.4及更高版本中的GID和GID。记录定义如下：
           struct acct_v3 {
               char ac_flag; / *标志* /
               char ac_version; / *始终设置为ACCT_VERSION（3）* /
               u_int16_t ac_tty; / *控制终端* /
               u_int32_t ac_exitcode; / *进程终止状态* /
               u_int32_t ac_uid; / *真实用户ID * /
               u_int32_t ac_gid; / *真实组ID * /
               u_int32_t ac_pid; / *进程ID * /
               u_int32_t ac_ppid; / *父进程ID * /
               u_int32_t ac_btime; / *进程创建时间* /
               float ac_etime; / *经过的时间* /
               comp_t ac_utime; / *用户CPU时间* /
               comp_t ac_stime; /* 系统时间 */
               comp_t ac_mem; / *平均内存使用量（kB）* /
               comp_t ac_io; / *转移的字符（未使用）* /
               comp_t ac_rw; / *块读取或写入
                                          （没用过） */
               comp_t ac_minflt; / *次要内存页错误* /
               comp_t ac_majflt; / *主要内存页错误* /
               comp_t ac_swaps; / *swap交换区数量（未使用）* /
               char ac_comm [ACCT_COMM]; / *命令名* /
           };
           enum {          /* Bits that may be set in ac_flag field */
               AFORK = 0x01,           /* Has executed fork, but no exec */
               ASU   = 0x02,           /* Used superuser privileges */(进程使用了超级用户特权)
               ACORE = 0x08,           /* Dumped core */
               AXSIG = 0x10            /* Killed by a signal */
           };

-----------------------------用户标识--------------------------
#include <unistd.h>
char* getlogin(void); //返回值 成功 返回指向登录名的字符串指针 失败NULL

----------------------------进程调度-------------------------
历史上调整nice值（通过调整nice值来降低它对cpu的占有，因此该进程是“nice”的，所有越nice，优先级越低)
一般范围是0-(2*NZERO)-1//NZERO为操作系统默认nice值，通过sysconf(_SC_NZERO)来获取

#include <unistd.h>
int nice(int inc);
//返回值 成功inc的值 失败返回-1
inc为增加到该进程原有nice值,所以要想提高优先级需要inc为负数，!!注意点:但是由于返回值可以为-1（nice为-1），则需要判断errno是否被设置了非0
//同nice命令的规则只有超级用户才能提高进程优先级

#include <sys/time.h>
#include <sys/resource.h>
int getpriority(int which, id_t who);优先级[praɪ'ɒrəti]//成功返回-NZERO-NZERO-1之间的值，出错返回-1
which:
1.PRIO_PROCESS:进程id
2.PRIO_PGRP:进程组id,此时的返回值为nice最小的进程（优先级最高的)
3.PRIO_USER表示用户id
who为0时表示当前的进程id或进程组id或实际用户id


int setpriority(int which, id_t who, int prio);
prio增加到NZERO上,成功返回0，错误返回-1

------------------------------进程时间---------------------------------
#include <sys/times.h>
//获取进程时间
clock_t times(struct tms* buf);
  struct tms {
               clock_t tms_utime;  /* user time */
               clock_t tms_stime;  /* system time */
               clock_t tms_cutime; /* user time of children */
               clock_t tms_cstime; /* system time of children */
           };
//返回值 成功 返回流逝的挂钟时间（真实时间）以clock_t(时钟滴答数为单位),失败返回(clock_t)-1
//buf是一个相对值（比如times（buf)，times(buf)两次结果相减才是挂钟时间
clock_t类型的值可以通过sysconf(_SC_CLK_TCK)来获取每秒时钟滴答次数

==================================第9章:进程关系========================
==================================第10章:信号==========================
信号是软件中断，SIG开头
信号是异步事件的典型实例，产生信号的事件对进程而言是随机出现的（不可预测的），进程无法通过一个变量如errno来判断是否发生了信号，而是告诉内核"在此信号发生时该做什么"
可以做三类事情:
1.忽略此信号（但是有两种信号不能忽略SIGKILL和SIGSTOP)
2.捕获信号（告诉内核当发生该信号时自动调用一个用户函数）(但是不能捕获SIGKILL和SIGSTOP)
3.执行系统默认动作(大多数信号的系统默认动作是终止该进程)
!!注意点:The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.
!!注意点:调用exec函数会导致原先设置要捕获的信号都更改为默认动作（因为在新进程中信号处理函数的地址已经无意义)
!!注意点:在一个进程调用fork后，子进程会复制父进程的信号处理方式，因为子进程在开始时就复制了父进程的内存映像

信号处理是每个进程的属性，在多线程应用中，信号的处理对于所有线程都是相同的

#include <signal.h>
void (*signal(int sig, void (*func)(int)))(int);
//!注意点:then first either the disposition is reset to SIG_DFL, or the signal  is  blocked  (see Portability  below)//首次调用func后会重置该信号的处理函数（设置为SIG_DFL)

//返回值 成功返回func，失败返回SIG_ERR
sig是signal(7)中的值，func是常量SIG_IGN(忽略)或SIG_DFL(默认)或当接收到该信号的时候处理函数的地址
信号处理函数也叫作（signal handler）（signal-catching function)

-----------------------(上古时期)不可靠信号-------------------
不可靠指的是信号存在丢失情况(捕获信号在处理信号之前发生了又一个信号)

-----------------------中断的系统调用----------------------
上古时期如果进程在执行一个低速的系统调用而阻塞期间捕捉到一个信号则该系统调用就被中断不再继续执行。
为了满足该特性：系统调用分为两种（低速系统调用和其他），低速系统调用(一般是操作低速设备)是可能会使进程永远阻塞的一类系统调用，为了使该系统调用不需要程序员进行人工地重启（如read系统调用被中断时可能返回错误，并且errno设置为EINTR)，某些操作系统引入了自动重启功能

----------------------可重入函数(在信号处理过程中保证调用安全(比如进程正在执行malloc时捕获到的信号，用于处理信号的函数中再次使用mallo，可能会导致进程破坏)c的函数,也称之为异步信号安全的async-signal safe)---------------------
当进程捕获到信号并对其进行处理时，会临时中断正在执行的正常指令序列(若该操作不是原子的，则可能会导致难以预计的结果)

应该避免在信号处理程序中使用不可重入函数(异步信号不安全函数)

--------------------------SIGCLD语义--------------------------
在 x86_64 Linux 4.15.0-30deepin-generic,SIGCLD等同于SIGCHLD
在别的早期系统上SIGCLD则不等同于SIGCHLD,如果进程特地设置该信号的配置为SIG_IGN,则调用进程的子进程将不产生僵死进程,如果将SIGCLD的配置设置为捕捉，则内核立即检查是否有子进程准备好被等待，如果是这样，则调用SIGCLD处理程序。

-----------------------可靠信号术语和语义------------------------
当造成信号的事件发生时，为进程！！产生！！一个信号（或向一个进程发送一个信号），当一个信号产生时，内核通常在进程表中以某种形式设置一个标记位，当对信号采取了这种动作时，我们说向进程！！递送！！了一个信号，在信号产生和递送之间的时间间隔内，称信号为未决的

执行信号的处理动作成为信号递达（Delivery），信号从产生到递达之间的状态称为信号未决(Pending)。进程可以选择阻塞(Block)某个信号。
被阻塞的信号产生时将保持在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作
注意：阻塞和忽略是不同的，只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作

每一个进程都有一个信号屏蔽字，它规定了当前要阻塞递送到该进程的信号集

==================================第11章:线程========================
每个线程都包含有表示执行环境所必须的信息，其中包括线程id，一组寄存器值，栈，调度优先级和策略以及信号屏蔽字，errno变量以及线程私有数据
一个进程的所有信息是所有线程共享的，包括可执行代码，程序的全局，堆，栈以及文件描述符

-------------------------------线程标识---------------------
#include <pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);
//返回值 相等返回非0 否则返回0

#include <pthread.h>
pthread_t pthread_self(void);
//返回值 调用线程的id

#include <pthead.h>
int pthread_create(pthread_t *restrict tidp, const pthread_attr_t *restrict attr, void *(*start_rtn)(void*), void *restrict arg);
//返回值 成功0 错误返回错误编号
//函数一旦开始就进入了竞争阶段

--------------------------------线程终止--------------------
如果进程中的任意线程调用了exit（_Exit _exit)那么整个进程就会终止
线程终止:
1.调用pthread_exit
2.可以被同一进程的其他线程取消
3.可以简单地从启动例程中返回return((void*)val)，返回值是线程的退出码

#include <pthread.h>
void pthread_exit(void *rval_ptr);
pthread_exit（）函数终止调用线程并通过retval返回一个值（如果线程是可连接的,进程中的其他线程也可以通过调用pthread_join来访问这个指针

#include <pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);//void* rval_ptr, &rval_ptr来传输
//返回值 成功 0 否则返回出错码
//调用线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程(开启新线程的线程)中返回或者被取消
//如果线程返回了则ravl_ptr就指向pthread_exit或return的值(!!注意点:线程不要返回局部的地址)，如果线程被取消，则rval_ptr所指向的内存单元就设置为PTHREAD_CANCELED
//可以通过调用pthread_join自动把线程置于分离状态，这样子资源就可以恢复，如果线程已经处于分离状态，则pthread_join就会失败


#include <pthread.h>
int pthread_cancel(pthread_t tid);
//取消同一进程中的其他线程,只是提议，可以被指定的线程忽略或者控制如何被取消，成功取消的话效果等价于pthread_exit(PTHREAD_CANCELED);
//返回值 成功0 失败 返回错误码

#include <pthread.h>
//同进程退出时调用函数atexit,
//以下两个函数可能实现为宏
void pthread_cleanup_push(void (*rtn)(void *), void *arg);
void pthread_cleanup_pop(int execute);//删除上一次push
1.调用pthread_exit时(但线程return返回时不会调用trn)
2.响应取消时
3.用非零execute调用pthead_cleanup_pop时(如果execute被设置为0，则清理函数不被调用,但是如果在push和pop之间插入pthread_exit的话则仍然会调用trn)
以上任意一种情况会由pthread_cleanup_push调用rtn(注意push和pop的个数需要在与线程相同的作用域内匹配(这个函数实现为宏，该宏push设置了{而pop设置了},如果pop和push不匹配则编译错误)


#include <pthread.h>
int pthread_detach(pthread_t tid);//不会像join一样阻塞当前线程
//返回值成功0 错误返回错误码
//分离线程的作用
//对于一个分离状态的线程不能用pthread_join来等待它的终止状态（如果线程被分离，则线程的底层资源可以在线程终止时立即被回收)
//默认情况下，线程的终止状态会被保存，直到pthread_join

--------------------------------线程同步--------------------
同步问题涉及到存储器周期

---------------------------互斥量（确保同一个时间只有一个线程访问数据)---------------
互斥量从本质来说是一把锁，在访问共享资源前对互斥量进行设置，在访问完成后释放互斥量
当释放互斥量（解锁）后，被阻塞的线程中第一个变成运行的线程会对互斥量进行上锁，这样操作后就可以保证每次只有一个线程在运行

#include <pthread.h>
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;//效果等价于pthread_mutex_init(&mutex, NULL)但是不执行错误检查
int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);//返回值 成功 0 失败返回错误码

#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
//返回值 成功 0 失败 错误码

pthread_mutex_trylock()调用在参数mutex指定的mutex对象当前被锁住的时候立即返回，除此之外，pthread_mutex_trylock()跟pthread_mutex_lock()功能完全一样。
pthread_mutex_trylock() 在成功获得了一个mutex的锁后返回0，否则返回一个错误提示码错误.

---------------------------------避免死锁-----------------
1.线程试图对同一个互斥量加锁两次(因为第一次加锁后还没有释放,第二次则只能等待)
2.可能出现的死锁只会发生在一个线程试图锁住另外一个线程以相反的顺序锁住的互斥量
(A:mutex1 mutex2(等待2解锁) B:mutex2 mutex1(等待1解锁))
(可以用pthread_mutex_trylock来测试mutex2，若返回错误的话，可以释放mutex1）

--------------------------------------函数pthread_mutex_timedlock---------------
#include <pthread.h>
#include <time.h>
//超过abstime这个绝对时间(表示在abstime这个绝对时间之前可以阻塞)就放弃阻塞返回错误码
//注意阻塞的时间可能会有不同，1.调度延迟可能会增加时间2.系统时钟的精度可能不足以支持这个abstime的设置
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
//返回值 成功0 失败  错误码

------------------------------------读写锁(也叫作共享互斥锁)--------------------------------
读写锁类似互斥量:
但是有三种状态
1.读模式下加锁状态(所有读模式被放行，写模式被阻塞)
2.写模式下加锁状态(写模式一次只有一个线程可以占有,一般情况下如果有读写锁处于读模式锁住的情况下，若有一个线程试图以写模式获取锁，读写锁通常会阻塞后面的读模式请求，以防止写模式一直得不到满足)
3.不加锁状态
通常适用于读的次数大于写的次数的情况，在使用之前必须初始化

#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
//返回值 成功 返回0 错误返回错误码
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;//同pthread_mutex_宏初始化

#include <pthread.h>
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
//返回值 成功 返回 0 失败返回错误码

//对应于mutex_trylock
#include <pthread.h>
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
//返回值 成功 返回 0 失败返回错误码

#include <pthread.h>
#include <time.h>
//同pthread_mutex_timedlock
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
    const struct timespec *restrict abstime);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
    const struct timespec *restrict abstime);


----------------------------条件变量——-------------------------
#include <pthread.h>
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_init(pthread_cond_t *restrict cond,    const pthread_condattr_t *restrict attr);
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
//返回值 成功 0 失败返回错误码

int pthread_cond_timedwait(pthread_cond_t *restrict cond,      pthread_mutex_t *restrict mutex,      const struct timespec *restrict abstime);
int pthread_cond_wait(pthread_cond_t *restrict cond,      pthread_mutex_t *restrict mutex);
//返回值 成功 0 失败返回错误码
//mutex需要先上锁
//执行以上两个函数后，会让调用线程放在等待条件的线程列表上，然后对互斥量解锁（以便其他线程获得锁开启其他工作),当函数返回时，互斥量再次上锁
//!!注意点:当条件变量为真时，需要再次验证所保护的条件是否真的满足，因为可能另一线程发出pthread_cond_signal信号之前，条件被其他线程所更改了

//通知线程条件已经满足
#include <pthread.h>
int pthread_cond_signal(pthread_cond_t *cond);//至少唤醒一个等待该条件的线程,此时条件变量应该为真
int pthread_cond_broadcast(pthread_cond_t *cond);//唤醒全部等待该条件的线程
//返回值 成功0 失败 返回错误码

--------------------------------------------自旋锁---------------------------------
自旋锁类似于互斥量(随着处理器进步，以及有些互斥量的实现会先让试图获取互斥量的线程先自旋一段时间，导致和互斥量的性能基本相同)，但是不是通过休眠使得线程阻塞，而是在获取锁之前处于忙等（自旋）阻塞状态
一般用于锁被持有的时间短，而且线程不希望在重新调度上花费太多成本

自旋锁通常作为底层原语用于实现其他类型的锁，根据所基于的系统体系结构，可以通过使用测试并设置指令来实现，当线程自旋等待锁变为可用时，cpu不能做其他事情，这也是自旋锁只能够被持有一小段时间的原因
#include <pthread.h>
int pthread_spin_destroy(pthread_spinlock_t *lock);
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
//返回值 成功0 失败返回错误码
pshard:
1.PTHREAD_PROCESS_SHARED:自旋锁能够被可以访问锁底层内存的线程所获取（即使那些线程属于不同的进程)
2.PTHREAD_PROCESS_PRIVATE:自旋锁只能被初始化该锁的进程内部的线程所访问

#include <pthread.h>
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);//不进行自旋，如果不能获取锁里面返回
int pthread_spin_unlock(pthread_spinlock_t *lock);
//返回值 成功0 失败返回错误码
!!注意点:不要在持有自旋锁状态下调用需要进入休眠状态的函数

----------------------------------------------屏障--------------------------------
屏障是用户协调多个线程并行工作的同步机制，允许每个线程等待，直到所有的合作线程都到达了某一点
//pthread_join就是一种屏障，允许一个线程等待，直到另外一个线程退出(到达了退出状态)
['bæriə(r)]barrier
#include <pthread.h>
int pthread_barrier_destroy(pthread_barrier_t *barrier);
int pthread_barrier_init(pthread_barrier_t *restrict barrier,    const pthread_barrierattr_t *restrict attr, unsigned count);
//返回值 成功0 失败返回错误码
//count指定了，在允许所有线程继续运行之前，必须到达屏障的线程数目

#include <pthread.h>
//准备等待其他线程到达屏障
int pthread_barrier_wait(pthread_barrier_t *barrier);
//返回值 成功0或者PTHREAD_BARRIER_SERIAL_THREAD
								['sɪəriəl]串行
//调用该函数的线程会在屏障计数为到达count之前进入休眠状态，如果该线程是最后一个调用该函数的线程，就满足了屏障计数，那么所有的线程都被唤醒
//pthread_barrier_wait（）函数将为在屏障处同步的单个（任意）线程返回PTHREAD_BARRIER_SERIAL_THREAD，并为每个其他线程返回零。


=====================================第12章 线程控制=====================
-----------------------------------线程控制----------------------------
sysconf来获取

---------------------------------线程属性---------------------------
1.每个对象与自己类型的属性对象进行关联（线程与线程属性关联，互斥量与互斥量属性关联)
2.有一个初始化函数，把属性值设置为默认值
3.还有一个销毁属性对象的函数
4.每个属性都有一个从属性对象中获取属性值的函数
5.每个属性都有一个设置属性值的函数(按值传递)

#include <pthread.h>
int pthread_attr_init(pthread_attr_t *attr);//在调用该函数后，线程属性是操作系统实现支持的默认属性
int pthread_attr_destroy(pthread_attr_t *attr);
//返回值 成功 0 失败返回错误码

属性:
名称						描述							
detachstate 				线程的分离状态属性
guardsize[ɡɑː(r)d](警戒)	线程栈末尾的警戒缓冲区大小（byte)//避免栈溢出导致的程序崩溃（若在线程栈末尾之后仍超过该值则会越界访问)
stackaddr 					线程栈的最低地址//如果修改了该属性操作系统会认为需要自己管理栈，于是等价于将guardsize设置为0
stacksize 					线程栈的最小长度（byte)
#include <pthread.h>
int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
int pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate);
//返回值 成功 0 失败返回错误码
detachstate:
PTHREAD_CREATE_DETACHED(线程结束后状态不保留立即被操作系统回收)
       Threads that are created using attr will be created in a detached state.
PTHREAD_CREATE_JOINABLE
       Threads that are created using attr will be created in a joinable state.


#include <pthread.h>
int pthread_attr_setstack(pthread_attr_t *attr,
                          void *stackaddr, size_t stacksize);
int pthread_attr_getstack(const pthread_attr_t *attr,
                          void **stackaddr, size_t *stacksize);
//返回值 成功 0 失败返回错误码
//stackaddr属性是线程栈的最低地址，但是不一定是栈的开始位置（依赖于处理器结构，栈是低生长还是高生长)
//同一个进程中的所有线程共同享有进程的栈大小

#include <pthread.h>
int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);
int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize);
//返回值 成功 0 失败返回错误码
//利用该函数就不用考虑处理器结构的问题
//但是stacksize不能小于PTHREAD_STACK_MIN

#include <pthread.h>
int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize);
int pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize);
//返回值 成功 0 失败返回错误码
//如果guardsize被修改了，则操作系统可能会把它取为内存页大小的整数倍

---------------------------------------------------同步属性----------------------------------
自旋锁拥有一个属性为进程共享属性
----------------------------互斥量属性---------------------------------
#include <pthread.h>
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_init(pthread_mutexattr_t *attr);
//返回值 成功 0  失败返回错误码

1.进程共享属性
#include <pthread.h>
int pthread_mutexattr_getpshared(const pthread_mutexattr_t
    *restrict attr, int *restrict pshared);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr,
    int pshared);
//返回值 成功 0 失败返回错误码
//使用PTHREAD_PROCESS_PRIVATE进程共享属性初始化的同步变量只能由初始化它们的进程中的线程操作
//使用PTHREAD_PROCESS_SHARED进程共享属性初始化的同步变量可以由任何有权访问它的进程中的任何线程操作

2.健壮属性
#include <pthread.h>
int pthread_mutexattr_getrobust(const pthread_mutexattr_t *restrict
    attr, int *restrict robust);
int pthread_mutexattr_setrobust(pthread_mutexattr_t *attr,
       int robust);
//返回值 成功 0  失败返回错误码
PTHREAD_MUTEX_STALLED
              持有互斥锁的进程终止时，不会采取任何特殊操作。 如果没有其他线程可以解锁互斥锁，则可能导致死锁。(对于另一个进程来说)
              这是默认值。
PTHREAD_MUTEX_ROBUST
			  如果一个线程调用pthread_mutex_lock获取锁，而该锁被另外一个进程所拥有而该进程终止时没有解锁，则该调用pthread_mutex_lock的线程的函数返回值为EOWNERDEAD而不是0
//不管该属性如何都应该进行恢复,否则该互斥量处于永久不可用状态

//针对上述情况产生了
#include <pthread.h>
int pthread_mutex_consistent(pthread_mutex_t *mutex);//返回值 成功 0 失败返回错误码
//该函数可以指明该互斥量的状态在互斥量解锁之前是一致的
//如果线程没有先调用该函数然后解锁，那么其他试图获取互斥量的阻塞线程就会得到错误码(防止死锁)，此时该互斥量不可再用
//通过提前调用该函数就可以使得互斥量正常工作

3.类型属性
PTHREAD_MUTEX_NORMAL:不做任何特殊的错误检查或死锁检测
PTHREAD_MUTEX_ERRORCHECK:提供错误检查
PTHREAD_MUTEX_RECURSIVE(recursive[rɪ'kɜː(r)sɪv]递归的)//允许统一线程在互斥量解锁之前对该互斥量进行多次加锁（会验证加锁次数是否等于解锁次数,若不相等则不会释放锁)//在单线程接口移植到多线程环境中，获取该属性是有用的，但是很难处理，除非没有其他方法不要选取该属性（避免死锁,但是需要解锁多次)!!!!!!!!!!!!!!!
PTHREAD_MUTEX_DEFAULT:根据实现映射到上述三种类型

互斥量类型					没有解锁时重新加锁?				本线程不占有锁时对另一线程的锁进行解锁?				在已经解锁后继续解锁
PTHREAD_MUTEX_NORMAL		死锁							未定义												未定义
PTHREAD_MUTEX_ERRORCHECK 	返回错误（可以用于调试bug)		返回错误											返回错误
PTHREAD_MUTEX_RECURSIVE 	允许							返回错误											返回错误

#include <pthread.h>
int pthread_mutexattr_gettype(const pthread_mutexattr_t *restrict attr,
           int *restrict type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
//返回值 成功 返回0 失败返回错误码

--------------------------------读写锁属性---------------------------
#include <pthread.h>
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
唯一属性:
	进程共享属性
#include <pthread.h>
int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t
           *restrict attr, int *restrict pshared);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr,
           int pshared);

------------------------------条件变量属性--------------------------
#include <pthread.h>
int pthread_condattr_destroy(pthread_condattr_t *attr);
int pthread_condattr_init(pthread_condattr_t *attr);
属性:
	进程共享属性  
		#include <pthread.h>
       int pthread_condattr_getpshared(const pthread_condattr_t *restrict attr,
           int *restrict pshared);
       int pthread_condattr_setpshared(pthread_condattr_t *attr,
           int pshared);
	时钟属性:
	    #include <pthread.h>

       int pthread_condattr_getclock(const pthread_condattr_t *restrict attr,
           clockid_t *restrict clock_id);
       int pthread_condattr_setclock(pthread_condattr_t *attr,
           clockid_t clock_id);
		//clockid_t的类型决定了pthread_cond_timedwait()中的时间采取哪种时间类型

-----------------------------------------屏障属性-------------------------------
#include <pthread.h>
int pthread_barrierattr_destroy(pthread_barrierattr_t *attr);
int pthread_barrierattr_init(pthread_barrierattr_t *attr);
唯一属性:
	进程共享属性:
	    #include <pthread.h>
       int pthread_barrierattr_getpshared(const pthread_barrierattr_t
           *restrict attr, int *restrict pshared);
       int pthread_barrierattr_setpshared(pthread_barrierattr_t *attr,
           int pshared);

==================================第16章 网络IPC:套接字
套接字描述符：（如同文件描述符）应用程序用套接字描述符来访问套接字
套接字描述符在unix上被当做文件描述符，因此处理文件描述符的系统调用都可以处理套接字描述符
#include <sys/socket.h>
int socket(int domain, int type, int protocol); //返回值 成功 返回文件（套接字)描述符，失败-1  
domain域 确定通信的特定，包括ip地址格式
  	 AF_UNIX, AF_LOCAL   Local communication(局域通信)              unix(7)
	 AF_INET             IPv4 Internet protocols          ip(7)
	 AF_INET6            IPv6 Internet protocols          ipv6(7)
	 AF_IPX              IPX - Novell protocols(IPX协议与IP协议是两种不同的网络层协议，它们的路由协议也不一样，IPX的路由协议不像IP的路由协议那样丰富，所以设置起来比较简单)
	 AF_NETLINK          Kernel user interface device     netlink(7)
	 AF_X25              ITU-T X.25 / ISO-8208 protocol   x25(7)
	 AF_AX25             Amateur radio AX.25 protocol
	 AF_ATMPVC           Access to raw ATM PVCs
	 AF_APPLETALK        AppleTalk(appletalk ( AT )是由Apple公司创建的一组网络协议的名字，它用于 Apple系列的个人计算机)ddp(7)
	 AF_PACKET           Low level packet interface       packet(7)
	 AF_ALG              Interface to kernel crypto API(内核加密API)
AF(address family地址类型，协议族)

type:
应用层——消息
传输层——数据段(segment)
网络层——分组、数据包（packet）
链路层——帧（frame）
物理层——P-PDU（bit）


 SOCK_STREAM     Provides sequenced, reliable, two-way, connection-based byte streams.  An out-of-band data transmission mechanism may be supported.//可以支持带外传输数据机制(默认使用tcp协议,因为提供的是字节流服务，应用程序分辨不出报文的限制，这意味着SOCK_STREAM套接字读取数据时，它也许不会返回所有由发送进程所写的字节数，最终可以获得发送过来的所有数据，但也许需要通过多次read系统调用)
 SOCK_DGRAM      Supports datagrams (connectionless, unreliable messages of a fixed maximum length).//无连接，固定最大长度，不可靠(默认使用udp协议)
 SOCK_SEQPACKET  Provides  a sequenced, reliable, two-way connection-based data transmission path for datagrams of fixed maximum length//固定最大长度; a consumer is required to read an entire(整个) packet with each input system call.//每次调用read会读取全部数据(SCTP流控制传输协议，提供了网络上的顺序数据包服务，因此从这接受的数据量与对方所发送的一致)
 SOCK_RAW        Provides raw(原始) network protocol access.(用于直接访问网络层ip层，使用这个接口时，需要自己构造传输层协议，需要创建一个该原始套接字时，需要有root权限以便防止恶意应用绕过inbuild安全机制来创建报文

 SOCK_RDM        Provides a reliable datagram layer that does not guarantee ordering.//不保证有序

 SOCK_PACKET     Obsolete(已经过时) and should not be used in new programs; see packet(7).XXXXXXXXXXXXXXX

 SOCK_NONBLOCK   Set  the  O_NONBLOCK file status flag(O_NONBLOCK文件状态标志) on the new open file description.  Using this flag saves extra calls to fcntl(2) to achieve the same result.

 SOCK_CLOEXEC    Set the close-on-exec (FD_CLOEXEC) flag on the new file descriptor.  See the  description  of  the  O_CLOEXEC flag in open(2) for reasons why this may be useful.

 protocol:
 	通常是0:表示为给定的域和套接字类型选择默认协议(当同一个domain和type支持多个协议时，可以用此参数控制特定协议
		

虽然socket和open类似，但是不是所有的接受文件描述符的系统调用都可以接受套接字描述符,套接字没有文件偏移量的概念

套接字通信是双向的，可以使用shutdown来禁止一个套接字的IO
#include <sys/socket.h>
int shutdown(int sockfd, int how);
//返回值 成功 0 失败-1
how:
	SHUT_RD(关闭读，接受)
	SHUT_WR(关闭写，发送)
	SHUT_RDWR(全部关闭)
close只有当最后一个活动引用关闭时，close才会释放网络节点（类似多个进程打开了同一个文件创建了多个文件描述符)
close //销毁套接字

-------------------------------寻址------------------------
CPU架构决定了内存大小端模式(字节序)

网络协议指定了字节序，因此不同cpu架构的计算机可以交换信息而不受字节序所混淆

TCP/IP协议栈使用了大端字节序.

网络字节顺序是TCP/IP中规定好的一种数据表示格式，它与具体的CPU类型、操作系统等无关，从而可以保证数据在不同主机之间传输时能够被正确解释。网络字节顺序采用big endian（大端）排序方式。

/h表示主机字节序（一般是小端模式），n表示网络（大端模式)l表示long s表示short
 #include <arpa/inet.h>
      uint32_t htonl(uint32_t hostlong);//主机到网络字节序
      uint16_t htons(uint16_t hostshort);
      uint32_t ntohl(uint32_t netlong);//网络到主机字节序
      uint16_t ntohs(uint16_t netshort);
-----------------------------------地址(ip地址)格式-------------------
用于存储参与（IP）Windows/linux套接字通信的计算机上的一个internet协议（IP）地址。为了统一地址结构的表示方法 ，统一接口函数，使得不同的地址结构可以被bind()、connect()、recvfrom()、sendto()等函数调用。
sockaddr记录了ip地址(ip地址会被强转为sockaddr类型)
  #include <arpa/inet.h>
//将sockaddr结构打印成人类可读的ip地址方式
  const char *inet_ntop(int af, const void *src,
                             char *dst, socklen_t size);
//将网络字节序的二进制地址转换成文本形式("xxx.xxx.xxx.xxx")
//af:
	    AF_INET
		AF_INET6
		size指定了缓冲区大小(INET_ADDRESTRLEN定义了足够大的空间来存放IPv4地址的文本字符串
				INET^_ADDRSTRLEN则用于存放IPv6

  int inet_pton(int af, const char *src, void *dst);
//则相反,将文本形式转换成网络字节序的二进制地址如果是AF_INET则需要确保dst的大小足够存放32个字节大小(sizeof(struct in_addr))
  AF_INET6,需要dst的大小足够存放128个字节大小(sizeof(struct in6_addr))

---------------------------------ip地址查询-----------------------
netstat命令
//获取给定的计算机系统的主机信息
//通过本地或DNS或NIS(网络信息服务)
#include <netdb.h>
// struct hostent {
               char  *h_name;            /* official name of host */		返回的ip地址采用网络字节序
               char **h_aliases;         /* alias list */
               int    h_addrtype;        /* host address type */
               int    h_length;          /* length of address */
               char **h_addr_list;       /* list of addresses */
           }

struct hostent* gethostent(void); //返回值 成功 指针 失败NULL
void sethostent(int stayopen); 
void endhostend(void);


//获取网络名字和网络编号
 struct netent {
               char      *n_name;     /* official network name */
               char     **n_aliases;  /* alias list */
               int        n_addrtype; /* net address type */ (AF_INET6或AF_INET)
               uint32_t   n_net;      /* network number */ 按照网络字节序返回
           }

#include <netdb.h>
struct netent* getnetbyaddr(uint32_t net, int type);
struct netent* getnetbyname(const char* name);

struct netent* getnetend(void);//返回值 成功 指针 失败NULL
void setnetent(int stayopen);
void endnetent(void);

//在协议名字和协议编号之间进行映射
   #include <netdb.h>
 struct protoent {
               char  *p_name;       /* official protocol name */
               char **p_aliases;    /* alias list */
               int    p_proto;      /* protocol number */
           }
   struct protoent *getprotobyname(const char *name);

   struct protoent *getprotobynumber(int proto);

   struct protoent *getprotoent(void);
   void setprotoent(int stayopen);
   void endprotoent(void);

//在服务和端口号之间映射
     #include <netdb.h>

       struct servent {
               char  *s_name;       /* official service name */
               char **s_aliases;    /* alias list */
               int    s_port;       /* port number */
               char  *s_proto;      /* protocol to use */
           }


       struct servent *getservbyname(const char *name, const char *proto);

       struct servent *getservbyport(int port, const char *proto);

       struct servent *getservent(void);
       void setservent(int stayopen);
       void endservent(void);
//将一个主机名和服务名映射到一个ip地址
 #include <sys/types.h>
       #include <sys/socket.h>
       #include <netdb.h>
//需要提供主机名(参数node)也可以是ip地址，服务名，或者两者都提供，如果仅仅提供名字，另外一个必须是NULL
       int getaddrinfo(const char *node, const char *service,
                       const struct addrinfo *hints, struct addrinfo **res);//返回值 成功0 失败错误码 
			//可以通过hints参数来选择符合特定条件的ip地址(相当于过滤),
ai_flags:
				  AI_ADDRCONFIG//查询匹配的ip地址类型
				  AI_ALL//查找IPv4和IPv6地址(仅用于AI_V4MAPPED)
				  AI_CANONNAME//主机规范名称
				  AI_NUMERICHOST//以数字格式指定主机地址
				  AI_NUMERICSERV//将服务指定为数字端口号
				  AI_PASSIVE//套接字地址用于监听绑定
				  AI_V4MAPPED//如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址
ai_family;			
ai_socktype;
ai_protocol;
			以上字段必须给定，其他整数字段必须是0，指针字段则为NULL
    struct addrinfo {
               int              ai_flags;//customize(自定义) behavior
               int              ai_family;//AF
               int              ai_socktype;
               int              ai_protocol;
               socklen_t        ai_addrlen;
               struct sockaddr *ai_addr;
               char            *ai_canonname;主机的规范(canonical)名称
               struct addrinfo *ai_next;
           };

       void freeaddrinfo(struct addrinfo *res);

       const char *gai_strerror(int errcode);


 #include <sys/socket.h>
       #include <netdb.h>
//将一个ip地址转换成一个主机名和一个服务名
       int getnameinfo(const struct sockaddr *addr, socklen_t addrlen,
                       char *host, socklen_t hostlen,
                       char *serv, socklen_t servlen, int flags);
//flags：
	NI_DGRAM: 服务基于数据报(udp)而非基于流(tcp)
	NI_NAMEREQD: 如果找不到主机名，将其视为一个错误对待
	NI_NOFQDN:对于本地主机，仅返回全限定域名的主机名部分
	NI_NUMEPICHOST:返回主机地址的数字形式，而非主机名
	NI_NUMERICSCOPE:对于IPv6返回范围ID的数字形式，而非名字
	NI_NUMERICSERV:返回服务地址的数字形式（端口号），而非名字

-----------------------------将套接字和ip地址关联
bind来关联ip地址和套接字
#include <sys/socket.h>
int bind(int sockfd, const struct sockaddr* addr, socklen_t len);
对于使用的addr有如下限制:
1.在进程正在运行的计算机，地址必须有效
2.ip地址必须和创建套接字时的ip协议族AF所支持的格式相互匹配
3.地址的端口号必须不少于1024，除非该进程具有root权限
4.一般只能将一个套接字端点绑定到一个给定ip地址上

//查找绑定到套接字上的地址
#include <sys/socket.h>
int getsockname(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict alenp);
//返回值 成功0失败-1

//如果套接字已经和对等放连接，可以查找对方的地址
#include <sys/socket.h>
int getpeername(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict alenp);
//返回值 成功0 错误-1

-------------------------建立连接---------------------------------
(如果采用面向连接的网络服务SOCK_STREAM或SOCK_SEQPACKET)需要用connet来建立连接
#include <sys/socket.h>
int connect(int sockfd, const struct sockaddr * addr, socklen_t len);
//甚至可以用于SOCK_DGRAM（udp)这样子传送报文的目标地址会设置成connect中的地址，以便每次传送报文的时候不要再次提供地址
//返回值 成功0 错误-1
如果sockfd没有绑定到一个给定的地址，那么connet会给调用者绑定一个随机地址
.失败的可能:
	网络问题
	对方计算机没有开启
	服务器等待队列有足够空间

失败：特殊系统(FreeBSD和Mac OS X)如果connect第一次失败则会导致该套接字后续仍然失败

#include <sys/socket.h>
int listen(int sockfd, int backlog);//返回值 成功 0 错误-1
//backlog:
	提供系统该进程所要入队的未完成连接请求数量
	SOMAXCONN(<sys/socket.h>最大值

一旦队列满，会拒绝对于的连接请求，一旦服务器调用了listen，则所用的套接字就能接受连接请求，使用accept获得请求并建立连接
#include <sys/socket.h>
int accept(int sockfd, struct sockaddr* restrict addr, socklen_t *restrict len);
//返回值 成功返回套接字描述符，失败-1
//该描述符连接到调用connect的客户端
//新的套接字描述符和sockfd原始的套接字描述符具有相同的套接字类型和ip协议族,传给accept的原始套接字没有关联到这个连接，而是继续保持可用状态并接受其他连接请求

如果不关心客户端标识，addr和len可以为NULL
如果没有连接请求，accept会一直阻塞直到一个请求到来，如果sockfd为非阻塞模式，则accpet会返回-1
//服务器可以使用poll和select来等待一个请求的到来，在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现


-----------------------------------数据传输---------------------------------------
如果想指定选项，从多个客户端接受数据包或者发送带外数据需要使用下面系统调用，否则可以使用read和write
#include <sys/socket.h>
//send如果是tcp连接，则会发送完所有数据否则会阻塞整个数据传输完成
ssize_t send(int sockfd, const void* buf, size_t nbytes, int flags); //返回值 成功发送的字节数，失败-1
基本等同于write
//send成功 并不代表对方接受到了数据，只能保证数据已经被无错误地传递给了网络驱动程序（网卡驱动)
//一般flags表示0

sendto则可以在无连接的套接字上指定一个目标地址
ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);
//面向连接的套接字，目标地址是被忽略的，因为连接中隐含了目标地址，而对于无连接的套接字则除非先通过connect来设置否则不能使用send
通过套接字发送数据时，还有一个选择可以指定多重缓冲区来传输数据
#include <sys/socket.h>
ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);

    struct msghdr {
               void         *msg_name;       /* optional address */
               socklen_t     msg_namelen;    /* size of address */
               struct iovec *msg_iov;        /* scatter/gather array */
               size_t        msg_iovlen;     /* # elements in msg_iov */
               void         *msg_control;    /* ancillary data, see below */
               size_t        msg_controllen; /* ancillary data buffer len */
               int           msg_flags;      /* flags (unused) */
           };

 #include <sys/types.h>

ssize_t recv(int sockfd, void *buf, size_t len, int flags); //返回值 返回数据的字节长度，若没有可用数据或对等方已经按序结束则返回0，错误返回-1
基本同于read，不同的是用flags

ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
                 struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

send的flag
标志					说明 								
MSG_CONFIRM			提供链路层反馈以保持ip地址映射有效	                           	
MSG_DONTROUTE		不要讲数据包发送出本地网络
MSG_DONTWAIT		允许非阻塞操作(O_NONBLOCK)
MSG_EOF				发送数据后关闭套接字的发送端
MSG_EOR				如果协议支持，标记记录结束
MSG_MORE 			延迟发送数据包允许写更多数据
MSG_NOSIGNAL 		在写无连接的套接字时不产生SIGPIPE信号
MSG_OOB 			如果协议支持，发送带外数据

recv的falg
标志					说明 								
MSG_CMSG_CLOEXEC		为UNIX域套接字接受的文件描述符设置FD_CLOEXEC
MSG_DONTWAIT 			启动非阻塞操作O_NONBLOCK
MSG_ERRQUEUE 			接受错误信息作为辅助数据
MSG_OOB 				如果协议支持，获取带外数据
MSG_PEEK 				返回数据包内容而不真正取走数据包(再次调用时是同一个数据)
MSG_TRUNC 				即使数据包被截断，也返回数据包的实际长度
MSG_WAITALL 			等待直到所有的数据可用(仅SOCK_STREAM)

#include <sys/socket.h>
//获取数据发送来源的地址
ssize_t recvfrom(int sockfd, void *restrict buf, size_t len, int flags, struct sockaddr *restrict addr, socklen_t *restrict addrlen);
//返回值 成功返回数据的字节长度，若无可用数据或对等方已经按序结束，返回0，错误返回-1
(一般用于无连接)

//接受到的数据送入多个缓冲区
#incude <sys/socket.h>
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
//返回值 成功返回数据的字节长度，若无可用数据或对等方已经按序结束，返回0，错误返回-1


