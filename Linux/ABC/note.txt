第一部份：Linux的规划与安装
第二部份：Linux文件、目录与磁盘格式
第三部份：学习Shell与Shell Scripts
第四部份：Linux使用者管理
第五部份：Linux系统管理员
第六部份：其他备份文章
screenFetch - The Bash Screenshot Information Tool
-------------------------计算机概论-----------------------------
芯片组通常分为两个桥接器来控制各组件的通信
（1）北桥负责连接速度较快的CPU，内存与显卡等组件；
（2）南桥负责连接速度较慢的周边接口，包括硬盘，USB,网卡等

库函数调用系统调用　
系统调用调用内核函数

一般来说操作系统会提供开发接口，让开发商制作他们的驱动程序
驱动程序与开发商有关，与操作系统的开发者无关

BIOS(Basic Input Output System)是一套程序，这套程序是写死在主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录，那就是只读存储器
操作系统（系统调用和内核）

IDE硬盘		/dev/hd[a-d]
SCSI/SATA/U盘	/dev/sd[a-p]
U盘		/dev/sd[a-p]
软盘		/dev/fd[0-1]
打印机		ｕ盘/dev/usb/lp[0-15]
		25针/dev/lp[0-2]
鼠标		Ｕ盘/dev/usb/mouse[0-15]
		ps2:/dev/psaux
当前的鼠标	/dev/mouse

磁盘的第一个扇区主要记录了两个重要的信息
1.主要启动记录区MBR：可以安装启动管理程序的地方，有446Bytes
2.分区表:记录整个磁盘分区的状态，有64bytes(四组记录,四个分区,每组记录了该区段的起始和结束的柱面号)


分区的一些限制:
1.主分区和扩展分区共计4个
2.扩展分区最多只有一个
3.逻辑分区是扩展分区继续划分出来的
4.扩展分区无法格式化

分区注意点,如果扩展分区被破坏，那么所有的逻辑分区都会被删除，因为逻辑分区的分区表记录在扩展分区里面

启动流程到操作系统之前的动作:
BIOS:启动主动运行的程序，会识别第一个可启动的设备
MBR:第一个可启动设备的第一个扇区内的主要启动记录区块，内含启动管理程序
启动管理程序(Boot loader):一个可读取内核文件来运行的软件
内核文件(操作系统内核):开始操作系统的功能

Boot loader的任务:
提供菜单:使用者可以选择不同的启动项目
加载内核文件:直接指向可启动的程序段开始操作系统
转交其他loader:将启动管理功能转交

每个分区都有自己的启动扇区(boot sector)
实际可启动的内核文件都是放在各个分区内

shutdown [-t 秒] [-arkhncfF] 时间[警告信息]
-t sec: -t后面加秒数，过sec秒后关机
-k    :	发送警告消息，不关机
-r    :	在将系统的服务停掉后就重新启动
-h    : 在将系统的服务停掉后就立即关机
-n    : 不经过init程序，直接以shutdown的功能来关机
-f    : 关机并启动之后，强制略过fsck的磁盘检查
-F    : 系统重新启动后，强制进行fsck的磁盘检查
-c    : 取消已经在进行的shutdown命令内容
时间  : 一定要加的参数！指定系统关机时间

run level 0:关机
run level 3:纯文本模式
run level 5:含有图形接口模式
run level 6:重新启动

man手册中的操作
空格		向下翻一页
[page down]	向上翻一页
[page up]	向下翻一页
[home]		回退第一页
[end]		去最后一页
/string		向下查找
?string		向上查找
n,N		移动查找结果的光标

man [-fk] [n]
-f	:显示工具和工具的简单说明等价于whatis	
n	:显示哪一页的man手册
-k	:搜索有关key的手册

\[enter]使命令连续到下一行

---------------------------linux基本命令------------------------------
date 
cal
bc
[Ctrl]+c	中断
[Ctrl]+d	终止输入


linux文件权限与目录配置----------------------------------|
/etc/passwd 记录系统上的账户和账户信息
/etc/shadow 记录个人密码
/etc/group  记录用户组

chgrp	[-R]	dirname/filename...
-R		:递归修改

chown	修改文件所属者
chown owner:group filename

chmod	修改文件权限
rwx:(三个bit对应三个状态有无)
chmod [-R] 文件或目录
-R		:递归修改

chmod | u | + | r | file/dir
      | g | - | w |
      |	o | = | x |
      |	a |   |   |

权限对于文件的重要性
r	可读
w	可编辑，新增修改（但不含删除）
x	可执行

权限对于目录的重要性
r	可以查询当前目录下的文件名数据
w	可以修改目录结构的权限（建立新文件或目录，删除已经存在的目录或文件，重命名，移动）
x	代表用户是否让该目录成为自己的工作目录,同时决定了能够使用该目录下的程序

文件种类:
1.正规文件:属性[-]
	纯文本文件ascii
	二进制文件binary
	数据格式文件data 通过特定程序来读取

2.目录:属性[d]
3.连接（类似于快捷方式):属性[l]
4.设备文件:
	块设备[b]:成组的设备比如硬盘
	字符设备[c]:串行端口的借口设备，特点一次性读取，不能截断
5.数据接口文件sockets:属性[s]
6.管道文件pipe:属性[p] 特点FIFO

重要的目录
/lost+found	这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分区的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』
/proc	这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统内核、进程信息(process)、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。
/sys	这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。 包括目前已加载的内核静态库与内核侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！
/etc：配置文件
/bin：重要执行档
/dev：所需要的设备文件
/lib：执行档所需的函式库与内核所需的静态库
/sbin：重要的系统执行

/bin主要放置在开机时，以及进入单人维护模式后还能够被使用的指令，至于/usr/bin则是大部分软件提供的指令放置处。

. 当前目录
.. 上级目录
- 前一个目录
~ 当前用户的home目录
~account account的home目录


pwd [-P]
--------|-p 显示出确实的路径，而非使用链接路径(默认会显示链接路径)

mkdir [-mp] 目录名称
--------|-m 配置文件的权限，直接配置，不需要看默认权限umask的脸色
--------|-p 递归创建

rmdir [-p] 空目录名称
--------|-p 递归删除

会根据PATH的设置，来决定率先使用哪一个命令
使用绝对路径或相对路径直接指定某个命令的档名来运行，会比搜寻PATH来的正确

ls [-aAdfFhilnrRSt] 目录名称
ls [--color={never,auto,always}] 目录名称
ls [--full-time] 目录名称
--------|-a 全部的文件，连同隐藏文件
--------|-d 仅列出目录本身，而不列出目录内的数据文件
--------|-l 长数据列出，包含文件的属性和权限等
--------|常用

--------|-A 全部的文件，但不包括. 和..
--------|-f 直接列出结果，而不进行排序（默认以文档名排序)
--------|-F 根据文件、目录等，赋予附加的数据结构（如/代表目录)
--------|-h 将文件容量以人类较易读的方式列出来
--------|-i 列出inode号码
--------|-n 列出UID和GID而非使用者和用户组的名字
--------|-r 将排序结果反向输出
--------|-R 递归列出
--------|-S 以文件大小排序，而不是以文件名排序
--------|-t 根据时间排序
--color=never:不要依据文件特征给出颜色显示
--color=always:显示颜色
--color=auto:让系统自行依据配置判断是否显示颜色
--full-tile:显示完整时间（年月日时分)
--time={atime,ctime}:输出访问access时间或改变权限属性时间(ctime)而非内容变更的时间(modification time)

cp [-adfilprsu] source destination
cp [options] source1 source2 source3... directory
--------|-a 相当于-pdr
--------|-d 若来源属于链接，则赋值链接而非文件本身
--------|-f 强制，若目标文件已经存在且无法开启，则移动后再尝试一次
--------|-i 若目标文件已经存在，则询问是否覆盖
--------|-l 进行硬链接的链接创建，而非复制文件本身
--------|-p 连同文件属性一起赋值，而非使用默认属性(备份常用)
--------|-r 递归复制
--------|-S 赋值为符号链接
--------|-u 若des比src旧才升级des

rm [-fir] 文件或目录
--------|-f 强制，忽略不存在的文件，没有警告信息
--------|-i 删除前询问
--------|-r 递归删除

\command 将会忽略掉alias的指定选项

mv [fiu] src des
mv [options] src1 src2 src3 ... des
--------|-f 强制，若目标文件存在，不会问询直接覆盖
--------|-i 若des存在，则询问是否覆盖
--------|-u 若des已经存在，且src较新，则升级update des

basename 获取文件名
dirname 获取目录名

cat [-AbEnTv]
--------|-A 相当于-vET,可列出一些特殊字符
--------|-b 列出行号，仅针对非空行号
--------|-E 将结尾的换行字节$显示出来
--------|-n 连同空行一起显示行号
--------|-T 将[tab]以^|显示出来
--------|-v 显示出特殊字符


nl [-bnw] 文件
--------|-b 指定行号方式，-b a：表示不论空行同样显示行号，-b t:有空行忽略显示行号（默认)
--------|-n 列出行号的方式，-n ln:行号最左边显示,rn最右边显示且不用0占位，rz用0占位，最右边显示
--------|-w 行号栏位的占用的位数如让行号占4位 -w 4

more内的操作
space:向下翻页
Enter:向下翻一行
/key:向下查找key
:f :显示文档名和当前行数
q 退出
b 回翻


less内的操作
space：向下翻一页
[pagedown]：等同于space
[pageup]：向上翻一页
/key
?key
n :重复前一个搜索
N :反向重复前一个搜索
q 退出


head [-n number] 文件
--------|-n 后面接数字，代表显示几行的意思
	    number为负数时，表示后面number行都不显示，只显示前面的


tail [-n number] 文件
--------|-n 后面接数字，代表显示几行
--------|-f 表示持续侦测后面所接的文件，要等到按下[ctrl]+c才会结束侦测(当数据更新时实时显示)
基本等同于head，只是方向相反


ob [-t Type] 文件
--------|-t a:利用默认字符输出
	    c:利用ascii字符输出
	    d[size] 利用十进制来输出数据，每个输出数据占用size 字节（以size字节来读取原始文本)
	    f[size]
	    o[size]
	    x[size]
最左边第一栏是以8进制显示的字节数

------------------------------------------------------------
modification time(mtime):默认
当前文件的内容变更时，会变更这个时间，内容指的是文件的内容而不是文件的属性或者权限
status time(ctime):
当该文件的状态改变时，比如权限或者属性被更改时，才会修改这个时间
access time(atime):
当文件的内容被读取时（文件被访问时），这个时间才会被修改
-------------------------------------------------------------



touch [-acdmt] 文件
--------|-a 仅修改访问时间
--------|-c 仅修改文件时间，若文件不存在则不创建文件
--------|-d 后面可以接想要修改的日期而不用目前的日期，也可以用--date="时间或日期"
--------|-m 仅修改modifytime（文件内容修改时间)
--------|-t 后面接想要修改的时间，格式为[YYMMDDhhmm]

默认权限umask -S（以可读形式展现)
umask(以数字，需要减掉的权限显示)
默认文件没有x权限，目录有x权限
eg:umask 
结果为0022 (022) user group other
		 0    2     2 //在777减去022
		 7    7     7
		 7    5     5 //实际权限
		 rwx  r-x   r-x


文件的隐藏属性
chattr(只能在Ext2/Ext3的文件系统上生效)
chattr [+-=] [ASacdistu] 文件或目录名
--------|+ 添加一个特殊参数
--------|- 移除一个特殊参数
--------|= 赋予权限
==========
--------|A 当配置了A属性时，若有存取此文件（或目录）时，它的存取时间atime将不会被修改，可避免I/O较慢的机器过度的存取磁盘。这对速度较慢的计算机有帮助
--------|S 一般文件是非同步写入磁盘的，如果加上S这个属性时，当你进行任何文件的修改，该改动会同步写入到磁盘中（sync)
--------|a 这个文件只能添加数据，不能删除也不能修改数据，只有root才能配置该权限
--------|c 将会自动将此文件压缩，在读取的时候自动解压缩，但是在存储的时候，将会先进行压缩然后再存储（对于大文件来说有用)
--------|d 当dump程序被运行的时候，配置d将可以使得该文件（目录）不会被dump备份
--------|i 让一个文件不能被删除、改名、配置连接也无法写入或新增数据!只有root可以配置，对系统安全性有强大的帮助
--------|s 如果这个文件被删除，它将会被完全的移除这个硬盘中，所以误删没有办法救回来
--------|u 与s相反，删除后，文件还留在硬盘中

lsattr(显示文件隐藏属性)
lsattr [-adR] 文件或目录
--------|-a 将隐藏文件的属性也显示
--------|-d 仅写出目录本身的属性
--------|-R 递归显示


Set UID
当s这个标志出现在文件拥有者x的权限上时，如/usr/bin/passwd 
[-rwsr-xr-x] 此时就称之为set UID，简称SUID的特殊权限
1.SUID权限仅对二进制程序有效
2.运行者对于该程序需要具有x的可执行程序
3.本权限仅在运行该程序的过程中有效（run-time)
4.运行者将具有该程序拥有者的权限

Set GID
s出现在文件用户组x的权限上
与SUID不同的是，SGID可以针对文件或目录配置
如果是文件:
1.SGID对二进制程序有效
2.程序运行者需要具有x权限
3.运行者在运行时会获得该程序用户组的权限支持
如果是目录:
1.使用者若对该目录具有r和x的权限时，使用者能够进入该目录
2.使用者在此目录下的有效用户组将会变成该目录的用户组
3.用途：若使用者在此目录下具有w权限（可以新建文件），则使用者所创建的新文件，该文件的用户组和此目录的用户组相同权限

Sticky Bit(sticky黏)
SBIT仅针对目录有效
1.当使用者对于该目录有wx权限
2.当使用者在该目录下创建文件或目录，仅有自己和root才有权限删除该文件
如/tmp [drwxrwxrwt]

4为SUDI
2为SGID
1为SBIT
ugb
例如:chmod 4755 test
当本身不具有x的权限时，赋予了UGB的话（实际上是具有空的权限)，其次s和t变成大写的ST

file(查看文件类型)


which(寻找可执行文件)
which [-a] command
--------|-a 显示所有PATH目录中可以找到的命令，而不只是第一个

whereis(寻找文件)(与find搜索磁盘不同，whereis是利用数据库搜索)
whereis [-bmsu] 文件或目录
--------|-b 只查找二进制文件
--------|-m 只找在说明文件manual路径下的文件
--------|-s 只找source来源文件
--------|-u 搜索不在上诉三个项目当中的其他特殊文件

whereis和locate是根据linux系统内记载了所有文件记录的一个数据库文件

locate [ir] keyword
--------|-i 忽略大小写
--------|-r 后面可以接正则表达式的显示方法

手动更新数据库updatedb

find [PATH] [option] [action] -a -o -a连接两个选项 -o或
1.与时间有关的选项-atime -ctime -mtime
	如:
	-mtime n: 在n天之前的一天之内被更改过内容的文件
	-mtime +n: 列出在n天之前（不含n）被更改过内容的文件
	-mtime -n: 列出在n天之内（含n)被更改过内容的文件 
	-newer file: file为一个存在的文件，列出比file还要新的文件
2.与使用者或用户组有关的参数
	-uid n: n为数字，即UID，
	-gid n: n为数字，即GID
	-user name: name为使用者的账户名称
	-group name: 用户组名
	-nouser: 寻找文件的拥有者不存在/etc/passwd 的人
	-nogroup: 寻找文件的用户组不在/etc/group的文件
3.与文件权限及名称有关的参数
	-name filename: 寻找文件名叫filename的文件
	-size [+-] SIZE: 寻找比SIZE还要大(+)或小(-)的文件
			c byte k 1024 bytes 
			eg：[-size +50k] 比50KB还要大的文件
	-type TYPE:一般正规文件f, 设备文件b,c 目录d 链接l 管道s FIFO p等属性	
	-perm mode: 寻找文件刚好等于mode的文件，如-rwsr-xr-x 4755
	-perm -mode: 寻找文件必须要全部包含mode权限的文件(以mode为基准增加0或多个属性)
	-perm +mode: 寻找文件包含任意mode权限的文件(2005后不在支持用--perm /mode替换)
4.额外的动作
	-exec command : command为其他命令 -exec 后面可以接command来处理结果
	-print : 默认动作，打印到屏幕

eg:
[root@www ~]# find / -perm /7000 -exec ls -l {} \;
# 注意到，那个 -exec 后面的 ls -l 就是额外的命令，命令不支持命令别名，
# 所以仅能使用 ls -l 不可以使用 ll 喔！注意注意！
解读:
{} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；
-exec 一直到 \; 是关键字，代表 find 额外动作的开始 (-exec) 到结束 (\;) ，在这中间的就是 find 命令内的额外动作。 在本例中就是『 ls -l {} 』罗！
因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。


权限和命令间的关系
一：让使用者能够进入某个目录成为工作目录的基本权限	
可使用的命令：cd
目录所需权限：x
额外要求：如ls，则需要有r权限
二：使用者在某个目录内读取一个文件的基本权限
可使用的命令:cat,more,less等等
目录所需权限：x
文件所需权限：r
三：让使用者可以修改一个文件的基本权限
可使用的命令：nano或vi或vim
目录所需权限：x
文件所需权限：rw
四：让使用者可以创建一个文件的基本权限
目录所需权限：wx
五：让使用者进入某个目录并且运行该目录下的基本权限
目录所需权限：x
文件所需权限：x

========================================文件系统===============================================================
superblock:记录此文件系统的整体信息，包括inode/block的总量，使用量，剩余量，以及文件系统的格式和相关信息
inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码
block:实际记录文件的内容，若文件太大时，会占用多个block

磁盘碎片整理：因为文件写入的block太过于离散，此时文件读取的效能将会变得很差，这个时候通过碎片整理将同一个文件所属的blocks汇整在一起，加快读取速度

=======================================Ext2文件系统===========================================================
=======================================================================
data block(数据区块)
Ext2文件系统的限制如下
-----------------------------------------------------
|Block 大小	1KB	2KB	4KB		    |
|最大单一文件限制	16GB	256GB	2TB         |
|最大文件系统总容量	2TB	8TB	16TB	    |
-----------------------------------------------------
1.原则上，block的大小与数量在格式化完就不能够再改变了（除非重新格式化）
2.每个block内最多只能放置一个文件的数据
3.承上，如果文件大于block的大小，则一个文件会占用多个block数量
4.承上，如果文件小于block，则该block的剩余容量就不能再被使用了（磁盘空间会被浪费)
=======================================================================
=======================================================================
inode table(inode 表)
inode记录的文件数据至少包含:
1.该文件的存取模式rwx
2.该文件的拥有者和用户组owner/group
3.该文件的容量
4.该文件的创建或状态更改的时间ctime
5.最近一次的读取时间atime
6.最近一次的修改时间mtime
7.特殊文件的标志如setUID
8.文件真正内容的指向(block)

每个inode大小为128bytes(ext2系统)
每个文件只会占用一个inode
文件系统所能创建的文件数量和inode的数量有关
系统读取文件的时候需要先找到inode,并分析inode所记录的权限与用户是否符合，若符合才开始读取block的内容
=======================================================================
=======================================================================
Superblock(超级区块)
1.block和inode的总量
2.未使用和已使用的inode/block数量
3.block和inode的大小(block为1,2,4k，inode为128bytes)
4.文件系统的挂载时间，最近一次写入数据的时间，最近一次检验磁盘（fsck）的时候等文件系统的相关信息
5.一个valib bit数值，若文件系统已被挂载则为0，否则为1

利用dumpe2fs命令查看superblock
可能每个block group都含有superblock，但是一个文件系统应该仅有一个superblock而已，因为，其他的block group若含有的话，主要是为了第一个block group内的superblock的备份
=======================================================================
=======================================================================
Filesystem Description(文件系统描述说明)
描述每个block group的开始和结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block)分别介于哪一个block号码之间，同样利用dump2fs查看
=======================================================================
=======================================================================
block bitmap(区块对照表)
利用位图算法来判断哪一个block可以用
inode bitmap(inode对照表)
利用位图算法来判断哪一个inode可以用
=======================================================================
=======================================================================
dumpe2fs[-bh] 设备文件名
--------|-b 列出保留为坏轨的部分（一般用不到）
--------|-h 仅列出superblock的数据

=======================================================================





新增一个文件时，文件系统的行为：
现根据用户对于新增文件的目录是否有wx权限，若有才能新增
根据inode bitmap查找没有使用的inode号码，并且根据umask将新文件的权限/属性写入
根据block bitmap查找没有使用的block号码，将实际的数据写入，并且更新inode里block指向数据
将刚写入的block和inode写入inode bitmap和block bitmap，并更新superblock的内容

superblock,inode bitmap, block bitmap 中间数据metadata
=======================================================================
在上古时期，没有日志，若发生数据不一致，需要检查中间数据（即superblock inodebitmap和blockbitmap）和实际数据的一致性，所以文件系统越大，时间越长
=======================================================================
日志式文件系统
1.预备：当系统要写入一个文件的时候，先在日志记录区块中记录某个文件准备要写入的信息
2.实际写入：开始写入文件的权限和数据,开始更新metadata的数据（509-513行的行为)
3.结束：完成数据和metadata更新后，在日志记录区块中完成该文件的记录
=======================================================================
系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读写
可以手动使用sync来强迫内存中配置为dirty的文件（文件内容被修改）写入到硬盘里
若正常关机时，关机命令会主动执行sync来将内存的数据写入到硬盘中
若不正常关机，由于数据尚未写会到硬盘中，因此重启后可能会花很多时间进行磁盘检查，甚至可能导致文件系统的损坏
=======================================================================


df [-ahikHTm] [目录或文件名]
--------|-a 列出所有的文件系统，包括系统特有的/proc等文件系统
--------|-h 以人类较易读的方式gb，kb，mb
--------|-i 不使用硬盘容量，而以inode的数量来显示
--------|-k 以kB来显示各个文件系统
--------|-H 以M=1000K取代M=1024K
--------|-T 连同该分区的文件系统名称也列出来
--------|-m 以MB来显示各个文件系统

/dev/shm是利用内存虚拟出来的硬盘空间
1.访问速度快
2.关机后消失

du [-ahskm] 文件或目录名称
--------|-a 列出所有的文件和目录的容量，因为默认统计目录底下的目录量而已
--------|-h 以人类较易读的方式
--------|-s 列出总量，而不列出各个目录所占用的容量
--------|-S 不包括子目录下的统计
--------|-k 以kB
--------|-m 以mB

hard link的限制:
不能跨越文件系统
不能link目录

ln [-sf] 来源文件 目的文件
--------|-s 软连接，默认硬链接
--------|-f 如果目标文件存在，则主动将目标文件删除后在创建

fdisk [-l] 设备名称 <==制作分区
--------|-l 输出后面接的设备所有的分区内容，若仅有fdisk -l时，则系统将会把整个系统内能够搜索到的设备的分区均列出来
fdisk的限制：没有办法处理2TB以上的硬盘分区表

mkfs [-t 文件系统格式] 设备名称
--------|-t 如ext3, ext2, vfat等

mke2fs [-b block大小] [-i block大小] [-L 标头] [-cj] 设备
--------|-b 可以设置每个block的大小，1024,2048,4096bytes
--------|-i 多少容量给予一个inode
--------|-c 检查硬盘错误，仅使用一次-c时，会进行快速读取测试，如果-c -c 则会测试读写，较慢
--------|-L 标头名称，
--------|-j 加上journal

磁盘检查fsck,badblocks

fsck [-t 文件系统] [-ACay] 设备名称 （检验文件系统是否出错，数据将会放在lost+found）
--------|-t 如同mkfs根据-t选项调用不同的文件系统程序
--------|-A 根据/etc/fstab的内容，将设备进行扫描，通常启动过程中会运行这一命令
--------|-a 自动修复检查到的有问题的扇区
--------|-y 与-a类型，但是某些文件系统仅支持-y
--------|-C 显示检测进度
EXT2/EXT3的额外选项功能(e2fsck所提供)
--------|-f 强制检查！一般来说，如果fsck没有发现任何unclean的标志，不会主动进入细部检查
--------|-D 针对文件系统下的目录进行优化配置


badblocks [-svw] 设备名称	（用于检查硬盘或软盘扇区有没有坏轨）
--------|-s 在屏幕上列出进度
--------|-v 可以在屏幕上看到进度
--------|-w 使用写入的方式来测试，不建议使用，尤其是待检查的设备已有文件时


mount [-a] [-l] [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 设备文件名 挂载点
--------|-a 依照配置文件/etc/fstab的数据将所有未挂载的硬盘都挂载上来
--------|-l 单纯的输入mount会显示目前挂载的信息，加上-l可以显示label名称
--------|-t 与mkfs的选项非常类似，可以加上文件系统种类来指定想要挂载的类型
--------|-n 在默认的情况下，系统会将实际挂载的情况实时写入/etc/mtab中,以利其他程序的运行，但是在某些情况下（如单人维护模式）为了避免问题，会可以不写入，此时就需要用-n
--------|-L 系统除了利用设备文件名之外，还可以利用文件系统的标头名称Label来挂载，最好为文件系统取一个独一无二的名称
--------|-o 后面可以接一些挂载时额外的参数，比如账号，密码，读写权限等
	    ro,rw: 挂载文件系统成为只读，或可读写
	    async,sync: 此文件系统是否使用同步写入sync或一部async的内存机制，请参考文件系统运行方式，默认为async
	    auto,noauto: 是否允许此分区被mount -a自动挂载
	    dev,nodev: 是否允许此分区上，可以创建设置文件
	    suid,nosuid: 是否允许此分区上拥有suid/sgid的文件格式
	    exec,noexec: 是否允许此分区上拥有可执行程序
	    user,nouser: 是否允许此分区让任何使用者运行mount，一般来说mount只有root可以运行，但有user参数时，则一般用户也可以进行mount对于此分区
	    defaults: rw,suid,dev,exec,auto,nouser,and async
	    remount: 重新挂载，在系统错误，或重新升级时使用
	    -o的参数以,间隔

umount [-fn] 设备或挂载点
--------|-f 强制卸载，可以用在类似于网络文件系统NFS无法读取的情况下 
--------|-n 不更新/etc/mtab下卸载

主要设备代码（major） 次要设备代码（minor)
eg: ll /dev/sda*
磁盘文件名	Major	Minor
/dev/hda	3	0~63
/dev/hdb	3	64~127
/dev/sda	8	0-15
/dev/sdb	8	16-31

当需要创建设备文件时
mknod 设备文件名 [bcp] [Major] [Minor]
--------|b 配置设备名称成为一个周边存储设备，如硬盘
--------|c 配置设备名称成为一个周边输入设备，如鼠标/键盘
--------|p 配置设备名称成为一个FIFO文件(管道文件)
Major: 主要设备代码
Minor: 次要设备代码

e2label 修改文件系统label(文件系统的label类似于win上面的C: d: E:)
e2label 设备名称 新的label名称

tune2fs [-jlL] 设备名称
--------|-j 将ext2转换为ext3文件系统
--------|-l 类似dumpe2fs -h将superblock内的数据读取出来
--------|-L 类似e2label修改设备的label

硬盘为IDE接口时使用hdparm,如果是SATA接口这个命令没有多大用途
hdparm [-icdmXTt] 设备名
--------|-i 将内核检测到的硬盘参数显示出来
--------|-c 配置32位存储模式，这个32位存储模式指的是在硬盘与PCI接口之间传输的模式，而硬盘本身依旧以16位跑的，默认情况下，这个配置值都会被使用
--------|-d 配置是否激活dma模式，-d1为启动，-d0为取消
--------|-m 配置同步读取多个扇区的模式，一般来说，配置此模式，可降低系统因为读取硬盘而损耗的性能，不过wd的硬盘则不建议配置，一般来说，配置为16/32为优化，不过wd硬盘默认是4/8,这个值的最大值可以用hdparm -i /dev/hda 输出的MaxMultSect来配置
--------|-x 配置UtraDMA模式，一般来说，UDMA的模式值加64即为配置值。并且，硬盘和主板芯片必须同步，所以，取最小的那个，一般来说
	33 MHz DMA mode 0~2(x64~x66)
        66 MHz DMA mode 3~4 (X67~X68)
        100MHz DMA mode 5   (X69)
        如果您的硬盘上面显示的是 UATA 100 以上的，那么配置 X69 也不错！
--------|-T 测试缓冲区cache的存取性能
--------|-t 测试硬盘的实际存取性能


/etc/fstab 是启动时的配置文件，不过，实际文件系统的挂载是记录到/etc/mtab与/proc/mounts这两个文件当中的

partprobe 更新分区表

制作swap分区 使用硬盘充当内存，暂时空出内存给更需要内存的程序使用
mkswap 设备名
free 查看系统中内存情况
swapon 使用交换分区

du查看某个目录所使用的容量

parted 分割2TB以上的分割槽
parted [设备] [命令 [参数]]
-------- 选项与参数：
	 命令功能:
	 新增分割: mkpart [primary][logical][extended] [ext3|vfat] 开始 结束
	 删除分割: rm [partition]
	 打印分割表: print


常见的压缩文件扩展名
*.Z		compress 程序压缩的文件
*.gz		gzip 程序压缩的文件
*.bz2		bzip2 程序压缩的文件
*.tar		tar 程序打包的数据，并没有进行压缩
*.tar.gz 	tar 程序打包的文件，其中并且经过gzip的压缩
*.tar.bz2	tar 程序打包的文件，其中并且经过bzip2的压缩

======================================压缩命令=========================
compress [-rcv] 文件或目录 (不再使用，而常用gzip，默认情况下压缩后源文件不见，压缩文件命名为basename.Z)
--------|-r 连同目录下的文件一同压缩
--------|-c 将压缩数据输出成为标准输出
--------|-v 可以展示出压缩后的文件信息以及压缩过程中一些文件名的变化
解压uncompress

------------------------
gzip [-cdtv#] 文件名 (压缩为*.gz)
--------|-c 默认情况将压缩的数据标准输出，可以通过重定向来处理到输出一个文件
--------|-d 解压缩的参数
--------|-t 可以用来检验一个压缩档的一致性，看文件有无错误
--------|-v 可以显示出源文件/压缩文件的压缩比等信息
--------|-# 压缩等级，-1最快但压缩比差，-9最慢但是压缩比好，默认-6

zcat 将解压的数据标准输出

bzip2 [-cdkzv#] 文件名
bzcat 文件名.bz2
--------|-c 将压缩的数据标准输出
--------|-d 解压缩
--------|-k 保留原始文件，而不会删除原始文件
--------|-z 压缩的参数
--------|-v 可以显示出压缩比等信息
--------|-# 同gzip，-9最佳

tar [-j|-z] [cv] [-f 创建的档名] filename <==打包与压缩
tar [-j|-z] [tv] [-f 创建的档名] <==查看档名
tar [-j|-z] [xv] [-f 创建的档名] [-C 目录] 解压缩
--------|-c 创建打包文件，可以搭配-v来观察过程中打包的档名filename
--------|-t 观察打包文件的内容含有哪些档名
--------|-x 解打包或解压缩的功能，可以搭配-C（大写）在特定目录解开
	    注意！！！-c,-t,-x不可同时出现
--------|-j 通过bzip2压缩或者解压缩,*.tar.bz2
--------|-z 通过gzip压缩或者解压缩，*.tar.gz
--------|-v 将正在处理的文件显示出来
--------|-f filename : -f后面要接要被处理的档名
--------|-C 目录: 在特定目录下解压

--------|-p 保留备份数据的原本权限和属性，常用于备份(-c)重要的配置文件
--------|-P 保留绝对路径,即运行备份数据中含有根目录存在
--------|--exclude=FILE 在压缩的过程中，不要将FILE打包

压缩:tar -jcv -f filename.tar.bz2 要被压缩的文件或目录
查询:tar -jtv -f filename.tar.bz2
解压缩:tar -jxv -f filename.tar.bz2 -C 想要解压到的文件目录
filename.tar.bz2为自己取的文件名
tar并不会主动产生文件

解压缩单独某个文件
tar -jxv -f filename.tar.bz2 等待解压缩的指定文件名

dump [-Suvj] [-level] [-f 备份档] 待备份数据
dump -W
--------|-S 仅列出后面的数据需要多少空间才能备份完
--------|-u 将这次dump的时间记录到/etc/dumpdates文件中(现在为/var/lib/dumpdates)
--------|-v 将dump的文件过程显示出来
--------|-j 加入bzip2的支持，默认压缩等级为2
--------|-level -0~-9十个等级
--------|-f 类似于tar，后面接产生的文件，也可以接设备名
--------|-W 列出/etc/fstab里面的具有dump配置的分区是否有备份过

当用dump备份目录时，-u level1~9不适用
使用restore恢复dump的备份

restore -t [-f dumpfile] [-h] 查看dump文件
restore -C [-f dumpfile] [-D 挂载点] 比较dump与实际文件
restore -i [-f dumpfile] 进入互动模式
restor -r [-f dumpfile] 还原整个文件系统
如同tar中-cx不能混用
--------|-t 此模式用在观察dump起来的备份文件中含有什么重要数据如同tar -t
--------|-C 列出dump文件内有记录的，且与目前文件系统不同的文件
--------|-i 可以仅还原部分文件，用在dump备份目录时
--------|-r 用在针对文件系统时全部还原
--------|-h 查看备份数据中inode和文件系统label等信息
--------|-f 后面接要处理的dump文件
--------|-D 与-C搭配使用，查看后面接的挂载点与dump内的不同文件

mkisofs [-o 镜像文件] [-rv] [-m file] 待备份文件.. [-V vol] \
> -graft-point isodir=systemdir ... <==制作镜像文件
--------|-o 后面接要产生的镜像文件名
--------|-r 通过Rock Ridge阐述支持Unix/linux的文件数据，可以记录较多的咨询
--------|-v 显示过程
--------|-m file 排除该文件类似exclude
--------|-V vol 创建Volume，类似win上文件管理里面看到的CD title
--------|-graft-point 将systemdir备份到isodir中

cdrecord -scanbus dev=ATA <==查询刻录机的位置
cdrecord -v dev=ATA:x,y,z blank=[fast|all] 抹除重复读写片
cdrecord -v dev=ATA:x,y,z -format 格式化DVD+RW
cdrecord -v dev=ATA:x,y,z [可用选项功能] file.iso
--------|-scanbus 扫描可用的刻录机，后续的装置为ATA界面
--------|-v 显示过程
--------|dev=ATA:x,y,z 后续的xyz为系统刻录机所在的位置
--------|blank=[fast|all] blank为抹除可重复读写的CD/DVD-RW,使用fast较快，all较完整
--------|-format 仅针对DVD+RW这个格式的DVD
-----------------------写入cd/dcd时使用
--------|-data 指定后面的文件以数据格式写入，而不是以CD音轨的方式写入
--------|speed=x 制定刻录速度
--------|-eject 指定刻录后自动退出光盘
--------|fs=Ym 指定多少缓冲内存
-----------------------写入dvd的选项
--------|driveropts=burnfree 打开buffer underrun free模式写入
--------|-sao 支持DVD-RW格式

dd if="input file" of="output file" bs="block size" count="number blocks"
将inputfile输出到outputfile，bs规定block的大小，count规定block的个数
if或of可以为设备名，复制的时候会将整个设备所有数据都复制，意味着包括文件系统,包括MBR与分区表，包括superblock，boot sector，meda data

cpio -ovcB > [file|device] <==备份
cpio -ivcdu < [file|device] <==还原
cpio -ivct < [filedevice] <==查看
--------|-o 将数据copy输出到文件或装置
--------|-B 让blosks可以添加至5120bytes

--------|-i 将数据自文件或设备copy出来到系统当中
--------|-d 自动创建目录
--------|-u 以较新文件覆盖旧文件
--------|-t 配合-i,观察

--------|-v 显示过程
--------|-c 新的便携式格式存储

vimtutor命令具有vim的操作说明
============================vim编辑器=================================
1.一般模式（进入后的默认模式)
2.指令模式:/?进入
3.编辑模式

----------------------------移动光标的方法-----------------------------
|h        光标向左移动一个字符					      |
|j  	  光标向下移动一个字符					      |
|k        光标向上移动一个字符					      |
|l 	  光标向右移动一个字符					      |
|n+[hjkl] 移动n个字符在对应方向					      |
|ctrl+f   向下移动一页Page down					      |
|ctrl+b	  向上移动一页Page Up					      |
|ctrl+d   向下移动半页						      |
|ctrl+u   向上移动半页						      |
|+	  光标移动到非空格符的下一行				      |
|-	  光标移动到非空格符的上一行				      |
|n<space> 光标向右移动n个字符					      |
|0或Home  移动到这一行的最前面字符处				      |
|$或End	  移动到这一行的最后面字符处				      |
|H        移动到这个屏幕的最上方那一行的第一个字符		      |
|M	  移动到这个屏幕的中央那一行的第一个字符		      |
|L	  移动到这个屏幕的最下方那一行的第一个字符	 	      |
|G	  移动到这个文件的最后一行				      |
|nG	  移动到第n行						      |
|gg	  移动到第一行						      |
|n<enter> 向下移动n行						      |
-----------------------------------------------------------------------
----------------------------搜索与替换---------------------------------
|/key	  向下寻找key字符串					      |
|?key	  向上寻找key字符串					      |
|n	  重复前一个搜索动作					      |
|N	  反向重复前一个搜索动作				      |
|:n1,n2s/word1/word2/g 	n1到n2行之间将word1替换成word2		      |
|			不完全匹配，即string若搜索/str会标记string    |
|:1,$s/word1/word2/g	第一行到最后一行将word1替换成word2	      |
|:1,$s/word1/word2/gc	给出提示是否要替换从第一行到最后一行的word1   |
-----------------------------------------------------------------------
---------------------------删除，复制与粘贴----------------------------
|x,X	  x删除光标的那个字符，X删除光标前的一个字符		      |
|nx       从光标起删除n个字符					      |
|dd	  删除光标所在这一行					      |
|ndd      删除光标开始的n行					      |
|d1G      删除光标所在到第一行的所有数据			      |
|dG       删除光标所在到最后一行的所有数据			      |
|d0       删除光标所在到该行的最前面那个字符			      |
|d$	  删除光标所在到该行的最后那个字符			      |
|yy       复制光标这一行					      |
|nyy      复制光标开始的n行					      |
|y1G      复制光标所在到第一行的所有数据			      |
|yG       复制光标所在到最后一行的所有数据			      |
|y0       复制光标所在到该行的最前面那个字符                          |
|y$       复制光标所在到该行的最后那个字符			      |
|p,P      p粘贴到光标后面，P则为光标前面			      |
|J        将光标所在行和下一行合并为一行                              |
|c        重复删除多个数据,cn[hjkl]				      |
|u	  撤销上一个动作					      |
|ctrl+r   恢复上一个动作					      |
|.        重复上一个动作                                              |
-----------------------------------------------------------------------
!!!!!!!! x d删除| y复制| p粘贴| u撤销| ctrl+r恢复| .重复|可以接0$nG
--------------------------进入插入或替换的编辑模式---------------------
|i,I	  i在光标所在位置插入，I在光标所在行首插入		      |
|a,A      a在光标后一个字符插入，A在光标所在行尾插入                  |
|o,O      o在光标所在行的下方另起一行，O则相反			      |
|r,R      r替换光标所在的那个字符，R从光标开始处一直替换到输出了ESC   |
-----------------------------------------------------------------------
--------------------------指令的存储和离开等---------------------------
|:w	  保存							      |
|:w!      强制写入，不过到底能不能取决于文件权限                      |
|:q       退出                                                        |
|:q!	  曾修改过文件但是不保留强制退出                              |
|:wq      储存后离开                                                  |
|ZZ       储存后离开						      |
|:w [filename] 另存为						      |
|:r [filename] 读取文件到光标所在行的后面			      |
|:n1,n2 w [filename] n1到n2行的内容另存为			      |
|:!command 暂时离开vim，执行command命令                               |
-----------------------------------------------------------------------
-------------------------区块选择的按键意义----------------------------
|v	  字符选择	 					      |
|V        行选择						      |
|ctrl+v   区块选择	 					      |
|y	  复制							      |
|d	  删除							      |
-----------------------------------------------------------------------
-------------------------多文件编辑的按键------------------------------
|:n       编辑下一个文件				              |
|:N	  编辑上一个文件					      |
|:files	  列出vim所开启的全部档案 	  			      |
-----------------------------------------------------------------------
-------------------------多窗口情况下的按键功能------------------------
|:vs [filename] 横向分屏					      |
|:sp [filename]	开启一个新窗口，若不加filename则同步显示(纵向分屏)    |
|ctrl+w+j	移动到下面的窗口				      |
|ctrl+w+k	移动到上面的窗口				      |
|ctrl+w+q	:q						      |
-----------------------------------------------------------------------

=========================vim 的环境设定参数============================
:set nu
:set nonu	就是设定与取消行号啊！
:set hlsearch
:set nohlsearch	hlsearch 就是 high light search(高亮度搜寻)。 这个就是设定是否将搜寻的字符串反白的设定值。默认值是 hlsearch
:set autoindent
:set noautoindent	是否自动缩排？autoindent 就是自动缩排。
:set backup	是否自动储存备份档？一般是 nobackup 的， 如果设定 backup 的话，那么当你更动任何一个档案时，则源文件会被另存成一个档名为 filename~ 的档案。 举例来说，我们编辑 hosts ，设定 :set backup ，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的档案，记录原始的 hosts 档案内容
:set ruler	还记得我们提到的右下角的一些状态栏说明吗？ 这个 ruler 就是在显示或不显示该设定值的啦！
:set showmode	这个则是，是否要显示 --INSERT-- 之类的字眼在左下角的状态栏。
:set backspace=(012)	一般来说， 如果我们按下 i 进入编辑模式后，可以利用退格键 (backspace) 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以透过 backspace 来设定啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！
:set all	显示目前所有的环境参数设定值。
:set	显示与系统默认值不同的设定参数， 一般来说就是你有自行变动过的设定参数啦！
:syntax on
:syntax off	是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本档时，如果开头是以 # 开始，那么该行就会变成蓝色。 如果你懂得写程序，那么这个 :syntax on 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本档案，要避免颜色对你的屏幕产生的干扰，则可以取消这个设定 。
:set bg=dark
:set bg=light	可用以显示不同的颜色色调，预设是『 light 』。如果你常常发现批注的字体深蓝色实在很不容易看， 那么这里可以设定为 dark 喔！试看看，会有不同的样式呢！
======================================================================
文件换行符的区别
dos2unix [-kn] file [newfile] <==dos转unix
unix2dos [-kn] file [newfile] <==unix转dos
--------|-k 保留该文件原来的mtime时间格式（不更新文件上次内容更改的时间)
--------|-n 保留原始文件的旧档，将转换后的内容输出到新文件eg:dos2unix -n old new


iconv --list
iconv -f 原本编码 -t 新编码 filename [-o newfile]
--------|--list 列出iconv所支持的语系编码
--------|-f from,来源，后面接原本的编码格式
--------|-t to,新的编码格式
--------|-o file, 保留源文件，-o输出到新文件

======================================================================

===============================bash====================================
/etc/shells 记录了有几个可以用的shells
登录后会根据/etc/passwd文件的配置给我们一个默认的shell

alias 命令别名
eg:alias rm='rm -i'

=======================================
type [-tpa] name
--------| 显示name是内建命令还是外部命令
--------|-t file为外部命令，alias为别名，builtin为内建命令
--------|-p 为外部命令时，显示完整文件名
--------|-a 由PATH定义的路径下，将所有name的命令都列出来包括alias


变量作为左值直接使用
变量作为右值$var 或者${var}

变量名称只能是英文或者数字，不能以数字开头
''内特殊字符仅为一般的字符（纯文本）
""内特殊字符如$，可以保有原来的特性

\转义字符

$(command)或者`comman`率先执行命令

在为变量扩增内容时，注意使用"$变量"或者${变量}，因为直接使用会和后面的内容产生歧义，认为一同是变量名

export 使得变量成为环境变量
export后面不加变量名，会显示所有的环境变量
一般情况下，父进程自定义的变量无法给子进程使用，但是可以使用export
子进程仅会继承父进程的环境变量，而不会继承父进程的自定义变量

unset 取消变量

env 查看环境变量

常见的环境变量
HOME  		用户家目录
SHELL 		说明所使用的SHELL是哪一个程序
HISTSIZE	记录历史命令的个数
MAIL		使用mail命令收信时，会使用该MAIL变量来获取邮件信箱
PATH		运行文件搜索的路径，目录与目录直接以:间隔
LANG		语系数据
RANDOM 		随机数变量,可以获取0-32767之间
$ 		目前这个shell所使用的PID
?		命令的返回值
PS1		命令提示符
OSTYPE,HOSTTYPE,MACHTYPE:(主机硬件与核心等级)
-		set的配置

关于PS1的配置
\d		显示出星期 月 日 eg:"Mon Feb 2"
\H		完整的主机名
\h		主机名在第一个小数点之前的名字
\t		24小时[HH:MM:SS]
\T		12小时[HH:MM:SS]
\A		24小时[HH:MM]
\@		12小时[am/pm]
\u		使用者用户名
\v		BASH的版本信息
\w		完整的工作目录名，以根目录写起
\W		利用basename获取工作目录，所以只会列出最后一个目录名
\#		下达的第几个命令
\$		提示字符：root为#，否则为$



使用set查看所有变量（包含自定义变量)

locale -a 显示linux所支持的语系
locale 通过显示的结果可以确定修改哪一个变量
LANG=en_US                   <==主语言的环境
LC_CTYPE="en_US"             <==字符(文字)辨识的编码
LC_NUMERIC="en_US"           <==数字系统的显示信息
LC_TIME="en_US"              <==时间系统的显示数据
LC_COLLATE="en_US"           <==字符串的比较与排序等
LC_MONETARY="en_US"          <==币值格式的显示等
LC_MESSAGES="en_US"          <==信息显示的内容，如菜单、错误信息等
LC_ALL=                      <==整体语系的环境


语系文件放置在/usr/lib/locale/下

read [-pt] var   <==结果放在var这个变量
--------|-p 后面接提示符
--------|-t 等待的秒数

declare [-aixr] var
--------|-a 定义变量为数组
--------|-i 定义变量为整形
--------|-x 与export类似，将变量变成环境变量
--------|-r 设置为readonly，该变量不可被修改也不可以被unset
--------|+[aix] 取消对应变量的类型定义
--------|-p 打印变量的类型
变量的类型默认为字符串，bash的数值运算只能是int

数组元素作为左值var[index]
数组元素作为右值${var[index]}

ulimit [-SHacdfltu] [配额]  <==linux的一些限制
--------|-S soft limit,警告的配置，能超过这个值但是会有警告
--------|-H hard limit,不能超过这个配置
--------|-a 显示所有限制额度
--------|-c 限制core文件的大小
--------|-f 创建的文件最大容量，单位为KB
--------|-d 段错误容量
--------|-l 锁定lock的内存量
--------|-t 最大的cpu时间单位秒
--------|-u 单一用户最大进程数

变量的配置方法		说明
${变量#key}		若变量从头开始符合key，则删除最短的符合数据
${变量##key}		若变量从头开始符合key，则删除最长的符合数据
${变量%key}		若变量从尾向前符合key，则删除最短的符合数据
${变量%%key}		若变量从尾向前符合key，则删除最长的符合数据
${变量/old/new}		若变量内容符合old，则将第一个old替换成new
${变量//old/new}	若变量内容符合old，则将全部old替换成new

变量设置方式		str没有设置	str为空字符串	str已设置且不为空字符串
var=${str-expr}		var=expr	var=		var=$str
var=${str:-expr}	var=expr	var=expr	var=$str
var=${str+exprt}	var=		var=expr	var=expr
var=${str:+expr}	var=		var=		var=expr
var=${str=expr}		str=expr	str不变		str不变
			var=expr	var=		var=$str
var=${str:=expr}	str=expr	str=expr	str不变
			var=expr	var=expr	var=$str
var=${str?expr}		expr输出至stderr var=		var=$str
var=${str:?expr}	expr输出至stderr expr输出至stderr var=$str

${}上述都会导致var的变量变化除?

-的作用str没有设置var则为expr
=的作用str没有设置则str也为expr
+的作用是说str设置了则var=expr(与-相反)
?的作用与标准输出有关

:的作用是将str为空串视为没有设置

alias,unalias设置命令别名、取消命令别名

history [n]
history [-c]
history [-raw] file
--------|n 显示最近的n个命令
--------|-c 将目前shell中所有history内容都清空
--------|-a 将新增的history命令写入到file中，默认写入~/.bash_history
--------|-r 将file的内容读到shell的history记忆中
--------|-w 将history的内容写入到file中,默认~/.bash_history

!number
!command
!!
-------|number 运行第几个命令
-------|command 由最近的命令向前搜索以command开头的那个命令，并运行
-------|!!	运行上一个命令

-----------------------配置文件---------------------------------------

/etc/issue 决定了进站信息
/etc/issus.net 是提供给telnet这个远程登录程序使用的

issue内的代码意义
\d	本地端时间的年月日
\l	显示第几个终端机接口
\m	显示硬件的等级
\n	显示主机的网络名称
\o	显示域名
\r	操作系统版本(uname -r)
\t	本地端的时分秒
\s	操作系统的名称
\v	操作系统的版本

/etc/motd 决定了用户登录后，显示的信息

login shell以及non-login shell(不需要重复登录的举动，如在x window登录后启动终端)
login shell:流程1./etc/profile 系统整体的配置
		2.~/.bash_profile或~/.bash_login或~/.profile属于使用者个人配置


source 配置文件   <==加载配置文件

non-login shell:仅仅会读取~/.bashrc

/etc/man.config记录了man手册到哪里寻找

~/.bash_logout 注销bash后，系统做完什么后离开

stty [-a]  <==终端机的环境配置
--------|-a 列出所有参数

stty 配置项 配置值 <==配置特殊热键

set [-uvCHhmBx]  <==配置整个命令的输入输出环境
--------|-u 默认不激活，激活后，使用没有配置的变量报错
--------|-v 默认不激活，激活后，若信息被输出前，会显示信息的原始内容
--------|-x 默认不激活，激活后，会显示命令的内容前面有++符合
--------|-h 默认激活，与历史命令有关
--------|-H 默认激活，与历史命令有关
--------|-m 默认激活，与工作管理有关
--------|-B 默认激活，与[]的作用有关
--------|-C 默认不激活，使用>时，若文件存在则不会被覆盖


/etc/inputrc 按键的配置

通配符
*	匹配0到无穷个任意字符
?	匹配一个任意字符
[]	如[abcd]则abcd任选一个
[-]	如[0-9]，0-9直接的所有数字
[^]	取反,如[^abc] ，不是abc即可

bash环境下的特殊符号
#	注释，最常用在script中
\	转义字符
|	管道
;	命令分割,eg: echo h ; ls
~	用户的家目录	
$	获取变量的值（右值）
&	将命令变成后台下工作
!	not取反
/	路径的分隔符
>,>>	输出重定向，输出与累加
<,<<	输入重定向
''	不具有让特殊字符具有特殊含义
""	能让特殊字符有特殊含义
``	率先运行可以用$(command)替换
()	中间为子shell的起始与结束
{}	中间为命令区块的组合

stdin: 0, 使用<或<<
stdout: 1, 使用>或>>
stderr: 2, 使用2>或2>>

若要将stdout和stderr输出到一个文件则使用> file 2>&1 
/dev/null 可以抹掉任何导向这个设备的信息

<<代表的是结束的输入字符
eg:cat > catfile << "eof"
当输入了eof则代表输入结束，而不需要输入ctrl+d


cmd;cmd (不考虑命令的关联性)
cmd&&cmd2 cmd成功（$?=0)则运行cmd2
cmd||cmd2 cmd失败($?!=0)则运行cmd2

|管道只能处理stdout，而不能处理stderr
将上个命令的stdout作为下一个命令的stdin

cut -d'分隔符' -f fields <==用于有特殊分隔符
cut -c 字符区间   <==用户排列整齐信息
--------|-d 后面接分隔符，与-f一起使用
--------|-f 依据-d的分隔符分割后，用-fn取出第n段，n以,间隔如n1,n2取出n1和n2
--------|-c 以字符为单位取出n1-n2之间的字符
cut 用于处理同一行里面的数据分解

grep [-acinvo] [--color=auto] '搜索的字符串' filename
grep [-A] [-B] [--color=auto[ '搜索的字符串' filename
--------|-a 将二进制文件以text的文件格式搜索
--------|-c 统计找到的字符串的次数
--------|-i 忽略大小写
--------|-n 输出行号
--------|-v 反向搜索
--------|-o 只显示匹配项,不会整行一同显示
--------|--color=auto 关键字高亮显示
--------|-A 后面加数字，为after的意思，除了该行外后面的n行也列出来
--------|-B 后面加数字，为before的意思，除了该行外前面的n行也列出来
该行有关键字时grep会显示整行

sort [-fbMnrtuk] [file or stdin]
--------|-f 忽略大小写
--------|-b 忽略最前面的空格符部分
--------|-M 根据月份的名字来排序
--------|-n 用数字排序（默认是文本排序)
--------|-r 反向
--------|-u uniq,相同的数据，仅出现一行
--------|-t 分隔符，默认[tab]
--------|-k 以那个区间field来排序，与-t连用，-t划分几个段后，以-k n这个第n段来排序

uniq [-ic] <==去重(需要先排序,才能达到去除重复的效果)
--------|-i 忽略大小写
--------|-c 计数


wc [-lwm] (结果为行数 字数 字符数)
--------|-l 仅仅列出行
--------|-w 仅仅列出字（英文单词）
--------|-m 多少字符

tee [-a] file <==处理标准输入，将标准输出可以在输出至屏幕的同时输出至文件
--------|-a 追加的方式

tr [-ds] SET1 ... (删除或替换) <==处理标准输入
--------|-d 删除set1这个字符串
--------|-s 取代掉重复的字符

col [-xb] <== 一般用于替换tab
--------|-x 将tab替换成对等的空格数
--------|-b 有/时，仅保留反斜杠最后接的那个字符

join [ti12] file1 file2
--------|-t 设置分隔符号,默认空格，并且比对第一个字段的数据，如果两个文件相同，则将两个文件数据连成一行,相同字段会放置在行首
--------|-i 忽略大小写
--------|-1 第一个文件要用哪个字段来分析
--------|-2 第二个文件要用哪个字段来分析

paste [-d] file1 file2
--------|-d 设置分隔字符，默认[Tab]
--------|- 如果file部分替换成-，代表数据来自标准输入

expand [-t] file <==将tab用空格替换 <==unexpand则相反
--------|-t 空格的数目n

split [-bl] file PREFIX
--------|-b 想要分隔的文件大小，单位可以设置为b,k,m等
--------|-l 后面接行数,以行数来分隔
--------|PREFIX 代表前导符的意思，可作为分隔文件的文件名的前缀字符

!!!!!!!!!!!!关于-的作用，会被当做stdin或stdout
eg:tar -cvf - /home | tar -xvf -
-作为tar -cvf的标准输出 ，后面的-作为标准输入

xargs [-Oepn] command <== 以stdin的数据默认根据空格分隔成command的参数,command会使用原始命令，即不用alias
--------|-O 如果输入的stdin含有特殊字符，如',\，空格等，则可以将它还原成一般字符
--------|-e 替换EOF，后面接一个字符串，当输入该字符串时代表eof
--------|-p 运行每个参数的命令时，询问
--------|-n 后面接次数，每次command命令要用几个参数的意思
xargs没有接收任何command时默认echo

finger获取账号的相关信息，后面接用户名

======================================正则表达式===============================================
注意点1：注意语系的不同导致编码的不同
特殊符号	意义
[:alnum:]	0-9，a-z，A-Z
[:alpha:]	A-Z,a-z
[:blank:]	空格与[Tab]
[:cntrl:]	控制符
[:digit:]	数字
[:graph:]	除了空格和[Tab]外的其他按键
[:lower:]	a-z
[:print:]	可打印字符
[:punct:]	标点符号
[:upper:]	A-Z
[:space:]	空格，[Tab],CR等
[:xdigit:]	十六进制数，数码有0-9,A-Z,a-z

基本正则表达式
^word		以word为行首
word$		以word为行尾
.		任意一个字符
char*		重复char字符0-无数次
[list]		[]内的任意一个字符
[n1-n2]		编码n1-n2范围内的任意一个字符
[^list]		不以[]内的任意一个字符
char{n,m}	重复char字符n-m次{n,m}
		{n}重复n次
		{n,}重复n次以及n次以上
扩展的正则表达式
char+		重复char字符一次或以上
char?		重复char字符0个或一个
|		or
(string)	找出群组字符串
(string)+	一个及一个以上(string)		!!与\{1,\}的区别是()里面是字符串，而后者是字符
\bstring	精确匹配string


sed [-nefr] [动作]
--------|-n 使用安静模式，在一般sed的用法中，所有来自标准输入的数据都会被列出在屏幕上，而-n后，只有经过sed处理的那一行（或者动作）才会被列出来
--------|-e 直接在命令列模式上进行sed的动作编辑,运行sed一条命令中执行多个动作,但需要-e 动作 -e 动作
--------|-f 将sed的动作写在一个文件内，-f filename则可以运行filename内的sed动作
--------|-r 让sed支持扩展的正则表达式
--------|-i 直接修改读取的文件内容，而不是有屏幕输出

动作说明:[n1[,n2]] function 应该用''括起来
--------|n1,n2 一般表示选择的动作行数，比如10,20[动作行为]代表对于10到20行进行动作处理

function:
--------|a 新增，a后面接字符串，则这些字符串会在目前的下一行出现
--------|c 替换，c后面接字符串，这些字符串将会替换n1,n2之间的行
--------|d 删除
--------|i 插入，i后面接字符串，这些字符串出现在目前的上一行
--------|p 打印n1，n2之间的数据
--------|s 替换，eg:1,20s/old/new/g 这个/可以替换为别的分割符如#

printf 类似c语言的printf
printf '打印格式' 内容

awk '条件类型1{动作1} 条件类型2{动作2} ...' filename <==用于处理每一行栏内的数据，默认分隔符是[Tab]或空格 
===========awk注意点====================
1.由于已经使用''括住所有动作，所以要想如printf使用文字部分时需要使用""
2.和bash中的变量不同，使用时（也就是变量作为右值时）不需要加$
3.若一个动作由多个命令组成，则每个命令之间用;或者\[Enter]间隔
=========awk中所使用的变量===============
1.$1 $2 $3代表第1,2,3栏的数据，$0代表一整行数据
2.NF 每一行$0所拥有的总栏数
3.NR 目前awk所处理的是第几行数据
4.FS 目前的分割字节，默认是空格
=========awk的逻辑运算字符==============
> < >= <= != == 
========================================
=赋值
========================================
awk的处理过程:
1.读取一行数据填入$0 $1 $2...
2.依据条件类型的限制判断是否需要进行后面的动作
3.做完所有的动作与条件类型
4.重复1-3直到所有行数都处理完
=========awk的特殊字符==================
BEGIN 最先执行
END   最后执行


diff <==每行作为对比单位,一般用于ASCII纯文字文件上的对比
diff [-bBiuraN] from-file to-file
--------|-b 忽略一行当中，仅有多个空格的差异如"about me"和"about    me"视为相同
--------|-B 忽略空白行的差异
--------|-i 忽略大小写
--------|from-file 作为原始(参考)比对文件
--------|-u 输出统一内容的头部信息（打补丁使用），计算机知道是哪个文件需要修改
--------|-r 递归对比目录中的所有资源（可以对比目录）
--------|-a 所有文件视为文本（包括二进制程序）
--------|-N 无文件视为空文件,在没有使用-N时会提示文件仅在某个目录中才有无法对比
可以用-替换成标准输入

cmp [-l] file1 file2 <==逐字节比较两个文件
--------|-l 将所有的不同点的位都列出来，因为默认是第一个不同点

patch -pN < patch_file 升级 <==使用diff创建出的补丁文件
patch -R -pN < patch_file 还原
--------|-p 后面可以接取消几层目录的意思
--------|-R 代表还原

========================shell script=====================
#为注释
如何运行
1.具有rx权限直接运行
2.bash script.sh 或sh script.sh
4..
4.source
运行方式的区别=================================
1.bash 是另外开启一个子进程运行脚本
2.source 则会在父进程上运行脚本
导致了变量的生命周期不同

#!/bin/bash 告知这个文件使用的是bash的语法

编写shell的习惯
开头处：功能，版本，作者和联系方式，版权声明，历史记录，有特殊的命令使用绝对路径使用，需要的环境变量预先配置和export

当下达一些外部命令时，最好的解决方式时提供环境变量

$((运算式))这样子便于计算数值（因为默认是字符型)

------------------------------------------------------------------------------
test 命令 可以使用[]来代替test

!!!!
[]的注意点
1.内的每个组件都用空格隔开
2.变量或者常量最好都用""括起来
3.-a -o连接两个条件
4.或者使用&&或||,但格式为[ con1 ] || [ con2 ]

测试的标志				代表的意义
1.关于某个文件的文件类型判断eg:test -e filename 表示是否存在
-e					该文件存在?（常用)
-f					存在且为文件?
-d					存在且为目录?
-b					存在且为块设备?
-c					存在且为字符设备?
-S					存在且为socket文件?
-p					存在且为管道文件pipe?
-L					存在且为链接文件?
2.关于文件的权限判断,如test -r filename是否可读（但root权限经常例外)
-r					存在且可读?
-w					存在且可写?
-u					存在且具有SUID属性?
-g					存在且具有SGID属性?
-k					存在且具有Sticky bit属性?
-s					存在且非空？
3.两个文件之间的比较 test file1 -nt file2
-nt					newer than 是否比file2新
-ot					older than 是否比file2旧
-ef					主要是判断两个文件的inode是否相同
4.关于两个整数之间的判断 test n1 -eq n2
-eq					两数值相等(equal)
-ne					不等(not equal)
-gt					n1 > n2(greater than)
-lt					n1 < n2(less than)
-ge					n1 >= n2(greater than or equal)
-le					n1 <= n2(less than or equal)
5.字符串的数据判断
test -z string				为空串?
test -n string				不为空串?
test st1 = str2				两个字符串相等?
test str1 != str2			两个字符串不等?
------------------------------------------------------------------------
在shell中，变量有
变量		意义
------		--------
$0		文件名
$1,$2,$3...	后面的参数
$#		后面接的参数的个数
$@		"$1" "$2" "$3" ...每个变量都是独立的
$*		"$1c$2c$3c..."	c为分隔符，默认是空格键
--------------------------
shell中变量偏移
shift n偏移n个变量($1开始作用,$0不变)

语法
1.条件判断
if [ con1 ]; then
	语句
elif [ con2 ]; then
	语句
else
	语句
fi
2.多重选择
case $var in
	"内容1")
		程序
		;;
	"内容2")
		程序
		;;
	*)
		程序
		;;
esac
3.函数
function fname() 
{
	程序段
} 
函数中的参数,$0函数名,$1形参1
如何使用函数 fname 1 2 3 #1 2 3为fname的参数$1=1 $2=2 $3=3 $0=fname

4.循环
while [ con ]
do
	程序
done

until [ con ]
do
	程序
done

for var in con1 con2 con3
do 
	程序
done

for (( 初始值; con; 步长))   eg: for (( i = 1; i <= $nu; ++i ))
do
	程序
done


shell的调试
sh [-nvx] scripts.sh
--------|-n 检查语法问题
--------|-v 先输出shell的内容然后运行
--------|-x 将用到的shell内容输出，（类似与单步调试)

=============================账号管理与ACL配置================================

/etc/passwd文件中的结构
root:x:0:0:root:/root:/bin/bash
x占位（早期密码是直接存放在这个字段中)

UID(id范围)					(ID使用者特性)
0(系统管理员)				只要将用户的UID改成0，那么就具有了ROOT的权限，一个系统上面不见得只有root一个管理员
1-499(系统账号)				1-99:由发行版linux自行创建的系统账号,100-499若用户有系统账号需求时，可以使用的账号UID
500-65535(可登录账号)			2.6.x版本的linux已经支持2^32-1这么多的UID

root		用户信息说明栏使用finger的时候会提供很多信息
/root		账号的home目录
shell		所使用的shell

/etc/shadow的文件结构

root:$6$2mNLumdY$YbSqnh7chwBXHmDnJlYg0c5hvgwa5EpfU/TUmqQtcBaI/PBnK0cDHfjebg7m2EVIEj59rOdLDv.mPCHI1MN4Z0:18065:0:99999:7:::

1.账号名称
2.密码(加密后)
3.最近一次修改密码的日期(可以使用chage命令来帮助理解该数字)
该结果为从1970-1-1到修改密码的那一天所经过的天数
4.密码不可被更改的天数
(距离上一次修改密码后需要间隔该字段的天数后才能修改)
5.密码需要重新更改的天数
(在最近一次修改密码后需要间隔该字段的天数后必须修改，否则过期)
6.密码需要重新修改的期限前的警告天数(与第五个字段相比)
(在第五个字段的前该字段天会提示用户，即将过期，需要修改密码)
7.密码过期后的账号宽限时间(与第五个字段相比)
密码的有限期为第三个字段加上第五个字段，过期后若用户没有修改密码，则密码过期(但是还是可以使用），直到过了该字段的天数后彻底失效，无法使用,无法登录
8.账号失效日期
(与第三个字段一样都是从1970-1-1开始的天数，这个字段表示过期后账号无法使用，无论密码是否过期，一般用于收费的系统，可以配置让用户过了该日期后无法使用)
9.保留字段

/etc/group文件结构
lp:x:7:littlerain
1.用户组
2.如同/etc/passwd中第二个字段
3.GID
4.用户组中的成员中间用,隔开

/etc/passwd中，GID决定了用户的初始化群组

使用groups可以查看目前登录用户所属的用户组,第一个结果决定了用户的有效群组(这个决定了新建文件时的文件所属于的用户组)

newgrp 用户组(修改用户的有效群组)
newgrp会新起一个进程，在该进程中有效群组变更为新的用户组

/etc/gshadow的文件结构
lp:*::littlerain
1.用户组名
2.密码栏，开头为!表示无合法口令，所以没有群组管理员
3.群管理员的账号
4.用户组中的成员

----------------------------useradd的说明--------------------------------------------------------------------------------
useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 用户账号名
--------|-u 直接指定特殊的UID
--------|-g 该用户组的gid会放置在/etc/passwd的第四个字段中
--------|-G 决定了用户是否加入其他的用户组，会写到/etc/group中
--------|-M 强制!不要创建用户家目录(系统账号默认值)
--------|-m 强制!创建用户家目录（一般账号默认值)
--------|-c /etc/passwd中第五个字段的说明内容
--------|-d 指定该目录成为用户的home目录
--------|-r 创建一个系统账号，这个账号的UID会有限制（/etc/login.defs)
--------|-s 后面接一个shell，没有制定的话默认是/bin/bash(deepin目前的是/bin/sh
--------|-e 后面接日期，格式为yyyy-mm-dd，会写入到shadow的第八个字段(用户失效日期)
--------|-f 后面接shadow的第七个字段，指定密码是否失效，0为立刻失效，-1为永不失效(密码只会过期)

useradd -D显示默认值(/etc/default/useradd中决定)
GROUP=100 (新建用户的初始群组）
不同的发行版决定了不同的用户组机制
1.私有用户组机制(系统会创建一个与账号一样的用户组作为用户的用户组，不会参考GROUP这个默认值)
2.公共用户组机制(则参考GROUP这个值)

HOME=/home (用户家目录的基准目录，都会创建在/home下面

INACTIVE=-1: 密码过期后是否会失效的配置值（-1不会，0立刻，数字如30则过期后30天失效)

EXPIRE=:    账号的失效日期

SHELL=/bin/bash: 默认使用的shell名称

SKEL=/etc/skel: 用户家目录参考的基准目录
(创建用户后会copy一份/etc/skel放置在用户home目录里)

CREATE_MAIL_SPOOL=yes: 创建用户的mailbox
ls -l /var/spool/mail/用户

UID/GID的默认值参考/etc/login.defs
/etc/login.defs中文件结构
1.MAIL_DIR /var/spool/mail 	用户默认信息目录
2.PASS_MAX_DAYS 99999		/etc/shadow内的第五栏，多久需要变成密码
3.PASS_MIN_DAYS 0		/etc/shadow内的第四栏，多久不可重新配置密码
4.PASS_MIN_LEN 5		密码最短长度，已经被pam静态库取代
5.PASS_WARN_AGE	7		/etc/shadow内的第六栏，过期前的警告日期
7.UID_MIN	500		小于这个数属于系统保留
8.UID_MAX	60000		使用者最大能够使用的UID
9.GID_MIN	500		小于属于系统保留
10.GID_MAX	60000		使用者最大能够使用的GID
11.CREATE_HOME	yes		在不加-m或-M时，是否主动创建home目录
12.UMASK	077		用户家目录创建的umask
13.USERGROUPS_ENAB yes		删除用户时userdel，是否删除初始化群组
14.MD5_CRYPT_ENAB yes		是否经过md5加密

需要注意的是系统给予一个账户UID时，1参考UID_MIN取得最小数值，然后2.有/etc/passwd中找最大的UID，1和2对比后，在最大的基础上加一就是新的UID
---------------------------------------------------------------------------------------------------------------------------------------------

passwd [--stdin]  <==所有人均可使用来改自己的密码
passwd [-l] [-u] [--stdin] [-S] [-n 日期] [-x 日期] [-w 日期] [-i 日期] 账号
--------|--stdin: 接受标准输入作为密码(不是所有的发行版都支持)
--------|-l lock的意思，将/etc/shadow的第二栏最前面加上!，使密码失效
--------|-u unlock
--------|-S 列出密码相关参数,shadow文件内的大部分信息
--------|-n 后面接天数，shadow的第四个字段，多久不可修改密码天数
--------|-x 后面接天数，shadow的第五个字段，多久内必须要修改密码
--------|-w 后面接天数，shadow的第六个字段，密码过期前的警告天数
--------|-i 后面接日期，shadow的第七个字段，密码失效日期

chage [-ldEImMW] 用户名
--------|-l 列出该账号的详细密码参数
--------|-d 后面接日期，修改shadow的第三个字段（最近一次更改密码的日期）格式YYYY-MM-DD
--------|-E 后面接日期，修改shadow的第八字段（账号失效日期），格式YYYY-MM-DD
--------|-I 后面接天数，修改shadow的第七字段（密码失效日期）
--------|-m 后面接天数，修改shadow的第四字段（密码最短保留天数）
--------|-M 后面接天数，修改shadow的第五字段（密码多久需要进行变更）
--------|-W 后面接天数，修改shadow的第六字段（密码过期前警告天数）

usermod [-cdegGlsuLU] username  <==也可直接修改/etc/passwd 或/etc/shadow
--------|-c /etc/passwd的第五栏的说明栏，可以加入账号的说明
--------|-d 修改用户的home目录，/etc/passwd的第六个字段
--------|-e 后面接日期，YYYY-MM-DD /etc/passwd的第八个字段
--------|-f 后面接天数，shadow的第七个字段
--------|-g 后面接初始用户组，修改/etc/passwd的第四个字段，也就是gid的字段
--------|-G 后面接次要用户组，修改的是/etc/group
--------|-a 与-G一起使用，可添加次要用户组的支持（新增）而不是配置（修改）
--------|-l 后面接账号名称，修改账号名称,/etc/passwd的第一栏
--------|-s shell的实际文件，可以使/bin/bash或者/bin/csh
--------|-u 后面接UID数字，修改/etc/passwd的第三栏数据
--------|-L 暂时冻结用户密码，/etc/shadow的密码栏
--------|-U 解冻密码

用户的数据有
/etc/passwd,/etc/shadow  用户的账号和密码
/etc/group,/etc/gshadow  用户组的相关信息
/home/username,/var/spool/mail/username 用户个人文件

------------一般用户可以使用,上述基本属于管理员
userdel [-r] username
--------|-r 连同用户的家目录一起删除

finger [-s] usernmae
--------|-s 仅列出用户账号，全名，终端代号，登录时间等
--------|-m 列出与后面接的账号相同者，而不是利用部分比对

chfn [-foph] [账号名]  <==会修改/etc/passwd的第五个字段
--------|-f 全名
--------|-o 办公室房间号码
--------|-p 办公室电话号码
--------|-h 家庭电话

chsh [-ls]   <==change shell
--------|-l 列出可用的shell，/etc/shells
--------|-s 配置修改自己的shell

id [username]  <==查看用户的uid/gid相关信息

groupadd [-g gid] [-r] 组名
--------|-g 特定GID
--------|-r 创建系统用户组/etc/login.defs中的GID_MIN有关

groupmod [-g gid] [-n group_name] 组名
--------|-g 修改现有的gid
--------|-n 修改现有的组名

groupdel [groupname]

gpasswd groupname
gpasswd [-A user1,...] [-M user3,...] groupname
gpasswd [-rR] groupname
--------|  没有参数时，表示给予groupname一个密码/etc/gshadow
--------|-A 将groupname的控制权给后面的用户管理（用户组管理员)
--------|-M 将用户加入到该组中
--------|-r 将groupname的密码移除
--------|-R 将groupname的密码失效
gpasswd [-ad] user groupname
--------|-a 将用户加入用户组
--------|-d 将用户移除用户组

------------------------------------ACL (access control list)-------------------------
1.使用者(user) 针对使用者来配置权限
2.用户组(group) 针对用户组来配置权限
3.默认属性(mask) 针对该目录下创建文件/目录时，规范新数据的默认权限

若系统没有默认增加ACl的话可以
mount -o remount,acl /
修改/etc/fstab
LABEL=/1 / ext3 defualts,acl 1 1

setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名
--------|-m 配置后续的acl参数给文件使用，不可与-x合用
--------|-x 删除后续的acl参数，不可与-m使用
--------|-b 移除所有的acl参数
--------|-k 移除默认的acl参数
--------|-R 递归配置acl
--------|-d 配置默认的acl参数，只对目录有效，在该目录新建数据时会引用此数据
1.针对特定使用者的方式
配置语法:  u:[使用者列表]:[rwx]没有使用者时，默认配置的是文件拥有者
2.针对特定群组的方式
配置语法:  g:[用户组列表]:[rwx]
3.针对有效权限mask的方式
配置语法:  m:[rwx]   <==限制u和g的最大权限
4.针对默认权限的配置方式
配置语法:  d:[ug]:使用者列表/用户组列表:[rwx]


getfacl filename
选项几乎和setfacl一致

su [-lm] [-c 命令] [username]  <==切换谁，需要谁的密码
--------|- 单独使用时代表使用login-shell的变量文件读取方式来登录系统,若使用者没有，则是切换为root身份
--------|-l 与-类似，但是后面需要加想要切换的用户账号，也是login-shell的方式
--------|-m 与-p一样，表示使用目前的环境配置，而不读取新用户的配置文件
--------|-c 仅执行一次命令，所以要后面加命令

sudo [-b] [-u 新使用者] <==/etc/sudoers决定了谁有权限使用该命令 切换用户来执行某个操作，密码仅仅需要当前使用的用户的密码
--------|-b 将后续的命令放在后台中让系统自行运行，而不和目前的shell产生影响
--------|-u 后面接想要切换的用户，没有用户则是root

/etc/sudoers的文件格式
使用visudo来编辑该文件（会检查语法错误），命令中应该使用绝对路径
1.单一用户的配置
使用者账号		登陆者的来源主机名=（可切换的身份）	可下达的命令   
root 			ALL=(ALL) 				ALL	       
2.用户组和免密码的配置
%groupname		ALL=(ALL)				ALL
username/%groupname	ALL=(ALL)				NOPASSWD:ALL
3.有限制的命令配置	
myuser			ALL=(root)				!/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*   <==!代表无法执行，也就是无法修改root的密码
4.通过别名建立配置
User_Alias UPPER = user1, user2, user3    <==设置用户别名，别名都需要大写
Cmnd_Alias UPPERCOM = !/usr/bin/passwd, /usr/bin/passwd [a-zA-Z]*  <==设置命令别名
UPPER			ALL=(root)				UPPERCOM
5.sudo的时间间隔为五分钟（五分钟内再次使用sudo不需要密码)


特殊的shell /sbin/nologin 可以使用系统资源但是无法登录（无法使用bash获取其他的shell来操作) /etc/nologin.txt可以编辑无法登录的原因告知用户

------------------PAM(Pluggable Authentication Modules，嵌入式模块)

PAM用来进行验证的数据称为Modules

/etc/pam.d/配置文件  使用PAM的程序会调用该目录下同名的配置文件，依据该配置文件寻找对应的PAM静态库

eg:CentOS下/etc/pam.d/passwd
#%PAM-1.0	<==PAM的版本
auth	include		system-auth   <==每一行都是验证过程
account	include		system-auth
passwordinclude		system-auth
验证类别控制标准	PAM静态库与静态库参数
include代表呼叫后面的文件来作为这个类别的验证

第一个字段：验证类别
1.auth
	authentication(认证),主要用来验证使用者的身份，通常是需要密码来验证，所以后面接的静态库是用来检验用户的身份
2.account
	account(账号)则大部分进行授权，主要验证使用者是否拥有正确的权限
3.session
	session会话，使用者在本次登录（本次命令）期间，PAM所给予的环境配置，通常用于记录用户登录或注销时的信息
4.password
	主要在提供验证的修改工作，比如修改密码

第二个字段：验证的控制标志（control flag)  <==通过验证的标准
1.required
	成功则带有success的标志，否则failure，但不论成功与否都会继续后续的验证流程
2.requisite(必须的)
	若验证失败则立刻回复原程序failure，并且终止后续验证，若成功则带有success并继续验证（与1的区别，失败后立即终止后续验证)
3.sufficient(充足的)
	成功立刻回复success给原程序，终止后续验证，若失败，则带有failure并且继续（与2相反)
4.optional
	大多数用于显示信息


/etc/pam.d/* 每个程序个别的PAM配置文件
/etc/security/* 其他PAM环境的配置文件
/lib/security/*	PAM静态库文件的实际放置目录
/usr/share/doc/pam-*/ 详细的PAM说明

较常使用的PAM静态库
1.pam_securetty.so:
	限制管理员只能够从安全的终端机登录，安全的终端机配置则写在/etc/securetty这个文件中
2.pam_nologin.so:
	限制一般用户是否能够登录主机，当/etc/nologin存在时，则所有一般用户无法再登录系统，并且会显示该配置文件的内容
3.pam_selinux.so:
	针对程序来进行细部管理权限的功能
4.pam_console.so:
	当系统出现某些问题，或者需要使用特殊的终端接口（如RS232）登录主机时，这个静态库可以帮助处理一些文件的权限，让使用者能够通过特殊终端来登录系统
5.pam_loginuid.so:
	验证使用者的UID是否满足程序需要
6.pam_env.so:
	配置环境变量的一个静态库，如果需要额外的环境变量配置参考/etc/security/pam_env.conf
7.pam_unix.so:
	可以用在验证阶段的认证功能，用在授权阶段的账号许可证管理，用在会话阶段的登陆文件记录，甚至是密码修改阶段的检验，在早期使用的非常频繁
8.pam_cracklib.so:
	用来检验密码的强度，包括密码是否在字典中，密码输入几次失败后就断开此次联机都是由该静态库提供
9.pam_limits.so:
	ulimit的功能由该静态库提供


limits.conf可以限制每次仅能有一个用户登录系统

w / who 查询已经登录在系统上的用户
lastlog 查询每个账号最近登录的时间会读取/var/log/lastlog文件

-------------------------用户间的通信--------------
write 用户 [用户所在终端接口]	<==用户之间的通信(但是会打断该用户当前的工作)

mesg n 拒绝除root外的对话
mesg y 开启对话
mesg 显示状态

wall 广播

mail username@localhost -s "邮件标题"  <==可使用<重定向来决定邮箱信息
mail则会查看邮箱内容

-------------------------手动增加用户或者用户组---------------
pwck 检查/etc/passwd的信息，与实际home目录是否存在的信息，还可以对比/etc/passwd /etc/shadow的信息是否一致
grpck 则用于检查用户组
pwconv 主要用于将/etc/passwd内的账号和密码，移动到/etc/shadow当中
pwunconv 则与上一个相反,并且会删除/etc/shadow文件
chpasswd 一般用于批量创建用户 eg: echo "username:password" | chpasswd -m

手动创建的步骤
1.先创建所需要的群组 ( vi /etc/group )；
2.将 /etc/group 与 /etc/gshadow 同步化 ( grpconv )；
3.创建账号的各个属性 ( vi /etc/passwd )；
4.将 /etc/passwd 与 /etc/shadow 同步化 ( pwconv )；
5.创建该账号的口令 ( passwd accountname )；
6.创建用户家目录 ( cp -a /etc/skel /home/accountname )；
7.更改用户家目录的属性 ( chown -R accountname.group /home/accountname )

========================磁盘配额与进阶文件系统管理============================
Quota的一般用途:
1.针对www server,例如：每个人的网页空间的容量限制!
2.针对mail server,例如，每个人的邮件空间限制
3.针对file server,例如，每个人最大的可用网络磁盘空间

针对linux系统主机上面的配置
1.限制某一用户组所能使用的最大磁盘配额
2.限制某一使用者最大的磁盘配额
3.以硬链接的方式，来使邮件可以作为限制的配额


Quota配额的使用限制
1.只能针对整个文件系统
2.内核必须支持
3.Quota的记录文件（现已从quota变成了aquota)
4.只对一般身份使用者有效(root无法配置quota)


对于文件系统的限制有
1.容量限制block或文件数量限制inode
2.柔性劝导与硬性规定(soft/hard)
inode/block有两个配置值一个是hard一个是soft，通常hard比sort还要高，高出sort后会有警告
3.会倒数计时的宽限时间（grace time),超过soft后会有宽限时间允许用户删除文件，宽限时间过后最大用量将由hard变成soft的值

Quota流程-1.文件系统的支持
挂载时加入usrquota,grpquota

Quota流程-2.创建quota记录文件
Quota是通过分析整个文件系统当中，每个使用者（用户组）所拥有的文件总数和容量，再将这些数据记录到该文件系统的最顶层目录，然后在该记录文件中在使用每个账号（用户组）的限制值去规范磁盘使用量的

quotacheck [-avugfM] [/mount_point]  <==扫描文件系统并创建quota的记录文件
--------|-a 扫描所有在/etc/mtab内，含有quota支持的文件系统，加上此参数后，/mount_point不必写
--------|-u 针对使用者扫描文件与目录的使用情况，会创建aquota.user
--------|-g 针对用户组扫描文件与目录的使用情况，会创建aquota.group
--------|-v 显示扫描过程的信息
--------|-f 强制扫描文件系统，并写入新的quota的配置文件中（危险）
--------|-M 强制以读写的方式扫描文件系统，只有在特殊情况才会使用

Quota流程-3.Quota启动，关闭与限制值配置
quotaon [-avug]
quotaon [-vug] [/mount_point]
--------|-u 针对使用者启动(aquota.user)
--------|-g 针对用户组启动(aduota.group)
--------|-v 显示启动过程的相关信息
--------|-a 根据/etc/mtab内的文件系统配置启动有关的quota，若不加-a则后面需要加特定的挂载点

quotaoff [-a]
quotaoff [-ug] [/mount_point]
--------|-a 全部的文件系统都关闭，根据/etc/mtab
--------|-u 仅针对后面那个挂载点关闭user quota
--------|-g 仅针对后面那个挂载点关闭group quota

edquota <==编辑账号/用户组的限制与宽限时间
edquota [-u username] [-g groupname]  
edquota -t <==修改宽限时间
edquota -p 范本账号 -u 新账号
--------|-u 后面接用户名，可以进入quota的编辑画面去配置username的限制值(单位KB)(该界面只要保持每一行有七栏即可，不需要对齐
--------|-g 后面接用户组，可以进入quota的编辑画面去配置groupname的限制值(单位KB)
--------|-t 可以修改宽限时间
--------|-p 复制范本，那个范本账号为已经存在并配置好quota的使用者
	    目的是将范本的账号这个用户的quota限制复制给新账号

Quota流程-4.Quota限制值的报表
quota [-uvs] [username]
quota [-gvs] [groupname]
--------|-u 后面接username表示显示出该使用者的quota限制，若不接则显示出运行者的quota限制
--------|-v 显示每个用户在文件系统的quota值
--------|-s 使用1024为倍数来制定单位，会显示如M的单位
--------|-g 后面接groupname表示显示出该用户组的quota限制值

repquota -a [-vugs] 针对整个文件系统的限额做报表
--------|-a 查阅/etc/mtab寻找具有quota的标志的文件系统，并报告quota的结果
--------|-v 输出的数据将含有文件系统相关的细致信息
--------|-g 显示出个别用户组的quota的值
--------|-s 使用M，G为单位
--------|-u 显示出使用者的quota限制值（默认)

Quota流程-5.测试与管理

warnquota根据/etc/warnquota.conf的配置来找出目前系统上超过soft的用户，然后通过email的功能发送给用户和root

setquota <==直接在命令中配置quota的限制值
setquota [-u|-g] 名称 block(soft) block(hard) inode(soft) inode(hard) 挂载点

------------------------------------------------RAID磁盘阵列--------------------------------
Redundant Arrays of Inexpensive Disks,RAID
容错式廉价磁盘阵列

磁盘阵列的等级
一）
RAID-0(等量模式,stripe)性能最佳,这种模式下硬盘会先切出等额的区块，然后当文件需要写入RAID时，该文件会依据区块的大小分割，然后依照RAID中硬盘的顺序，循环轮流写入到各个硬盘中。
特点:只要有任何一个硬盘损坏，在RAID上面的所有数据都会遗失而无法读取

二）
RAID-1(映射模式，mirror)完整备份
让同一份数据，完整的保存在RAID中的每一个硬盘中
特点：数据的备份，以及读取的性能提高，当多个进程读取同一个数据时，可以选择不同的硬盘去读取

三）
RAID 0+1,RAID 1+0
0+1，率先组成RAID-0，然后多个RAID-0组成RAID-1
1+0，率先组成RAID-1，然后多个RAID-1组成RAID-0

四）
RAID-5:性能与数据备份的均衡考虑
类似于RAID-0,不过在循环写入的时候，会在每一个硬盘上加一个同位检查数据（Parity),这个数据被记录其他硬盘的备份数据，用于当有硬盘损坏时的救援
eg:
DiskA		DiskB		DiskC
A0		B0		parity0
A1		parity1		C1
parity2		B2		C2
特点:RAID-5的总容量会是整体硬盘数量-1，而且当损坏的硬盘数量大于1时，这整个RAID就损坏,因为RAID-5默认仅支持一个硬盘损坏
RAID-6则允许两块硬盘作为parity的储存

Spare Disk:预备硬盘的功能:
一个或多个硬盘没有包含在磁盘阵列中，平时不会被使用，当磁盘阵列中任何硬盘损坏时，则这个spare disk则会主动被拉近磁盘阵列中，并且将坏的硬盘移除，然后重新建立数据系统（但坏的硬盘还是需要人手工替换的)

磁盘阵列的优点：
1.数据安全性和可靠性
2.读写性能
3.容量

软件/硬件磁盘阵列：硬件需要有磁盘阵列卡以及驱动，软件则是模拟出磁盘阵列。
硬件磁盘阵列在linux下面看来就是一个大的硬盘/dev/sd[a-p]，而软件模拟出来的，所使用的设备名称时系统的设备文件/dev/md[0-n]

mdadm --detail /dev/md0 <==下面命令运行后，需要一定的时间才能查看
mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N --level=[015] --spare-devices=N /dev/sdx
--------|--create 创建RAID
--------|--auto=yes 决定创建后接的软件磁盘阵列设备即/dev/md[0-9]
--------|--raid-devices=N 使用几个硬盘作为磁盘阵列的设备
--------|--level=[015] 磁盘阵列的等级，但是不只是015
--------|--spare-devices=N 使用几个作为磁盘阵列的备份设备   
--------|-detail 显示后面的磁盘阵列的信息

cat /proc/mdstat也可以查看磁盘阵列的状态
Personalities : [linear] [multipath] [raid0] [raid1] [raid6] [raid5] [raid4] [raid10] 
md0 : active raid5 sda8[5] sda9[4](S) sda7[2] sda6[1] sda5[0]  <==(S)为spare 
      3068928 blocks(总的blocks数量，每个block大小为1KB) super 1.2 level 5(等级), 512k chunk(每个磁盘的小区块大小), algorithm 2 [4/4](需要m个装置，n个装置正常运行，这里是需要4个设备，四个设备状态正常) [UUUU](正常运行，若不正常则为_）
unused devices: <none>

RAID错误的救援模式
mdadm --manage /dev/md[0-9] [--add 设备] [--remove 设备] [--fail 设备]
--------|--add 将后面的设备添加到/dev/md[0-9]之中
--------|--remove 将后面的设备移除
--------|--fail 讲后面的设备配置为出错的状态

/etc/mdadm.conf决定了软件磁盘阵列的配置
mdadm --stop /dev/md[0-9] <==关闭磁盘阵列,如果只是取消挂载的话，在重新分区的时候可能会出现错误

--------------------LVM(Logical Volume Manager)逻辑卷轴管理------------
LVM在于可以弹性的调整文件系统的容量，可以整合多个分区(或硬盘)在一起，让这些分区看起来就像一个硬盘一样！而且，还可以在未来新增或移除其他的实体分区到这个LVM中

Physical Volume,PV 实体卷轴
1.需要在实际分区的基础上通过fdisk调整系统识别码成为8e(LVM的识别码），再通过pvcreate将它转化为LVM最底层的实体卷轴PV

Volume Group,VG 卷轴群组
1.将多个PV组成一个VG，一个VG最多仅能包含65534个PE

Physical Extend,PE,实体延伸区块
1.LVM默认使用4MB的pe区块，而LVM的VG最多仅能含有65534个PE，因此默认的LVM VG会有256G
PE是整个LVM最小的储存单元（类似于block)

Logical Volume, LV,逻辑卷轴
1.VG最终被切割成LV类似于分区，LV的设备名通常为/dev/vgname/lvname


LV是如何写入到硬盘中(默认线性模式)
1.线性模式（linear）：先用前面的设备，当前面的设备容量用完时才用后面的
2.交错模式（triped）：类似于RAID-0

LVM必须要内核支持并且安装lvm2这个程序

1.制作实体卷轴PV
pvcreate：将实体分区创建成为PV  eg: pvcreate /dev/sda{1,2,3}
pvscan：搜索目前系统里面任何具有PV的硬盘或分区
pvdisplay：展示目前系统上面的PV状态
pvremove：将PV属性移除
pvmove: 移动pe <== pvmove src des 

2.创建卷轴群组VG
vgcreate [-s N[mgt]] VG名称 PV名称
--------|-s 后面接PE的大小，mgt为单位（大小写均可）
vgscan:搜索系统上面是否有vg存在
vgdisplay:显示目前的vg状态
vgextend:在VG内添加额外的PV <== vgextend vgname /dev/sda{1,2,3}
vgreduce：在VG内移除pv
vgchange：配置vg是否启动
vgremove：删除一个vg

3.对VG进行分割创建LV
lvcreate [-L N[mgt]] [-n lv名称] vg名称
lvcreate [-l N] [-n lv名称] vg名称
--------|-L 后面接容量，最小单位为PE，因此若不符合pe大小时，系统会采取近似值
--------|-l pe的个数
--------|-n lv的名称
lvscan:查询系统上面的lv
lvdisplay：显示系统上lv的状态  <==第一个指标会显示出LV全名，在使用lv的时候需要用全名，不像vg
lvextend: 在lv中添加容量
lvreduce: 在lv中减少容量
lvremove: 移除整个lv
lvresize 对大小进行调整

扩容vg
1.创pv,pvcreate
2.添加pv,vgextend
3.添加pe,lvresize  <== lvresize -l +-n 增加扩减少pe的个数
4.通过resize2fs来将文件系统扩容
resize2fs [-f] [device] [size]
--------|-f 强制
--------|[device] 设备名称
--------|[size] 加上size则必须要给单位，没有size，则整个分区都使用
减少vg则相反

LVM的作用创建系统快照(系统备份)
系统快照:将当时的系统信息记录下来，未来如果有任何数据的变动，则原始数据会被移动到快照区，而没有被变更的区域则由快照区和文件系统共享
快照和被快照的LV必须在同一个VG中
lvcreate -l 60 -s -n 快照名 lvdir
--------|-s 快照
--------|-n 需要快照的设备名称
--------|-l 多少个pe给快照区使用

利用快照恢复系统


LVM相关命令汇整与LVM的关闭
任务		PV阶段		VG阶段		LV阶段
搜索scan	pvscan		vgscan		lvscan
创建create	pvcreate	vgcreate	lvcreate
列出display	pvdisplay	vgdisplay	lvdisplay
添加extend			vgextend	lvextend
减少reduce			vgreduce	lvreduce
删除remove	pvremove	vgremove	lvremove
改变容量resize					lvresize
改变属性attribute pvchange	vgchange	lvchange
文件阶段改变大小需要resize2fs命令

卸载lvm:
1.移除挂载的lvm和快照
2.lvremove
3.vgchange -a n VGname 让vgname这个VG不再具有active标志
4.vgremove
5.pvremove
6.fdisk修改回来id

========================================例行性工作安排(crontab)============================
at:可以处理仅运行一次就结束安排的命令，不过需要有atd的支持
crontab:所配置的工作将会循环的一直进行下去，也可以编辑/etc/crontab来支持,需要crond这个服务

Linux系统常见的例行性任务有：
1.进行登录文件的轮替（log rotate）
2.登陆文件分析logwatch的任务
3.创建locate数据库（/var/lib/mlocate中)系统会主动进行updatedb
4.wahtis数据库的创建
5.RPM软件登录文件的创建
6.删除缓存文件tmpwatch命令
7.与网络服务有关的分析行为

atd的启动与at运行方式
/etc/init.d/atd restart
chkconfig atd on <==配置启动时自动启动这个服务(RH系列的命令)

at会将工作写入/var/spool/at/下,然后等待atd的调用
1.at先寻找/etc/at.allow这个文件，只有该文件中的使用者才能使用at(即使没有写在/etc/at.deny)
2.如果没有上述文件则查询/etc/at.deny这个文件，若写在这个文件中的使用者则不能使用at，而没有的则可以使用
3.都没有则root才可以使用

at [-mldv] TIME
at -c 工作号码
--------|-m 当at的工作完成后，即使没有输出信息，也会用email的方式通知使用者该工作已完成
--------|-l at -l相当于atq，列出目前系统上面的所有该使用者的at安排
--------|-d at -d相当于atrm，可以取消一个在at安排中的工作
--------|-v 可以使用较明显的时间格式列出at安排中的工作列表
--------|-c 可以列出后面接的该项工作的实际命令内容
TIME 时间格式，这里可以定义出【什么时候要进行at这项工作】的时间，格式有：
HH:MM
	在今天的HH:MM时刻进行，eg04:00，若该时间已经超过，则是明天的这个时候
HH:MM YYYY-MM-DD
	强制规定在这个时间进行工作eg:04:00 2010-10-10
HH:MM[am|pm] [Month] [Date] ex> 04pm March 17
	强制规定在这个时间进行工作
HH:MM[am|pm] + number [minutes|hours|days|weeks]
	在这个时间点之后在上上述时间后才进行可以用now表示当前时间
注意点1：
工作路径决定了at，因此最好使用绝对路径
2.at的运行与终端机环境无关，所有的标准输出或者标准错误输出都会送到运行者的mailbox中

at的工作都是会放在后台执行，因此允许断开连接

atq <==查询所有使用者的at安排
atrm (jobnumber) <==移除该工作

batch:系统有空闲时才执行后台任务
(cpu的工作负荷小于0.8时执行所下达的任务,工作负荷比如执行一个程序时，是接近于1，工作负荷不是cpu使用率)
使用方法如同at

----------------------循环运行的例行性工作安排-----------
如同at的限制
/etc/cron.allow:
/etc/cron.deny:

工作会被记录到/var/spool/cron/下
cron的每一项工作会被记录到/var/log/cron这个文件中


crontab [-u username] [-l|-e|-r]
--------|-u 默认只有root才可以进行这个任务，-u后帮助其他使用者创建或删除crontab工作安排
--------|-l 查看crontab的内容
--------|-e 编辑crontab的内容
--------|-r 移除所有的crontab的内容，若只要移除单独几项，使用-e去编辑

crontab -e后的文件格式
0	12	*	*	*	mail dmtsai -s "at 12:00" < /home/dmtsai/.bashrc
分	时	日	月	周	命令

范围:0-59	0-23	1-31	1-12	0-7(0或7都是星期天)
*  任何时间都接受
,  相同栏目分割如3,6表示3和6都适用
-  时间段如8-12
/n n为数字，每间隔n个单位，如*/5或者0-59/5表示每五分钟

系统的crontab配置文件
/etc/crontab，cron这个服务的最低侦测限制时分钟，所以cron每分钟会读取/etc/crontab和/var/spool/cron里面的内容
文件格式:
SHELL=/bin/bash <==所使用的shell
PATH=... <==运行文件所搜索的路径
MAILTO=root <==将数据发送给谁
HOME=/	<==默认此shell的家目录所在
# m h dom mon dow user	command
   分 时 日 月 周 运行者身份 命令
eg:17 *	* * *	root    cd / && run-parts --report /etc/cron.hourly
/etc/crontab中有两种下达命令的方式
1.命令
2.目录eg:17 * * * *   root    cd / && run-parts --report /etc/cron.hourly  <==每小时17分运行/etc/cron.hourly下的所有可执行程序

注意事项:
1.注意资源分配均匀（不要让动作基本都发生在同一时间)
2.取消不必要的输出项目(利用输出错误重定向/dev/null)
3.安全检查/var/log/cron(记录使用者的crontab的安排)
4.星期与日月不可同时存在（不然只会选择星期或者日月)


anacron:
处理非24小时一直启动的linux系统,一般以天为单位或者启动后立刻执行,会检测关机期间应该运行但是没有运行的crontab，并将任务运行一遍后，anacron就会自动停止
anacron是通过crontab来运行的，它运行的时间通常有两个，一个是系统启动期间运行，一个时写入crontab的安排当中

anacron [-sfn] [job]..
anacron -u [job]..
--------|-s 开始连续的运行各种job，会依据时间记录文件的数据判断是否进行
--------|-f 强制进行，而不去判断时间记录文件的时间戳
--------|-n 立刻进行未进行的任务，而不延迟delay等待时间
--------|-u 仅更新时间记录文件的时间戳，而不进行任何工作
--------|job 由/etc/anacrontab定义的工作名称
/etc/anacrontab的文件格式
1       5       cron.daily      run-parts --report /etc/cron.daily
差异天数(运行后会比较/var/spool/anacron/下对应文件来取出最近一次运行的anacron的时间戳，然后和实际时间相比，差异的天数大于等于该数值时会运行）    延迟命令执行的时间 工作名称定义	实际要运行的命令
天数单位天：延迟单位：分钟：工作名称可以自定义
命令则通常与crontab的配置相同

===========================进程管理与SELinux初探=======================
在Linux上面运行一个命令，系统会将相关的权限，属性，程序代码与数据等均加载到内存中，并给一个PID

工作管理：在bash环境下取得bash shell后在单一终端机下面同时进行多个工作的行为管理，每个工作都是bash的子进程，彼此之间有关联性，无法以工作管理的方式由tty1的环境控制tty2的bash!

注意点:
1.这些工作所触发的程序必须来自于你shell的子进程（只管理自己的bash)
2.前台：可以控制与下达命令的这个环境
3.后台：可以自行运行的工作，无法使用ctrl+c终止它，可以使用bg/fg呼叫
4.后台中运行的程序无法交互

1.command & (将任务放后台运行）会显示该任务的PID，但是输出的时候仍然会输出到屏幕上，因此可以使用重定向
2.将目前的工作丢到后台中stop，ctrl+z
[1]+ Stopped command
[1]表示第一个工作 +表示最近一个被丢进后台的工作且目前在后台下默认会被取用的那个工作（命令fg有关） Stopped:表示这个工作的状态

jobs [-lrs] <==观察目前的背景工作状态
--------|-l 除了列出job number与命令外同时列出PID
--------|-r 仅列出正在后台run的工作
--------|-s 仅列出正在后台当中stop的工作

fg %jobnumber <==拿出后台中+的那个工作放在前台
--------|%jobnumber 为工作的号码，%可有可无
fg -则表示将-(+后续的一个工作)放在前台
fg率先唤醒+这个工作

bg %jobnumber <==让工作在后台的状态下变成运行中

kill -signal %jobnumber <==管理后台当中的工作
kill -l
--------|-l 列出kill能够使用的signal有哪些
--------|signal: man 7 signal
		-1：重新读取一次该进程的配置文件（reload)
		-2：代表由键盘输入ctrl-c一样的动作
		-9：立刻强制删除一个工作
		-15：以正常的程序方式终止一项工作，与-9不同
kill的注意点默认number是pid，需要工作管理的话加上%

上述的后台指的是终端机的后台，而不是系统后台，因此关闭连接后将终止，而at则是将工作放置在系统后台，因此即使关闭连接后仍然能够继续
或者nohup

nohup [命令与参数]  <==在前台
nohup [命令与参数] & <==在后台
nohup不支持bash内建的命令
nohup: 忽略输入并把输出追加到'nohup.out' <==会在工作目录下生成一个nohup.out来记录输出


ps:将某个时间点的程序运行情况截取下来
ps aux <==显示系统所有的进程数据
ps -lA <==同上
ps axjf <==呈现树状
--------|-A 所有的进程均显示出来，与-e一样
--------|-a 不予终端有关的所有进程
--------|-u 有效使用者相关的进程
--------|x 通常与-a这个参数一起使用，可以列出较为完整的信息
--------|输出格式规划:
		l:较长，较详细的将该PID的信息列出
		j:工作的格式
		-f:做一个更为完成的输出

ps -fl
F S UID        PID  PPID  C PRI  NI ADDR SZ WCHAN  STIME TTY          TIME CMD
0 S abc       6328  6225  0  80   0 -  5841 wait   19:02 pts/1    00:00:00 /bin/bash
F:进程的标识
	4表示权限为root
	若为1则表示子进程仅进行fork复制而没有实际运行exec
S:进程的状态
	R(Running) 
	S(sleep)但是可以被唤醒(singal)
	D:不可被唤醒的睡眠状态，通常这个进程可能在等待IO
	T:停止的状态（stop），可能在工作控制（后台暂停）或除错（traced）状态
	Z(Zombie):僵尸状态，进程已经终止但无法被移除至内存外(僵尸进程，子进程率先结束，但是父进程还没有回收)
C:CPU使用率，单位为百分比
PRI/NI:Priority/Nice的缩写，代表此程序被CPU所运行的优先级，数值越小越快被CPU执行
ADDR/SZ/WCHAN：与内存有关，ADDR是内核功能指出该程序在内存的哪一个部分，如果正在运行的进程一般会显示-，SZ表示用掉了多少内存,WCHAN表示目前进程是否运行中，同样的-表示正在运行
STIME:进程开始的时间
TTY:登录的终端
TIME:用掉的cpu时间，是该进程实际花费cpu的运行时间
CMD:命令(后面加上<defunct>表示僵尸进程)


top:动态观察程序的变化
top [-d 数字] | top [-bnp]
--------|-d 后面可以接秒数，整个程序画面更新的秒数，默认5秒
--------|-b 以批量的方式运行top，通常搭配重定向来导出成文件
--------|-n n为数字,与-b搭配，表示需要top n次的输出
--------|-p 后面接pid指定某些个pid来观察
top运行中可以按的命令:
	?:显示在top当中可以输出的按键命令
	P:以cpu的使用资源排序(默认排序)
	M:以Memory的使用资源排序
	N:以PID排序
	T:由该进程使用的cpu时间累计（TIME+)排序
	k:给某个进程一个信号signal
	r:给某个进程重新制定一个nice值(优先级)
	q:离开

pstree [-A|U] [-up]
--------|-A 各个进程树之间的连接以ASCII的编码来连接
--------|-U 以万国码的编码来连接
--------|-u 同时列出每个进程的PID
--------|-u 同时列出每个进程的拥有者

killall [-iIe] [command name]
--------|-i 互动式，删除时带有提示
--------|-e exact精确的，表示完全匹配后面的command name，但整个命令不能超过15个字节
--------|-I 忽略命令中的大小写

PRI与NI的相关性
PRI(new)=PRI(old)+NI  <==PRI越小越先被执行
但是不是一定会发生变化，取决于系统动态决定的，需要经过系统的分析
NI可以为负数
1.nice的范围-20~19
2.root可以随意调整自己或其他人进程的NICE值，且范围为~20-19
3.一般使用者仅可以调整自己的进程，且范围仅为0-19(避免一般用户抢占系统资源）
4.一般用户尽仅可以讲nice越调越高(优先级越来越后)

nice [-n 数字] command <==新运行的命令给予新的nice值
--------|-n -20~19

renice [number] PID  <==对于已经存在的进程重新调整nice

free [-b|-k|-m|-g] [-t] <==观察内存使用情况
--------|-b 默认是KB,b(B),m(MB),g(GB)
--------|-t 显示实际的内存和swap（虚拟内存）的总量

uname [-asrmpi] <==查阅系统和内核相关信息
--------|-a 所有系统相关的信息，包括地下的数据都会被列出
--------|-s 系统内核名称
--------|-r 内核的版本
--------|-m 本系统的硬件名称：如x86_64
--------|-p cpu的类型
--------|-i 硬件的平台

uptime <==查看系统启动时间和工作负载

load average: 0.55, 0.38, 0.16
		1    5     15分钟的平均负载

netstat [-atunlp]
--------|-a 目前系统上所有的连接、监听、socket都列出
--------|-t 列出tcp网络封包的数据
--------|-u 列出udp网络封包的数据
--------|-n 不以进程的服务名称，而以端口号显示
--------|-l 列出目前正在网络监听的程序
--------|-p 列出该网络服务的进程pid
封包协议|接收队列|发送队列|本地ip和端口号|远程主机的ip和端口号|连接状态，创建（ESTABLISED）及监听（LISTEN）
Proto   | Recv-Q | Send-Q |Local Address |Foreign Address     |   State      
tcp        0      0 192.168.1.105:42776     211.159.235.143:http    TIME_WAIT  

socket file的输出栏有
Proto RefCnt(连接到此socket的数量) Flags       Type(确认连接STREAM与不需确认的DGRAM)       State(若CONNECTIED则表示多个进程之间已经连线创建)         I-Node   Path
unix  2      			   [ ]         DGRAM                  			  						             29510    /run/user/1000/systemd/notify


dmesg <==内核启动时的信息

vmstat <==侦测系统资源的变化
vmstat [-a] [延迟的秒数 [总计侦测次数]] <==CPU/memory等信息
vmstat [-fs] <==内存相关信息
vmstat [-S 单位] 配置显示数据的单位
vmstat [-d] 与硬盘有关
vmstat [-p 分区] 与硬盘有关
--------|-a 使用inactive/active(活跃与否),取代buffer/cache的内存信息
--------|-f 启动到目前位置系统fork的进程数
--------|-s 将一些事件（启动至目前为止）导致的内存变化列出
--------|-S k/m/g取代Ｂ
--------|-d 列出硬盘的读写总量统计
--------|-p 后面列出分区，可以显示该分区的读写总量
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 5755208  57588 1729412  0    0   201    29   86  402  1  0 98  1  0
内存栏位（procs)的项目分别为
r:等待运行中的进程数量　b:不可被唤醒的进程数量
内存栏位（memory)的项目分别为
swpd:虚拟内存使用量	free:未被使用的内存量	buff:用于缓冲区的内存	cache:用于高速缓存
内存交换区（swap）的项目分别为
si:由硬盘中将进程读取的量	so:由于内存不足而将没有使用到的进程信息写入到硬盘的swap的容量
硬盘读写（io)的项目分别为
bi:从硬盘中读取的区块数量 	bo:写入到硬盘的区块数量
系统（system)的项目分别为
in:每秒被中断的进程数	cs:每秒钟进行的事件切换次数
cpu的项目分别为
us:非内核层的cpu使用状态	sy:内核层所使用的cpu状态	id:闲置的状态	wa:等待IO所消耗的cpu状态	st:虚拟机所使用的cpu状态


/proc记录了进程信息
/proc/1/cmdline:记录了这个进程被启动的命令
/proc/1/environ:记录了这个进程的环境变量内容
/proc/cmdline:加载内核时所下达的相关参数！查阅此文件，可以了解系统时如何启动的
/proc/cpuinfo:cpu的相关信息
/proc/devices:记录了系统各个主要设备的主要设备号
/proc/filesystems:目前系统已经加载的文件系统
/proc/interrupts:目前系统上面的中断请求分配状态
/proc/ioports:系统上面各个设备所配置的IO为地址
/proc/kcore:内存的数据
/proc/loadavg:top以及uptime,上面的三个平均值记录在这(1 5 15分钟时的平均负载)
/proc/meminfo:使用free列出的内存信息
/proc/modules:目前系统加载的模块列表
/proc/mounts:已经挂载的数据,mount命令后显示的数据
/proc/swaps:系统挂载的内存，使用掉的分区就记录在这里
/proc/paritions:fdisk -l的结果
/proc/pci:在pci总线上面，每个装置的详细信息，可以用lspci查询
/proc/uptime:使用uptime的结果
/proc/version:uname -a的结果，系统内核版本
/proc/bus/*:一些总线的设备，还有u盘也会记录

fuser [-umv] [-k [i] [-signal]] file/dir <==根据文件找出正在使用此文件的进程
--------|-u 除了进程的pid外还显示该进程的拥有者
--------|-m 指定一个挂载文件系统上的文件或者被挂载的块设备（名称name）。这样所有访问这个文件或者文件系统的进程都会被列出来。如果指定的是一个目录会自动转换成"name/",并使用所有挂载在那个目录下面的文件系统。  
--------|-v 列出每个文件和进程还有命令的完整信息
--------|-k 找出使用该文件或目录的pid，并视图以sigkill这个信号给予该进程
--------|-i 必须与-k配合使用，在删除pid之前询问使用者
--------|-signal: -1 -15，默认-9

			用户  进程号 权限   命令
/root:               root      13393 ..c.. (root)bash
权限:c 此进程在当前的目录下
     e 可被触发为运行状态
     f 是一个被开启的文件
     r 代表顶层目录/
     F 该文件被开启了，不过在等待回应
     m 可能为分享的动态库

lsof [-aUu] [+d] <==列出被进程所开启的文件名
--------|-a 多项数据需要同时列出时(比如lsof -u root lsof -U)
--------|-U 仅列出unix like系统的socket文件
--------|-u 后面接username，列出使用者相关进程开启的文件
--------|+d 后面接目录，找出该目录下已经被开启的文件

pidof [-sx] program_name <==找出正在运行的进程的PID
--------|-s 仅列出一个pid而不是所有的pid
--------|-x 同时列出该进程的父进程的pid

===========================SELinux(Security Enhanced Linux)=====================
背景:
ubuntu默认是不安装selinux的。未证实的消息，selinux是由NSA部门开发的(斯诺登的那个部门)，据说是有后门的，参与过棱镜门计划，会收集隐私。虽然并未有实际的证据证明这个论点，但是SELINUX最近的确状况堪忧，并不像你想的那么安全，已经被爆出不少绕过selinux安全认证的漏洞。

ubuntu是使用了一个apparmor这样的简易权限控制工具代替selinux功能,see: https://wiki.ubuntu.com/AppArmor


SELinux:在进行进程、文件等细部权限配置依据的一个内核模块
传统的文件权限（某个进程想要对文件进行存取时，系统会根据进程的拥有者/用户组来比对文件的权限)叫做自主式存取控制(Discretionary Access Control,DAC)

SELinux添加了委任式存取控制（Mandatory Access Control,MAC)
控制的主体不再是传统的用户了而是进程，目标则是该进程能否读取的文件资源
主体（subject):
	process
目标（Object):
	文件系统
政策（Policy):
	在CentOS 5.x里仅有提供两个主要的政策（政策下面有rule守则可以制定不同的服务开放某些资源的存取）
	targeted:针对网络服务限制较多，针对本机限制较少，默认
	strict:完整的SELinux限制，限制方面较为严格
安全性上下文(security context):
	主体（会一同加载进内存)与目标(inode)的安全性上下文一致才能顺利存取(但最终还需要通过rwx来决定)

ls -Z可以列出安全性上下文
root:object_r:user_home_t
身份识别：角色：类型
身份识别:
	root:表示root的账号身份
	system_u:进程
	user_u:一般使用者
角色:
	object_r:文件或目录等文件资源
	system_r:进程
类型:
	在主体和目标的定义不同
	主体（进程）domain（领域）
	目标（文件）type(类型)

在targeted政策下的意义
root		system_r	代表在root账号登录时所取得的权限
system_u	system_r	由于为系统账号，因此是非交互式的系统运行程序
user_r		system_r	一般可登录用户的进程


SELinux支持的三种模式
enforcing:强制模式，代表SELinux运行中，并且开始限制domain/type
permissive:宽容模式，代表SELinux运行中，不过仅会有警告不会实际限制domain/type的存取，这种模式可以作为debug
disabled:关闭

getenforce  <==列出目前的SELinux模式
sestatus [-vb] <==SELinux的政策
	--------|-v 检查/etc/sestatus.conf内的文件与进程的安全性上下文内容

	--------|-b 将目前政策的守则值列出来，也就是某些守则是否要启动（0/1)
	SELinux的配置文件/etc/selinux/config
	setenforce [0|1] <==设置SELinux的模式
	--------|0 permissive模式
	--------|1 enforcing模式

==================================================系统服务（daemons）（守护进程）=============
daemon的分类:
1.stand_alone:此daemon可以自行单独启动的服务
	优点：一直存在内存内持续的提供服务
	常见的有www的daemon（httpd)FTP的daemon（vsftpd)
2.super daemon:一个特殊的daemon来统一管理(早期是inetd管理，后来被xinetd取代)
	当没有客户端的请求时，各项服务都是未启动的情况，等有客户端的请求时，super daemon才会唤醒相应的服务，当请求结束后，被唤醒的服务随着关闭并释放系统资源
	常见的有telnet	


通过窗口类型来探讨两种daemon的区别:
1.个别窗口负责单一服务的stand_alone（如存钱窗口)
2.统一窗口负责各种业务的super daemon（如大堂经理）
	处理模式也有两种:
	1.multi-threaded(多线程):
		全部的客户请求都拿来，一次给他处理，所以一个服务会同时负责好几个进程
	2.single-threaded(单线程):
		排队

daemon的工作形态的类型
	1.signal-control:
		只要有任何客户端的需求进来，就会立即启动去处理eg:打印机的服务
	2.interval-control
		每隔一段时间主动运行某个工作，eg atd和crond

daemon的命令规则(通常在服务的名称后面加上一个d，daemon)


/etc/services记录了端口号和服务的对应关系
/var/run/下记录了daemon启动后所获取的进程PID
/etc/init.d/*:启动脚本
/etc/sysconfig/*:各服务的初始化环境配置文件
/etc/xinetd.conf /etc/xinetd.d/*:super daemon配置文件
/etc/*:各项服务的配置文件
/var/lib/*:各项服务产生的数据

两种启动方式
一:

1.Stand alone的/etc/init.d/* 启动脚本
2.service [service name] (start|stop|restart|...) (其实是一个shell文件)
service --status-all
--------|service name 需要启动的服务名称需要与/etc/init.d/下面对应
--------|start|... 该服务要进行的工作
--------|--status-all 所有的stand alone的服务状态列出

二:
super daemon的启动方式
super daemon本身是一个stand alone方式的服务，但所管理的其他daemon则不同，必须要在配置文件/etc/xinetd.d/*启动才行

/etc/xinetd.d/*要是没有相关配置会参考/etc/xinetd.conf

vim /etc/xinetd.conf
defaults
{
# 服务启动成功或失败，以及相关登陆行为的记录文件
	log_type        = SYSLOG daemon info  <==登录文件的记录服务类型
        log_on_failure  = HOST   <==发生错误时需要记录的信息为主机 (HOST)
        log_on_success  = PID HOST DURATION EXIT <==成功启动或登陆时的记录信息
	# 允许或限制联机的默认值
        cps         = 50 10 <==同一秒内的最大联机数为 50 个，若超过则暂停 10 秒
        instances   = 50    <==同一服务的最大同时联机数
        per_source  = 10    <==同一来源的客户端的最大联机数
	# 网络 (network) 相关的默认值
        v6only          = no <==是否仅允许 IPv6 ？可以先暂时不启动 IPv6 支持！
	# 环境参数的配置
        groups          = yes
        umask           = 002
}

includedir /etc/xinetd.d <==更多的配置值在 /etc/xinetd.d 那个目录内

/etc/xinetd.d/*的文件格式
service <service_name>
{
#	xinetd的管理参数 参数的配置方法
	<attribute>	<assign_op>	<value>		<value>...
	....
}
assign_op:
1.=:
	表示后面的配置参数如下	
2.+=:
	增加新的参数
3.-=:	
	舍弃的参数

attribute(属性)					说明
1.一般配置项目:服务的识别、启动与程序
disable				配置值[yes|no]默认yes
id(服务识别）			配置值[服务的名称]A
server(程序文件名)		配置值[程序的绝对路径]
server_args(程序参数)		配置值[程序的相关参数]
user(服务所属UID)		配置值[使用者的UID]
group				如同user
2.一般配置项目:联机方式与联机封包协议
socket_type(封包类型)		配置值[stream|dgram|raw]
				stream为联机机制较为可靠的tcp封包,udp则是dgram，raw表示服务需要直接与ip连接
protocol(封包类型)		配置值[tcp|udp]
wait(联机机制）			配置值[yes(single)|no(multi)]默认wait=no
				单线程与多线程，一般udp为yes，tcp为no
instances(最大联机数)		配置值[数字或UNLIMITED]
				该服务可以接受的最大联机数量
per_source(单一用户来源)	配置值[数字或UNLIMITED]
				控制每个来源ip仅能有一个最大的同时联机数
cps(新联机限制)			配置值[两个数字]
				第一个数字表示一秒内最大新联机数，第二个数字表示超过后暂时关闭该服务的秒数
3.一般配置项目:登陆文件的记录
log_type(登录文件类型)		配置值[登录项目 等级]
				当数据记录时以什么登录项目记录并且登录的等级，默认info
log_on_success
log_on_failure(登录状态)	配置值[PID,HOST,USERID,EXIT,DURATION]
				exit:离开的时候记录的项目
				duration：使用此项服务的时间
4.进阶配置项目:环境、网络端口和联机机制等
env(额外变量配置)		配置值[变量名=变量内容]
port(非正规端口号)		配置值[一组数字（小于65534）]服务名需要和/etc/services相同，若是自定义的服务，则可以随意制定
redirect(服务转址)		配置值[ip port]
				将客户端的请求转移到另外一台主机上这个ip就是另一台远程主机的ip和端口号
includedir(呼叫外部配置)	配置值[目录]
				将某个目录下的所有文件都加入到该文件配置中eg:/etc/xinetd.conf
5.安全控管项目
bind(服务接口锁定)		配置值[ip]
				允许某一个ip（多个ip时）使用该服务
interface			配置值[ip]
				同bind
only_from(防火墙机制)		配置值[0.0.0.0, 192.168.1.0/24, hostname, domainname]
				这有这个的ip或者是主机名才可以登录,0.0.0.0表示所有的pc都可以登录，192.168.1.0/24则表示局域网(192.168.1.1-192.168.1.255都可以登录，也可以选择domainname(域名)
no_access(防火墙机制)		配置值[0.0.0.0, 192.168.1.0/24, hostname, domainname]
				同only_from但是该属性表示不可登录的ip，主机名，域名
access_time(时间控管)		配置值[00:00-12:00, HH:MM-HH:MM]
				配置该服务启动的时间，使用24小时的配置
umask				配置值[000,777,022]建议时022,777-022结果为755(rwxr-xr-x)


任何以xinetd管理的服务，都可以通过/etc/hosts.{allow|deny}来配置防火墙，这两个配置文件同时也是/usr/sbin/tcpd的配置文件
一个服务受到xinetd管理或者一个服务的进程支持TCP Wrappers动态库(libwrap.so)时，该服务的防火墙配置就能够通过/etc/hosts.allow|deny来配置
TCP wrappers控管的是

1.来源ip或与整个网络的ip网段
2.port

ldd(library dependency discovery)可以查询某个进程所用到的动态库

/etc/hosts.allow|deny的文件格式是
启动该服务的程序名:IP或域名或主机名:deny|allow

写在 hosts.allow 当中的 IP 与网段，为默认『可通行』的意思，亦即最后一个字段 allow 可以不用写；
而写在 hosts.deny 当中的 IP 与网段则默认为 deny ，第三栏的 deny 亦可省略；

这两个文件的判断依据是： (1) 以 /etc/hosts.allow 为优先，而 (2) 若分析到的 IP 或网段并没有记录在 /etc/hosts.allow ，则以 /etc/hosts.deny 来判断。通常我们都是：

允许进入的写在 /etc/hosts.allow 当中；
不许进入的则写在 /etc/hosts.deny 当中。

ALL：代表全部的 program_name 或者是 IP 都接受的意思，例如 ALL: ALL: deny
LOCAL：代表来自本机的意思，例如： ALL: LOCAL: allow
UNKNOWN：代表不知道的 IP 或者是 domain 或者是服务时；
KNOWN：代表为可解析的 IP, domain 等等信息时；
