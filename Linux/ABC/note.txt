ctrl+D 从某种程度上等价于exit
man手册中使用/key 向下搜索并标记key
	    ?key 向上搜索并标记key
使用man -k key模糊搜索key

vim使用小结
使用%可查找匹配的括号
使用:%s/old/new/gc 可全文件替换并且给出每一个是否替换的提示

多线程中读写锁:
写 > 读
读可多 写只能一个


/usr/src/linux-headers-4.15.0-29deepin/include/linux

子进程会获取父进程的资源的副本


文件显示命令:
cat less more tac(cat从尾往前) head tail

新建文件:
touch

匹配文件指定内容:
grep

排序:
sort 
uniq(去重)

文件比较:
comm diff

cp mv rm

统计字符wc

 






type [-tpa] name
会显示name是外部命令还是bash内置命令
-t: 以下面字眼显示含义：
	file:外部命令
	alias:命令别名
	builtin:内置命令
-p: name为外置命令时显示完整文件名
-a: 有PATH变量定义的路径中，显示所有name包含alias

echo 输出

变量的设置规则:
----------||需要获得变量的值时使用$变量或者${变量}而用变量自身的时候则无需
----------||和php语法类似"中的$变量"会替换成变量的值
----------||而'中的字符则原样输出'
----------||可以使用转义字符
----------||在使用命令提供的信息时需要加$(command)
----------||变量累加内容的时候使用"$变量"累加内容
----------||export使得变量变成环境变量
----------||取消变量的方法unset 变量名

env列出当前shell环境下所有的环境变量
export

set查看所有变量包括自定义的变量
set [-uvCHhmBx]
---------|u 默认不启用，若启用后，当使用未设置变量时会显示错误信息
---------|v 默认不启用，若启用后，在讯息被输出前，会先显示信息的原始内容
---------|x 默认不启用，若启用后，在命令被执行前，会显示命令内容
---------|h 默认启用，与历史命令有关
---------|H 默认启用，与历史命令有关
---------|m 默认启用，与工作管理有关
---------|B 默认启用，与[]的作用有关
---------|C 默认不启用，使用>等时，若文件存在时，该文件不会被覆盖


$ 本身也是变量，表示当前shell的线程号
? 上一个执行命令的返回值

子进程仅仅会继承父进程的环境变量

export 变量名（让该变量成为环境变量，从而使得子进程可以使用)

locale 查询所支持的语系
read [-pt] variable
----------|p 反面可以接提示符
----------|t 后面可以接等待的秒数

declare\typeset 声明变量的类型
declare [-aixr] variable
---------|a 数组array
---------|i int
---------|x 设置为环境变量
---------|r readonly只读

变量默认类型是文本

变量定义为数组时用${数组元素}读取该元素

ulimit [-SHacdfltu] [配额]
---------|S soft limit 警告的设置，超过改值有警告
---------|H hard limit 严格的设置，必定不会超过这个值
---------|a 列出所有限制配额
---------|c 核心文件的最大容量
---------|f 可以创建文件的最大文件容量单位为KB
---------|d 最大段容量
---------|l 用于锁定(lock)的内存量
---------|u 单一用户最大进程数

变量设置方式					说明
${变量名#关键字}		|若变量从头开始的数据符合关键字，则将符合的最短数据删除
${变量名##关键字} 		|若变量从头开始的数据符合关键字，则将符合的最长数据删除
${变量名%关键字} 		|若变量从尾向前的数据符合关键字，则将符合的最短数据删除
${变量名%%关键字}		|若变量从尾向前的数据符合关键字，则将符合的最长数据删除
${变量名/旧字符串/新字符串}	|若变量内容符合旧字符串，则第一个旧字符串将替换成新的
${变量名//旧/新}		|旧全换新

str:代表str未设置或者str为空字符串 
var=${str-expr} 代表str未设置时var=expr,否则var=str 
var=${str?expr} 不存在时输出expr，否则等于str

命令别名alias 取消命令别名unalias
history [n] [-c] [-raw] histfiles
---------|n 是数字，显示最新n行命令
---------|c 清空
---------|a 将目前新增的history里的命令放入到histfiles中，若没有histfiles则默认写入~/.bash_history
---------|r 将history里的数据读到history记忆中
---------|w 将目前history记忆写入到histfiles中
histfiles中的数据条数与环境变量HISTSIZE有关

!number 执行第几条命令
!str 向前查找最近一次以str开头的command命令并执行
!! 执行上一条命令

利用type -a command 可以知道命令执行的顺序
source 或者. 都可以将配置文件读到目前shell环境中

ssty [-a]显示所有终端机参数

通配符
*
?
[]
[1-9][a-b]
[^]

;连续命令执行分隔符
``中间为可以先执行的命令可以用$()代替
()中间为子shell的起始与结束
{}中间为命令块的组合

数据流重定向
标准输入0
标准输出1
标准错误输出2
/dev/null将吃掉任何导向这个设备的信息
<<是代表结束输入的意思
eg:
   << "eof" 则输入eof则代表输入了ctrl+d

cmd ; cmd （不考虑命令相关性的连续命令执行)
cmd1 && cmd2 若cmd1执行完毕并且正确（$?=0)，则开始执行cmd2
||则相反

&& ||是利用了前面命令的返回值$?来判断的

|管道：仅仅会处理前面命令的标准输出，而不会处理标准错误输出
       后面的命令必须可以接收标准输入

cut -d'分割字符' -f fields <==用于分割字符
cur -c 字符范围 <==用户排列整齐的信息
cut [-dfc]
--------|d 后面接分割字符，与-f一起使用
--------|f 依据-d划分数段后，用-f取出第几段
--------|c 以字符的单位取出固定字符区间
eg: cut -c 10-20 取出10-20字符区间内容
cut在处理多个空格分割的文件时比较吃力

grep [-acinvAB] [--color=auto] '查找字符串' filename
--------|a 将二进制文件以text文件的方式查找数据
--------|c 计算找到的次数
--------|i 忽略大小写
--------|n 附加输出行号
--------|v 反向选择，即显示出没有'查找关键字'的哪一行
--------|--color=auto 将关键字高亮显示
--------|A 后面接数字为after，后续n行也显示
--------|B 后面接数字为before，前面n行也显示

sort [-fbMnrtuk] [file or stdin]
--------| f 忽略大小写
--------| b 忽略最前面的空格部分
--------| M 以月份的名字来排序
--------| n 使用纯数字排序（默认是文本排序）
--------| r 反向排序
--------| u 去重
--------| t 分隔符，默认是[tab]分割
--------| k 以哪一个区间来进行排序(和-t联合使用)

uniq [-ic]
--------|i 忽略大小写
--------|c 进行计数 
使用uniq的时候需要先排序

wc [-lwm]
--------|l 仅列出列
--------|w 仅列出字（英文单字）
--------|m 多少字符

tee [-a] file 双向重定向
--------|a 以累加的方式增加数据到file

tr 可以删除一段信息中的文字，或者进行文字的替换
tr [-ds] SET1
--------|d 删除信息当中set1这个字符串
--------|s 替换掉重复的字符串

col [-xb]
--------|x 将[tab]替换成对等的空格
--------|b 在文字有反斜杠/时，仅保留/最后接的字符

join [-ti12] file1 file2 相同数据加在一起
--------|t join默认以空格符分隔数据，并且对比“第一个字段”的数据,如果两个文件相同，则将两条数据连接在一行，且第一个字段放在第一个
--------|i 忽略大小写
--------|1 代表第一个文件要用哪一个字段来分析
--------|2 代表第二个文件要用哪一个字段来分析

paste [-d] file1 file2
--------|d 后面可以接分隔符，默认以[tab]划分
--------|- 如果file写成-,则表示来自于标准输入的数据

expand 将[tab]转换成空格
expand [-t] file
--------|t 后面可以接数字，一个[tab]可以用8个空格替换，也可以自定义
unexpand则相反

split [-b1] file PREFIX
--------|b	后面可以接想要切割成文件的大小，可以加单位：b，k，m
--------|l	以行数进行切割
--------|PREFIX	代表前导符号，可作为切割文件的前导文字

xargs 产生某个命令的参数
xargs [-0epn] command
--------|0 如果输入的stdin含有特殊字符，例如`,\,空格等字符时，这个参数可以将它还原成一般字符，这个参数可以用于特殊状态
--------|e (EOF)的意思，后面接一个字符串，这个字符串代表EOF
--------|p 在执行每个命令的参数时，都会询问用户
--------|n 后面接次数，每次command时，要使用几个参数的意思

-的作用将标准输入与标准输出用-代替:eg 234行


正则表达式:
--------------------------------------------------------------------------------
特殊符号:	代表意义							|
[:alnum:]	代表英文大小写字符和数字 0-9A-Za-z				|
[:alpha:]	代表任何英文大小写字符a-z A-Z					|
[:blank:]	代表空格键和[tab]						|
[:cntrl:]	代表控制键CR,LF,Tab,Del等					|
[:digit:]	代表数字							|
[:graph:]	除了空格符号（空格键和[Tab])外其他所有按键			|
[:lower:]	代表小写字符							|
[:print:]	代表任何可以被打印出来的字符					|
[:punct:]	代表标点符号							|
[:upper:]	代表大写字符							|
[:space:]	任何会产生空白的字符 空格 [tab] CR				|
[:xdigit:]	十六进制的数字类型						|
行首字符^ 行尾字符$								|
[^a-z]不是a-z									|
.任意一个字符									|
*重复前一个字符0次到无数次							|
{m,n}连续m-n个前一个字符							|
										|		
基础正则表达式字符								|	
---------------------------------------------------------------------------------
|^word 		以word为行首				  			|
|word$ 		以word为行尾				  			|
|.		匹配任意一个字符			  			|	
|\		转义字符				  			|
|*		重复上一个字符0到无数次			  			|
|[list]		如[agc] 匹配a或g或c			  			|
|[n1-n2]		匹配n1-n2的字符范围		  			|
|[^list]	与list取反				  			|
|\{m,n\}	重复上一个字符m到n次,\{m\}重复m次上一个，\{m,\}重复m到正无穷次  |
---------------------------------------------------------------------------------
