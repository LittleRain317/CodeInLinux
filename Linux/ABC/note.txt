ctrl+D 从某种程度上等价于exit
man手册中使用/key 向下搜索并标记key
	    ?key 向上搜索并标记key
使用man -k key模糊搜索key

vim使用小结
使用%可查找匹配的括号
使用:%s/old/new/gc 可全文件替换并且给出每一个是否替换的提示

多线程中读写锁:
写 > 读
读可多 写只能一个


/usr/src/linux-headers-4.15.0-29deepin/include/linux

子进程会获取父进程的资源的副本


文件显示命令:
cat less more tac(cat从尾往前) head tail

新建文件:
touch

匹配文件指定内容:
grep

排序:
sort 
uniq(去重)

文件比较:
comm diff

cp mv rm

统计字符wc

 






type [-tpa] name
会显示name是外部命令还是bash内置命令
-t: 以下面字眼显示含义：
	file:外部命令
	alias:命令别名
	builtin:内置命令
-p: name为外置命令时显示完整文件名
-a: 有PATH变量定义的路径中，显示所有name包含alias

echo 输出

变量的设置规则:
----------||需要获得变量的值时使用$变量或者${变量}而用变量自身的时候则无需
----------||和php语法类似"中的$变量"会替换成变量的值
----------||而'中的字符则原样输出'
----------||可以使用转义字符
----------||在使用命令提供的信息时需要加$(command)
----------||变量累加内容的时候使用"$变量"累加内容
----------||export使得变量变成环境变量
----------||取消变量的方法unset 变量名

env列出当前shell环境下所有的环境变量
export

set查看所有变量包括自定义的变量
set [-uvCHhmBx]
---------|u 默认不启用，若启用后，当使用未设置变量时会显示错误信息
---------|v 默认不启用，若启用后，在讯息被输出前，会先显示信息的原始内容
---------|x 默认不启用，若启用后，在命令被执行前，会显示命令内容
---------|h 默认启用，与历史命令有关
---------|H 默认启用，与历史命令有关
---------|m 默认启用，与工作管理有关
---------|B 默认启用，与[]的作用有关
---------|C 默认不启用，使用>等时，若文件存在时，该文件不会被覆盖


$ 本身也是变量，表示当前shell的线程号
? 上一个执行命令的返回值

子进程仅仅会继承父进程的环境变量

export 变量名（让该变量成为环境变量，从而使得子进程可以使用)

locale 查询所支持的语系
read [-pt] variable
----------|p 反面可以接提示符
----------|t 后面可以接等待的秒数

declare\typeset 声明变量的类型
declare [-aixr] variable
---------|a 数组array
---------|i int
---------|x 设置为环境变量
---------|r readonly只读

变量默认类型是文本

变量定义为数组时用${数组元素}读取该元素

ulimit [-SHacdfltu] [配额]
---------|S soft limit 警告的设置，超过改值有警告
---------|H hard limit 严格的设置，必定不会超过这个值
---------|a 列出所有限制配额
---------|c 核心文件的最大容量
---------|f 可以创建文件的最大文件容量单位为KB
---------|d 最大段容量
---------|l 用于锁定(lock)的内存量
---------|u 单一用户最大进程数

变量设置方式					说明
${变量名#关键字}		|若变量从头开始的数据符合关键字，则将符合的最短数据删除
${变量名##关键字} 		|若变量从头开始的数据符合关键字，则将符合的最长数据删除
${变量名%关键字} 		|若变量从尾向前的数据符合关键字，则将符合的最短数据删除
${变量名%%关键字}		|若变量从尾向前的数据符合关键字，则将符合的最长数据删除
${变量名/旧字符串/新字符串}	|若变量内容符合旧字符串，则第一个旧字符串将替换成新的
${变量名//旧/新}		|旧全换新

str:代表str未设置或者str为空字符串 
var=${str-expr} 代表str未设置时var=expr,否则var=str 
var=${str?expr} 不存在时输出expr，否则等于str

命令别名alias 取消命令别名unalias
history [n] [-c] [-raw] histfiles
---------|n 是数字，显示最新n行命令
---------|c 清空
---------|a 将目前新增的history里的命令放入到histfiles中，若没有histfiles则默认写入~/.bash_history
---------|r 将history里的数据读到history记忆中
---------|w 将目前history记忆写入到histfiles中
histfiles中的数据条数与环境变量HISTSIZE有关

!number 执行第几条命令
!str 向前查找最近一次以str开头的command命令并执行
!! 执行上一条命令

利用type -a command 可以知道命令执行的顺序
source 或者. 都可以将配置文件读到目前shell环境中

ssty [-a]显示所有终端机参数

通配符
*
?
[]
[1-9][a-b]
[^]

;连续命令执行分隔符
``中间为可以先执行的命令可以用$()代替
()中间为子shell的起始与结束
{}中间为命令块的组合

数据流重定向
标准输入0
标准输出1
标准错误输出2
/dev/null将吃掉任何导向这个设备的信息
<<是代表结束输入的意思
eg:
   << "eof" 则输入eof则代表输入了ctrl+d

cmd ; cmd （不考虑命令相关性的连续命令执行)
cmd1 && cmd2 若cmd1执行完毕并且正确（$?=0)，则开始执行cmd2
||则相反

&& ||是利用了前面命令的返回值$?来判断的

|管道：仅仅会处理前面命令的标准输出，而不会处理标准错误输出
       后面的命令必须可以接收标准输入

cut -d'分割字符' -f fields <==用于分割字符
cur -c 字符范围 <==用户排列整齐的信息
cut [-dfc]
--------|d 后面接分割字符，与-f一起使用
--------|f 依据-d划分数段后，用-f取出第几段
--------|c 以字符的单位取出固定字符区间
eg: cut -c 10-20 取出10-20字符区间内容
cut在处理多个空格分割的文件时比较吃力

grep [-acinv] [--color=auto] '查找字符串' filename
--------|a 将二进制文件以text文件的方式查找数据
--------|c 计算找到的次数
--------|i 忽略大小写
--------|n 附加输出行号
--------|v 反向选择，即显示出没有'查找关键字'的哪一行
--------|--color=auto 将关键字高亮显示
