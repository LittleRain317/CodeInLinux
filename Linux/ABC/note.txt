第一部份：Linux的规划与安装
第二部份：Linux文件、目录与磁盘格式
第三部份：学习Shell与Shell Scripts
第四部份：Linux使用者管理
第五部份：Linux系统管理员
第六部份：其他备份文章


-------------------------计算机概论-----------------------------
芯片组通常分为两个桥接器来控制各组件的通信
（1）北桥负责连接速度较快的CPU，内存与显卡等组件；
（2）南桥负责连接速度较慢的周边接口，包括硬盘，USB,网卡等

库函数调用系统调用　
系统调用调用内核函数

一般来说操作系统会提供开发接口，让开发商制作他们的驱动程序
驱动程序与开发商有关，与操作系统的开发者无关

BIOS(Basic Input Output System)是一套程序，这套程序是写死在主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录，那就是只读存储器
操作系统（系统调用和内核）

IDE硬盘		/dev/hd[a-d]
SCSI/SATA/U盘	/dev/sd[a-p]
U盘		/dev/sd[a-p]
软盘		/dev/fd[0-1]
打印机		ｕ盘/dev/usb/lp[0-15]
		25针/dev/lp[0-2]
鼠标		Ｕ盘/dev/usb/mouse[0-15]
		ps2:/dev/psaux
当前的鼠标	/dev/mouse

磁盘的第一个扇区主要记录了两个重要的信息
1.主要启动记录区MBR：可以安装启动管理程序的地方，有446Bytes
2.分区表:记录整个磁盘分区的状态，有64bytes(四组记录,四个分区,每组记录了该区段的起始和结束的柱面号)


分区的一些限制:
1.主分区和扩展分区共计4个
2.扩展分区最多只有一个
3.逻辑分区是扩展分区继续划分出来的
4.扩展分区无法格式化

分区注意点,如果扩展分区被破坏，那么所有的逻辑分区都会被删除，因为逻辑分区的分区表记录在扩展分区里面

启动流程到操作系统之前的动作:
BIOS:启动主动运行的程序，会识别第一个可启动的设备
MBR:第一个可启动设备的第一个扇区内的主要启动记录区块，内含启动管理程序
启动管理程序(Boot loader):一个可读取内核文件来运行的软件
内核文件(操作系统内核):开始操作系统的功能

Boot loader的任务:
提供菜单:使用者可以选择不同的启动项目
加载内核文件:直接指向可启动的程序段开始操作系统
转交其他loader:将启动管理功能转交

每个分区都有自己的启动扇区(boot sector)
实际可启动的内核文件都是放在各个分区内

shutdown [-t 秒] [-arkhncfF] 时间[警告信息]
-t sec: -t后面加秒数，过sec秒后关机
-k    :	发送警告消息，不关机
-r    :	在将系统的服务停掉后就重新启动
-h    : 在将系统的服务停掉后就立即关机
-n    : 不经过init程序，直接以shutdown的功能来关机
-f    : 关机并启动之后，强制略过fsck的磁盘检查
-F    : 系统重新启动后，强制进行fsck的磁盘检查
-c    : 取消已经在进行的shutdown命令内容
时间  : 一定要加的参数！指定系统关机时间

run level 0:关机
run level 3:纯文本模式
run level 5:含有图形接口模式
run level 6:重新启动

man手册中的操作
空格		向下翻一页
[page down]	向上翻一页
[page up]	向下翻一页
[home]		回退第一页
[end]		去最后一页
/string		向下查找
?string		向上查找
n,N		移动查找结果的光标

man [-fk] [n]
-f	:显示工具和工具的简单说明等价于whatis	
n	:显示哪一页的man手册
-k	:搜索有关key的手册

\[enter]使命令连续到下一行

---------------------------linux基本命令------------------------------
date 
cal
bc
[Ctrl]+c	中断
[Ctrl]+d	终止输入


linux文件权限与目录配置----------------------------------|
/etc/passwd 记录系统上的账户和账户信息
/etc/shadow 记录个人密码
/etc/group  记录用户组

chgrp	[-R]	dirname/filename...
-R		:递归修改

chown	修改文件所属者
chown owner:group filename

chmod	修改文件权限
rwx:(三个bit对应三个状态有无)
chmod [-R] 文件或目录
-R		:递归修改

chmod | u | + | r | file/dir
      | g | - | w |
      |	o | = | x |
      |	a |   |   |

权限对于文件的重要性
r	可读
w	可编辑，新增修改（但不含删除）
x	可执行

权限对于目录的重要性
r	可以查询当前目录下的文件名数据
w	可以修改目录结构的权限（建立新文件或目录，删除已经存在的目录或文件，重命名，移动）
x	代表用户是否让该目录成为自己的工作目录,同时决定了能够使用该目录下的程序

文件种类:
1.正规文件:属性[-]
	纯文本文件ascii
	二进制文件binary
	数据格式文件data 通过特定程序来读取

2.目录:属性[d]
3.连接（类似于快捷方式):属性[l]
4.设备文件:
	块设备[b]:成组的设备比如硬盘
	字符设备[c]:串行端口的借口设备，特点一次性读取，不能截断
5.数据接口文件sockets:属性[s]
6.管道文件pipe:属性[p] 特点FIFO

重要的目录
/lost+found	这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分区的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』
/proc	这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统内核、进程信息(process)、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。
/sys	这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。 包括目前已加载的内核静态库与内核侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！
/etc：配置文件
/bin：重要执行档
/dev：所需要的设备文件
/lib：执行档所需的函式库与内核所需的静态库
/sbin：重要的系统执行

/bin主要放置在开机时，以及进入单人维护模式后还能够被使用的指令，至于/usr/bin则是大部分软件提供的指令放置处。

. 当前目录
.. 上级目录
- 前一个目录
~ 当前用户的home目录
~account account的home目录


pwd [-P]
--------|-p 显示出确实的路径，而非使用链接路径(默认会显示链接路径)

mkdir [-mp] 目录名称
--------|-m 配置文件的权限，直接配置，不需要看默认权限umask的脸色
--------|-p 递归创建

rmdir [-p] 空目录名称
--------|-p 递归删除

会根据PATH的设置，来决定率先使用哪一个命令
使用绝对路径或相对路径直接指定某个命令的档名来运行，会比搜寻PATH来的正确

ls [-aAdfFhilnrRSt] 目录名称
ls [--color={never,auto,always}] 目录名称
ls [--full-time] 目录名称
--------|-a 全部的文件，连同隐藏文件
--------|-d 仅列出目录本身，而不列出目录内的数据文件
--------|-l 长数据列出，包含文件的属性和权限等
--------|常用

--------|-A 全部的文件，但不包括. 和..
--------|-f 直接列出结果，而不进行排序（默认以文档名排序)
--------|-F 根据文件、目录等，赋予附加的数据结构（如/代表目录)
--------|-h 将文件容量以人类较易读的方式列出来
--------|-i 列出inode号码
--------|-n 列出UID和GID而非使用者和用户组的名字
--------|-r 将排序结果反向输出
--------|-R 递归列出
--------|-S 以文件大小排序，而不是以文件名排序
--------|-t 根据时间排序
--color=never:不要依据文件特征给出颜色显示
--color=always:显示颜色
--color=auto:让系统自行依据配置判断是否显示颜色
--full-tile:显示完整时间（年月日时分)
--time={atime,ctime}:输出访问access时间或改变权限属性时间(ctime)而非内容变更的时间(modification time)

cp [-adfilprsu] source destination
cp [options] source1 source2 source3... directory
--------|-a 相当于-pdr
--------|-d 若来源属于链接，则赋值链接而非文件本身
--------|-f 强制，若目标文件已经存在且无法开启，则移动后再尝试一次
--------|-i 若目标文件已经存在，则询问是否覆盖
--------|-l 进行硬链接的链接创建，而非复制文件本身
--------|-p 连同文件属性一起赋值，而非使用默认属性(备份常用)
--------|-r 递归复制
--------|-S 赋值为符号链接
--------|-u 若des比src旧才升级des

rm [-fir] 文件或目录
--------|-f 强制，忽略不存在的文件，没有警告信息
--------|-i 删除前询问
--------|-r 递归删除

\command 将会忽略掉alias的指定选项

mv [fiu] src des
mv [options] src1 src2 src3 ... des
--------|-f 强制，若目标文件存在，不会问询直接覆盖
--------|-i 若des存在，则询问是否覆盖
--------|-u 若des已经存在，且src较新，则升级update des

basename 获取文件名
dirname 获取目录名

cat [-AbEnTv]
--------|-A 相当于-vET,可列出一些特殊字符
--------|-b 列出行号，仅针对非空行号
--------|-E 将结尾的换行字节$显示出来
--------|-n 连同空行一起显示行号
--------|-T 将[tab]以^|显示出来
--------|-v 显示出特殊字符


nl [-bnw] 文件
--------|-b 指定行号方式，-b a：表示不论空行同样显示行号，-b t:有空行忽略显示行号（默认)
--------|-n 列出行号的方式，-n ln:行号最左边显示,rn最右边显示且不用0占位，rz用0占位，最右边显示
--------|-w 行号栏位的占用的位数如让行号占4位 -w 4

more内的操作
space:向下翻页
Enter:向下翻一行
/key:向下查找key
:f :显示文档名和当前行数
q 退出
b 回翻


less内的操作
space：向下翻一页
[pagedown]：等同于space
[pageup]：向上翻一页
/key
?key
n :重复前一个搜索
N :反向重复前一个搜索
q 退出


head [-n number] 文件
--------|-n 后面接数字，代表显示几行的意思
	    number为负数时，表示后面number行都不显示，只显示前面的


tail [-n number] 文件
--------|-n 后面接数字，代表显示几行
--------|-f 表示持续侦测后面所接的文件，要等到按下[ctrl]+c才会结束侦测(当数据更新时实时显示)
基本等同于head，只是方向相反


ob [-t Type] 文件
--------|-t a:利用默认字符输出
	    c:利用ascii字符输出
	    d[size] 利用十进制来输出数据，每个输出数据占用size 字节（以size字节来读取原始文本)
	    f[size]
	    o[size]
	    x[size]
最左边第一栏是以8进制显示的字节数

------------------------------------------------------------
modification time(mtime):默认
当前文件的内容变更时，会变更这个时间，内容指的是文件的内容而不是文件的属性或者权限
status time(ctime):
当该文件的状态改变时，比如权限或者属性被更改时，才会修改这个时间
access time(atime):
当文件的内容被读取时（文件被访问时），这个时间才会被修改
-------------------------------------------------------------



touch [-acdmt] 文件
--------|-a 仅修改访问时间
--------|-c 仅修改文件时间，若文件不存在则不创建文件
--------|-d 后面可以接想要修改的日期而不用目前的日期，也可以用--date="时间或日期"
--------|-m 仅修改modifytime（文件内容修改时间)
--------|-t 后面接想要修改的时间，格式为[YYMMDDhhmm]

默认权限umask -S（以可读形式展现)
umask(以数字，需要减掉的权限显示)
默认文件没有x权限，目录有x权限
eg:umask 
结果为0022 (022) user group other
		 0    2     2 //在777减去022
		 7    7     7
		 7    5     5 //实际权限
		 rwx  r-x   r-x


文件的隐藏属性
chattr(只能在Ext2/Ext3的文件系统上生效)
chattr [+-=] [ASacdistu] 文件或目录名
--------|+ 添加一个特殊参数
--------|- 移除一个特殊参数
--------|= 赋予权限
==========
--------|A 当配置了A属性时，若有存取此文件（或目录）时，它的存取时间atime将不会被修改，可避免I/O较慢的机器过度的存取磁盘。这对速度较慢的计算机有帮助
--------|S 一般文件是非同步写入磁盘的，如果加上S这个属性时，当你进行任何文件的修改，该改动会同步写入到磁盘中（sync)
--------|a 这个文件只能添加数据，不能删除也不能修改数据，只有root才能配置该权限
--------|c 将会自动将此文件压缩，在读取的时候自动解压缩，但是在存储的时候，将会先进行压缩然后再存储（对于大文件来说有用)
--------|d 当dump程序被运行的时候，配置d将可以使得该文件（目录）不会被dump备份
--------|i 让一个文件不能被删除、改名、配置连接也无法写入或新增数据!只有root可以配置，对系统安全性有强大的帮助
--------|s 如果这个文件被删除，它将会被完全的移除这个硬盘中，所以误删没有办法救回来
--------|u 与s相反，删除后，文件还留在硬盘中

lsattr(显示文件隐藏属性)
lsattr [-adR] 文件或目录
--------|-a 将隐藏文件的属性也显示
--------|-d 仅写出目录本身的属性
--------|-R 递归显示


Set UID
当s这个标志出现在文件拥有者x的权限上时，如/usr/bin/passwd 
[-rwsr-xr-x] 此时就称之为set UID，简称SUID的特殊权限
1.SUID权限仅对二进制程序有效
2.运行者对于该程序需要具有x的可执行程序
3.本权限仅在运行该程序的过程中有效（run-time)
4.运行者将具有该程序拥有者的权限

Set GID
s出现在文件用户组x的权限上
与SUID不同的是，SGID可以针对文件或目录配置
如果是文件:
1.SGID对二进制程序有效
2.程序运行者需要具有x权限
3.运行者在运行时会获得该程序用户组的权限支持
如果是目录:
1.使用者若对该目录具有r和x的权限时，使用者能够进入该目录
2.使用者在此目录下的有效用户组将会变成该目录的用户组
3.用途：若使用者在此目录下具有w权限（可以新建文件），则使用者所创建的新文件，该文件的用户组和此目录的用户组相同权限

Sticky Bit(sticky黏)
SBIT仅针对目录有效
1.当使用者对于该目录有wx权限
2.当使用者在该目录下创建文件或目录，仅有自己和root才有权限删除该文件
如/tmp [drwxrwxrwt]

4为SUDI
2为SGID
1为SBIT
ugb
例如:chmod 4755 test
当本身不具有x的权限时，赋予了UGB的话（实际上是具有空的权限)，其次s和t变成大写的ST

file(查看文件类型)


which(寻找可执行文件)
which [-a] command
--------|-a 显示所有PATH目录中可以找到的命令，而不只是第一个

whereis(寻找文件)(与find搜索磁盘不同，whereis是利用数据库搜索)
whereis [-bmsu] 文件或目录
--------|-b 只查找二进制文件
--------|-m 只找在说明文件manual路径下的文件
--------|-s 只找source来源文件
--------|-u 搜索不在上诉三个项目当中的其他特殊文件

whereis和locate是根据linux系统内记载了所有文件记录的一个数据库文件

locate [ir] keyword
--------|-i 忽略大小写
--------|-r 后面可以接正则表达式的显示方法

手动更新数据库updatedb

find [PATH] [option] [action] -a -o -a连接两个选项 -o或
1.与时间有关的选项-atime -ctime -mtime
	如:
	-mtime n: 在n天之前的一天之内被更改过内容的文件
	-mtime +n: 列出在n天之前（不含n）被更改过内容的文件
	-mtime -n: 列出在n天之内（含n)被更改过内容的文件 
	-newer file: file为一个存在的文件，列出比file还要新的文件
2.与使用者或用户组有关的参数
	-uid n: n为数字，即UID，
	-gid n: n为数字，即GID
	-user name: name为使用者的账户名称
	-group name: 用户组名
	-nouser: 寻找文件的拥有者不存在/etc/passwd 的人
	-nogroup: 寻找文件的用户组不在/etc/group的文件
3.与文件权限及名称有关的参数
	-name filename: 寻找文件名叫filename的文件
	-size [+-] SIZE: 寻找比SIZE还要大(+)或小(-)的文件
			c byte k 1024 bytes 
			eg：[-size +50k] 比50KB还要大的文件
	-type TYPE:一般正规文件f, 设备文件b,c 目录d 链接l 管道s FIFO p等属性	
	-perm mode: 寻找文件刚好等于mode的文件，如-rwsr-xr-x 4755
	-perm -mode: 寻找文件必须要全部包含mode权限的文件(以mode为基准增加0或多个属性)
	-perm +mode: 寻找文件包含任意mode权限的文件(2005后不在支持用--perm /mode替换)
4.额外的动作
	-exec command : command为其他命令 -exec 后面可以接command来处理结果
	-print : 默认动作，打印到屏幕

eg:
[root@www ~]# find / -perm /7000 -exec ls -l {} \;
# 注意到，那个 -exec 后面的 ls -l 就是额外的命令，命令不支持命令别名，
# 所以仅能使用 ls -l 不可以使用 ll 喔！注意注意！
解读:
{} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；
-exec 一直到 \; 是关键字，代表 find 额外动作的开始 (-exec) 到结束 (\;) ，在这中间的就是 find 命令内的额外动作。 在本例中就是『 ls -l {} 』罗！
因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。


权限和命令间的关系
一：让使用者能够进入某个目录成为工作目录的基本权限	
可使用的命令：cd
目录所需权限：x
额外要求：如ls，则需要有r权限
二：使用者在某个目录内读取一个文件的基本权限
可使用的命令:cat,more,less等等
目录所需权限：x
文件所需权限：r
三：让使用者可以修改一个文件的基本权限
可使用的命令：nano或vi或vim
目录所需权限：x
文件所需权限：rw
四：让使用者可以创建一个文件的基本权限
目录所需权限：wx
五：让使用者进入某个目录并且运行该目录下的基本权限
目录所需权限：x
文件所需权限：x

========================================文件系统===============================================================
superblock:记录此文件系统的整体信息，包括inode/block的总量，使用量，剩余量，以及文件系统的格式和相关信息
inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码
block:实际记录文件的内容，若文件太大时，会占用多个block

磁盘碎片整理：因为文件写入的block太过于离散，此时文件读取的效能将会变得很差，这个时候通过碎片整理将同一个文件所属的blocks汇整在一起，加快读取速度

=======================================Ext2文件系统===========================================================
=======================================================================
data block(数据区块)
Ext2文件系统的限制如下
-----------------------------------------------------
|Block 大小	1KB	2KB	4KB		    |
|最大单一文件限制	16GB	256GB	2TB         |
|最大文件系统总容量	2TB	8TB	16TB	    |
-----------------------------------------------------
1.原则上，block的大小与数量在格式化完就不能够再改变了（除非重新格式化）
2.每个block内最多只能放置一个文件的数据
3.承上，如果文件大于block的大小，则一个文件会占用多个block数量
4.承上，如果文件小于block，则该block的剩余容量就不能再被使用了（磁盘空间会被浪费)
=======================================================================
=======================================================================
inode table(inode 表)
inode记录的文件数据至少包含:
1.该文件的存取模式rwx
2.该文件的拥有者和用户组owner/group
3.该文件的容量
4.该文件的创建或状态更改的时间ctime
5.最近一次的读取时间atime
6.最近一次的修改时间mtime
7.特殊文件的标志如setUID
8.文件真正内容的指向(block)

每个inode大小为128bytes(ext2系统)
每个文件只会占用一个inode
文件系统所能创建的文件数量和inode的数量有关
系统读取文件的时候需要先找到inode,并分析inode所记录的权限与用户是否符合，若符合才开始读取block的内容
=======================================================================
=======================================================================
Superblock(超级区块)
1.block和inode的总量
2.未使用和已使用的inode/block数量
3.block和inode的大小(block为1,2,4k，inode为128bytes)
4.文件系统的挂载时间，最近一次写入数据的时间，最近一次检验磁盘（fsck）的时候等文件系统的相关信息
5.一个valib bit数值，若文件系统已被挂载则为0，否则为1

利用dumpe2fs命令查看superblock
可能每个block group都含有superblock，但是一个文件系统应该仅有一个superblock而已，因为，其他的block group若含有的话，主要是为了第一个block group内的superblock的备份
=======================================================================
=======================================================================
Filesystem Description(文件系统描述说明)
描述每个block group的开始和结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block)分别介于哪一个block号码之间，同样利用dump2fs查看
=======================================================================
=======================================================================
block bitmap(区块对照表)
利用位图算法来判断哪一个block可以用
inode bitmap(inode对照表)
利用位图算法来判断哪一个inode可以用
=======================================================================
=======================================================================
dumpe2fs[-bh] 设备文件名
--------|-b 列出保留为坏轨的部分（一般用不到）
--------|-h 仅列出superblock的数据

=======================================================================





新增一个文件时，文件系统的行为：
现根据用户对于新增文件的目录是否有wx权限，若有才能新增
根据inode bitmap查找没有使用的inode号码，并且根据umask将新文件的权限/属性写入
根据block bitmap查找没有使用的block号码，将实际的数据写入，并且更新inode里block指向数据
将刚写入的block和inode写入inode bitmap和block bitmap，并更新superblock的内容

superblock,inode bitmap, block bitmap 中间数据metadata
=======================================================================
在上古时期，没有日志，若发生数据不一致，需要检查中间数据（即superblock inodebitmap和blockbitmap）和实际数据的一致性，所以文件系统越大，时间越长
=======================================================================
日志式文件系统
1.预备：当系统要写入一个文件的时候，先在日志记录区块中记录某个文件准备要写入的信息
2.实际写入：开始写入文件的权限和数据,开始更新metadata的数据（509-513行的行为)
3.结束：完成数据和metadata更新后，在日志记录区块中完成该文件的记录
=======================================================================
系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读写
可以手动使用sync来强迫内存中配置为dirty的文件（文件内容被修改）写入到硬盘里
若正常关机时，关机命令会主动执行sync来将内存的数据写入到硬盘中
若不正常关机，由于数据尚未写会到硬盘中，因此重启后可能会花很多时间进行磁盘检查，甚至可能导致文件系统的损坏
=======================================================================


df [-ahikHTm] [目录或文件名]
--------|-a 列出所有的文件系统，包括系统特有的/proc等文件系统
--------|-h 以人类较易读的方式gb，kb，mb
--------|-i 不使用硬盘容量，而以inode的数量来显示
--------|-k 以kB来显示各个文件系统
--------|-H 以M=1000K取代M=1024K
--------|-T 连同该分区的文件系统名称也列出来
--------|-m 以MB来显示各个文件系统

/dev/shm是利用内存虚拟出来的硬盘空间
1.访问速度快
2.关机后消失

du [-ahskm] 文件或目录名称
--------|-a 列出所有的文件和目录的容量，因为默认统计目录底下的目录量而已
--------|-h 以人类较易读的方式
--------|-s 列出总量，而不列出各个目录所占用的容量
--------|-S 不包括子目录下的统计
--------|-k 以kB
--------|-m 以mB

hard link的限制:
不能跨越文件系统
不能link目录

ln [-sf] 来源文件 目的文件
--------|-s 软连接，默认硬链接
--------|-f 如果目标文件存在，则主动将目标文件删除后在创建

fdisk [-l] 设备名称 <==制作分区
--------|-l 输出后面接的设备所有的分区内容，若仅有fdisk -l时，则系统将会把整个系统内能够搜索到的设备的分区均列出来
fdisk的限制：没有办法处理2TB以上的硬盘分区表

mkfs [-t 文件系统格式] 设备名称
--------|-t 如ext3, ext2, vfat等

mke2fs [-b block大小] [-i block大小] [-L 标头] [-cj] 设备
--------|-b 可以设置每个block的大小，1024,2048,4096bytes
--------|-i 多少容量给予一个inode
--------|-c 检查硬盘错误，仅使用一次-c时，会进行快速读取测试，如果-c -c 则会测试读写，较慢
--------|-L 标头名称，
--------|-j 加上journal

磁盘检查fsck,badblocks

fsck [-t 文件系统] [-ACay] 设备名称 （检验文件系统是否出错，数据将会放在lost+found）
--------|-t 如同mkfs根据-t选项调用不同的文件系统程序
--------|-A 根据/etc/fstab的内容，将设备进行扫描，通常启动过程中会运行这一命令
--------|-a 自动修复检查到的有问题的扇区
--------|-y 与-a类型，但是某些文件系统仅支持-y
--------|-C 显示检测进度
EXT2/EXT3的额外选项功能(e2fsck所提供)
--------|-f 强制检查！一般来说，如果fsck没有发现任何unclean的标志，不会主动进入细部检查
--------|-D 针对文件系统下的目录进行优化配置


badblocks [-svw] 设备名称	（用于检查硬盘或软盘扇区有没有坏轨）
--------|-s 在屏幕上列出进度
--------|-v 可以在屏幕上看到进度
--------|-w 使用写入的方式来测试，不建议使用，尤其是待检查的设备已有文件时


mount [-a] [-l] [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 设备文件名 挂载点
--------|-a 依照配置文件/etc/fstab的数据将所有未挂载的硬盘都挂载上来
--------|-l 单纯的输入mount会显示目前挂载的信息，加上-l可以显示label名称
--------|-t 与mkfs的选项非常类似，可以加上文件系统种类来指定想要挂载的类型
--------|-n 在默认的情况下，系统会将实际挂载的情况实时写入/etc/mtab中,以利其他程序的运行，但是在某些情况下（如单人维护模式）为了避免问题，会可以不写入，此时就需要用-n
--------|-L 系统除了利用设备文件名之外，还可以利用文件系统的标头名称Label来挂载，最好为文件系统取一个独一无二的名称
--------|-o 后面可以接一些挂载时额外的参数，比如账号，密码，读写权限等
	    ro,rw: 挂载文件系统成为只读，或可读写
	    async,sync: 此文件系统是否使用同步写入sync或一部async的内存机制，请参考文件系统运行方式，默认为async
	    auto,noauto: 是否允许此分区被mount -a自动挂载
	    dev,nodev: 是否允许此分区上，可以创建设置文件
	    suid,nosuid: 是否允许此分区上拥有suid/sgid的文件格式
	    exec,noexec: 是否允许此分区上拥有可执行程序
	    user,nouser: 是否允许此分区让任何使用者运行mount，一般来说mount只有root可以运行，但有user参数时，则一般用户也可以进行mount对于此分区
	    defaults: rw,suid,dev,exec,auto,nouser,and async
	    remount: 重新挂载，在系统错误，或重新升级时使用
	    -o的参数以,间隔

umount [-fn] 设备或挂载点
--------|-f 强制卸载，可以用在类似于网络文件系统NFS无法读取的情况下 
--------|-n 不更新/etc/mtab下卸载

主要设备代码（major） 次要设备代码（minor)
eg: ll /dev/sda*
磁盘文件名	Major	Minor
/dev/hda	3	0~63
/dev/hdb	3	64~127
/dev/sda	8	0-15
/dev/sdb	8	16-31

当需要创建设备文件时
mknod 设备文件名 [bcp] [Major] [Minor]
--------|b 配置设备名称成为一个周边存储设备，如硬盘
--------|c 配置设备名称成为一个周边输入设备，如鼠标/键盘
--------|p 配置设备名称成为一个FIFO文件(管道文件)
Major: 主要设备代码
Minor: 次要设备代码

e2label 修改文件系统label(文件系统的label类似于win上面的C: d: E:)
e2label 设备名称 新的label名称

tune2fs [-jlL] 设备名称
--------|-j 将ext2转换为ext3文件系统
--------|-l 类似dumpe2fs -h将superblock内的数据读取出来
--------|-L 类似e2label修改设备的label

硬盘为IDE接口时使用hdparm,如果是SATA接口这个命令没有多大用途
hdparm [-icdmXTt] 设备名
--------|-i 将内核检测到的硬盘参数显示出来
--------|-c 配置32位存储模式，这个32位存储模式指的是在硬盘与PCI接口之间传输的模式，而硬盘本身依旧以16位跑的，默认情况下，这个配置值都会被使用
--------|-d 配置是否激活dma模式，-d1为启动，-d0为取消
--------|-m 配置同步读取多个扇区的模式，一般来说，配置此模式，可降低系统因为读取硬盘而损耗的性能，不过wd的硬盘则不建议配置，一般来说，配置为16/32为优化，不过wd硬盘默认是4/8,这个值的最大值可以用hdparm -i /dev/hda 输出的MaxMultSect来配置
--------|-x 配置UtraDMA模式，一般来说，UDMA的模式值加64即为配置值。并且，硬盘和主板芯片必须同步，所以，取最小的那个，一般来说
	33 MHz DMA mode 0~2(x64~x66)
        66 MHz DMA mode 3~4 (X67~X68)
        100MHz DMA mode 5   (X69)
        如果您的硬盘上面显示的是 UATA 100 以上的，那么配置 X69 也不错！
--------|-T 测试缓冲区cache的存取性能
--------|-t 测试硬盘的实际存取性能


/etc/fstab 是启动时的配置文件，不过，实际文件系统的挂载是记录到/etc/mtab与/proc/mounts这两个文件当中的

partprobe 更新分区表

制作swap分区 使用硬盘充当内存，暂时空出内存给更需要内存的程序使用
mkswap 设备名
free 查看系统中内存情况
swapon 使用交换分区

du查看某个目录所使用的容量

parted 分割2TB以上的分割槽
parted [设备] [命令 [参数]]
-------- 选项与参数：
	 命令功能:
	 新增分割: mkpart [primary][logical][extended] [ext3|vfat] 开始 结束
	 删除分割: rm [partition]
	 打印分割表: print


常见的压缩文件扩展名
*.Z		compress 程序压缩的文件
*.gz		gzip 程序压缩的文件
*.bz2		bzip2 程序压缩的文件
*.tar		tar 程序打包的数据，并没有进行压缩
*.tar.gz 	tar 程序打包的文件，其中并且经过gzip的压缩
*.tar.bz2	tar 程序打包的文件，其中并且经过bzip2的压缩

======================================压缩命令=========================
compress [-rcv] 文件或目录 (不再使用，而常用gzip，默认情况下压缩后源文件不见，压缩文件命名为basename.Z)
--------|-r 连同目录下的文件一同压缩
--------|-c 将压缩数据输出成为标准输出
--------|-v 可以展示出压缩后的文件信息以及压缩过程中一些文件名的变化
解压uncompress

------------------------
gzip [-cdtv#] 文件名 (压缩为*.gz)
--------|-c 默认情况将压缩的数据标准输出，可以通过重定向来处理到输出一个文件
--------|-d 解压缩的参数
--------|-t 可以用来检验一个压缩档的一致性，看文件有无错误
--------|-v 可以显示出源文件/压缩文件的压缩比等信息
--------|-# 压缩等级，-1最快但压缩比差，-9最慢但是压缩比好，默认-6

zcat 将解压的数据标准输出

bzip2 [-cdkzv#] 文件名
bzcat 文件名.bz2
--------|-c 将压缩的数据标准输出
--------|-d 解压缩
--------|-k 保留原始文件，而不会删除原始文件
--------|-z 压缩的参数
--------|-v 可以显示出压缩比等信息
--------|-# 同gzip，-9最佳

tar [-j|-z] [cv] [-f 创建的档名] filename <==打包与压缩
tar [-j|-z] [tv] [-f 创建的档名] <==查看档名
tar [-j|-z] [xv] [-f 创建的档名] [-C 目录] 解压缩
--------|-c 创建打包文件，可以搭配-v来观察过程中打包的档名filename
--------|-t 观察打包文件的内容含有哪些档名
--------|-x 解打包或解压缩的功能，可以搭配-C（大写）在特定目录解开
	    注意！！！-c,-t,-x不可同时出现
--------|-j 通过bzip2压缩或者解压缩,*.tar.bz2
--------|-z 通过gzip压缩或者解压缩，*.tar.gz
--------|-v 将正在处理的文件显示出来
--------|-f filename : -f后面要接要被处理的档名
--------|-C 目录: 在特定目录下解压

--------|-p 保留备份数据的原本权限和属性，常用于备份(-c)重要的配置文件
--------|-P 保留绝对路径,即运行备份数据中含有根目录存在
--------|--exclude=FILE 在压缩的过程中，不要将FILE打包

压缩:tar -jcv -f filename.tar.bz2 要被压缩的文件或目录
查询:tar -jtv -f filename.tar.bz2
解压缩:tar -jxv -f filename.tar.bz2 -C 想要解压到的文件目录
filename.tar.bz2为自己取的文件名
tar并不会主动产生文件

解压缩单独某个文件
tar -jxv -f filename.tar.bz2 等待解压缩的指定文件名

dump [-Suvj] [-level] [-f 备份档] 待备份数据
dump -W
--------|-S 仅列出后面的数据需要多少空间才能备份完
--------|-u 将这次dump的时间记录到/etc/dumpdates文件中(现在为/var/lib/dumpdates)
--------|-v 将dump的文件过程显示出来
--------|-j 加入bzip2的支持，默认压缩等级为2
--------|-level -0~-9十个等级
--------|-f 类似于tar，后面接产生的文件，也可以接设备名
--------|-W 列出/etc/fstab里面的具有dump配置的分区是否有备份过

当用dump备份目录时，-u level1~9不适用
使用restore恢复dump的备份

restore -t [-f dumpfile] [-h] 查看dump文件
restore -C [-f dumpfile] [-D 挂载点] 比较dump与实际文件
restore -i [-f dumpfile] 进入互动模式
restor -r [-f dumpfile] 还原整个文件系统
如同tar中-cx不能混用
--------|-t 此模式用在观察dump起来的备份文件中含有什么重要数据如同tar -t
--------|-C 列出dump文件内有记录的，且与目前文件系统不同的文件
--------|-i 可以仅还原部分文件，用在dump备份目录时
--------|-r 用在针对文件系统时全部还原
--------|-h 查看备份数据中inode和文件系统label等信息
--------|-f 后面接要处理的dump文件
--------|-D 与-C搭配使用，查看后面接的挂载点与dump内的不同文件

mkisofs [-o 镜像文件] [-rv] [-m file] 待备份文件.. [-V vol] \
> -graft-point isodir=systemdir ... <==制作镜像文件
--------|-o 后面接要产生的镜像文件名
--------|-r 通过Rock Ridge阐述支持Unix/linux的文件数据，可以记录较多的咨询
--------|-v 显示过程
--------|-m file 排除该文件类似exclude
--------|-V vol 创建Volume，类似win上文件管理里面看到的CD title
--------|-graft-point 将systemdir备份到isodir中

cdrecord -scanbus dev=ATA <==查询刻录机的位置
cdrecord -v dev=ATA:x,y,z blank=[fast|all] 抹除重复读写片
cdrecord -v dev=ATA:x,y,z -format 格式化DVD+RW
cdrecord -v dev=ATA:x,y,z [可用选项功能] file.iso
--------|-scanbus 扫描可用的刻录机，后续的装置为ATA界面
--------|-v 显示过程
--------|dev=ATA:x,y,z 后续的xyz为系统刻录机所在的位置
--------|blank=[fast|all] blank为抹除可重复读写的CD/DVD-RW,使用fast较快，all较完整
--------|-format 仅针对DVD+RW这个格式的DVD
-----------------------写入cd/dcd时使用
--------|-data 指定后面的文件以数据格式写入，而不是以CD音轨的方式写入
--------|speed=x 制定刻录速度
--------|-eject 指定刻录后自动退出光盘
--------|fs=Ym 指定多少缓冲内存
-----------------------写入dvd的选项
--------|driveropts=burnfree 打开buffer underrun free模式写入
--------|-sao 支持DVD-RW格式

dd if="input file" of="output file" bs="block size" count="number blocks"
将inputfile输出到outputfile，bs规定block的大小，count规定block的个数
if或of可以为设备名，复制的时候会将整个设备所有数据都复制，意味着包括文件系统,包括MBR与分区表，包括superblock，boot sector，meda data

cpio -ovcB > [file|device] <==备份
cpio -ivcdu < [file|device] <==还原
cpio -ivct < [filedevice] <==查看
--------|-o 将数据copy输出到文件或装置
--------|-B 让blosks可以添加至5120bytes

--------|-i 将数据自文件或设备copy出来到系统当中
--------|-d 自动创建目录
--------|-u 以较新文件覆盖旧文件
--------|-t 配合-i,观察

--------|-v 显示过程
--------|-c 新的便携式格式存储

vimtutor命令具有vim的操作说明
============================vim编辑器=================================
1.一般模式（进入后的默认模式)
2.指令模式:/?进入
3.编辑模式

----------------------------移动光标的方法-----------------------------
|h        光标向左移动一个字符					      |
|j  	  光标向下移动一个字符					      |
|k        光标向上移动一个字符					      |
|l 	  光标向右移动一个字符					      |
|n+[hjkl] 移动n个字符在对应方向					      |
|ctrl+f   向下移动一页Page down					      |
|ctrl+b	  向上移动一页Page Up					      |
|ctrl+d   向下移动半页						      |
|ctrl+u   向上移动半页						      |
|+	  光标移动到非空格符的下一行				      |
|-	  光标移动到非空格符的上一行				      |
|n<space> 光标向右移动n个字符					      |
|0或Home  移动到这一行的最前面字符处				      |
|$或End	  移动到这一行的最后面字符处				      |
|H        移动到这个屏幕的最上方那一行的第一个字符		      |
|M	  移动到这个屏幕的中央那一行的第一个字符		      |
|L	  移动到这个屏幕的最下方那一行的第一个字符	 	      |
|G	  移动到这个文件的最后一行				      |
|nG	  移动到第n行						      |
|gg	  移动到第一行						      |
|n<enter> 向下移动n行						      |
-----------------------------------------------------------------------
----------------------------搜索与替换---------------------------------
|/key	  向下寻找key字符串					      |
|?key	  向上寻找key字符串					      |
|n	  重复前一个搜索动作					      |
|N	  反向重复前一个搜索动作				      |
|:n1,n2s/word1/word2/g 	n1到n2行之间将word1替换成word2		      |
|			不完全匹配，即string若搜索/str会标记string    |
|:1,$s/word1/word2/g	第一行到最后一行将word1替换成word2	      |
|:1,$s/word1/word2/gc	给出提示是否要替换从第一行到最后一行的word1   |
-----------------------------------------------------------------------
---------------------------删除，复制与粘贴----------------------------
|x,X	  x删除光标的那个字符，X删除光标前的一个字符		      |
|nx       从光标起删除n个字符					      |
|dd	  删除光标所在这一行					      |
|ndd      删除光标开始的n行					      |
|d1G      删除光标所在到第一行的所有数据			      |
|dG       删除光标所在到最后一行的所有数据			      |
|d0       删除光标所在到该行的最前面那个字符			      |
|d$	  删除光标所在到该行的最后那个字符			      |
|yy       复制光标这一行					      |
|nyy      复制光标开始的n行					      |
|y1G      复制光标所在到第一行的所有数据			      |
|yG       复制光标所在到最后一行的所有数据			      |
|y0       复制光标所在到该行的最前面那个字符                          |
|y$       复制光标所在到该行的最后那个字符			      |
|p,P      p粘贴到光标后面，P则为光标前面			      |
|J        将光标所在行和下一行合并为一行                              |
|c        重复删除多个数据,cn[hjkl]				      |
|u	  撤销上一个动作					      |
|ctrl+r   恢复上一个动作					      |
|.        重复上一个动作                                              |
-----------------------------------------------------------------------
!!!!!!!! x d删除| y复制| p粘贴| u撤销| ctrl+r恢复| .重复|可以接0$nG
--------------------------进入插入或替换的编辑模式---------------------
|i,I	  i在光标所在位置插入，I在光标所在行首插入		      |
|a,A      a在光标后一个字符插入，A在光标所在行尾插入                  |
|o,O      o在光标所在行的下方另起一行，O则相反			      |
|r,R      r替换光标所在的那个字符，R从光标开始处一直替换到输出了ESC   |
-----------------------------------------------------------------------
--------------------------指令的存储和离开等---------------------------
|:w	  保存							      |
|:w!      强制写入，不过到底能不能取决于文件权限                      |
|:q       退出                                                        |
|:q!	  曾修改过文件但是不保留强制退出                              |
|:wq      储存后离开                                                  |
|ZZ       储存后离开						      |
|:w [filename] 另存为						      |
|:r [filename] 读取文件到光标所在行的后面			      |
|:n1,n2 w [filename] n1到n2行的内容另存为			      |
|:!command 暂时离开vim，执行command命令                               |
-----------------------------------------------------------------------
-------------------------区块选择的按键意义----------------------------
|v	  字符选择	 					      |
|V        行选择						      |
|ctrl+v   区块选择	 					      |
|y	  复制							      |
|d	  删除							      |
-----------------------------------------------------------------------
-------------------------多文件编辑的按键------------------------------
|:n       编辑下一个文件				              |
|:N	  编辑上一个文件					      |
|:files	  列出vim所开启的全部档案 	  			      |
-----------------------------------------------------------------------
-------------------------多窗口情况下的按键功能------------------------
|:vs [filename] 横向分屏					      |
|:sp [filename]	开启一个新窗口，若不加filename则同步显示(纵向分屏)    |
|ctrl+w+j	移动到下面的窗口				      |
|ctrl+w+k	移动到上面的窗口				      |
|ctrl+w+q	:q						      |
-----------------------------------------------------------------------

=========================vim 的环境设定参数============================
:set nu
:set nonu	就是设定与取消行号啊！
:set hlsearch
:set nohlsearch	hlsearch 就是 high light search(高亮度搜寻)。 这个就是设定是否将搜寻的字符串反白的设定值。默认值是 hlsearch
:set autoindent
:set noautoindent	是否自动缩排？autoindent 就是自动缩排。
:set backup	是否自动储存备份档？一般是 nobackup 的， 如果设定 backup 的话，那么当你更动任何一个档案时，则源文件会被另存成一个档名为 filename~ 的档案。 举例来说，我们编辑 hosts ，设定 :set backup ，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的档案，记录原始的 hosts 档案内容
:set ruler	还记得我们提到的右下角的一些状态栏说明吗？ 这个 ruler 就是在显示或不显示该设定值的啦！
:set showmode	这个则是，是否要显示 --INSERT-- 之类的字眼在左下角的状态栏。
:set backspace=(012)	一般来说， 如果我们按下 i 进入编辑模式后，可以利用退格键 (backspace) 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以透过 backspace 来设定啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！
:set all	显示目前所有的环境参数设定值。
:set	显示与系统默认值不同的设定参数， 一般来说就是你有自行变动过的设定参数啦！
:syntax on
:syntax off	是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本档时，如果开头是以 # 开始，那么该行就会变成蓝色。 如果你懂得写程序，那么这个 :syntax on 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本档案，要避免颜色对你的屏幕产生的干扰，则可以取消这个设定 。
:set bg=dark
:set bg=light	可用以显示不同的颜色色调，预设是『 light 』。如果你常常发现批注的字体深蓝色实在很不容易看， 那么这里可以设定为 dark 喔！试看看，会有不同的样式呢！
======================================================================
文件换行符的区别
dos2unix [-kn] file [newfile] <==dos转unix
unix2dos [-kn] file [newfile] <==unix转dos
--------|-k 保留该文件原来的mtime时间格式（不更新文件上次内容更改的时间)
--------|-n 保留原始文件的旧档，将转换后的内容输出到新文件eg:dos2unix -n old new


iconv --list
iconv -f 原本编码 -t 新编码 filename [-o newfile]
--------|--list 列出iconv所支持的语系编码
--------|-f from,来源，后面接原本的编码格式
--------|-t to,新的编码格式
--------|-o file, 保留源文件，-o输出到新文件

======================================================================

===============================bash====================================
/etc/shells 记录了有几个可以用的shells
登录后会根据/etc/passwd文件的配置给我们一个默认的shell

alias 命令别名
eg:alias rm='rm -i'

=======================================
type [-tpa] name
--------| 显示name是内建命令还是外部命令
--------|-t file为外部命令，alias为别名，builtin为内建命令
--------|-p 为外部命令时，显示完整文件名
--------|-a 由PATH定义的路径下，将所有name的命令都列出来包括alias


变量作为左值直接使用
变量作为右值$var 或者${var}

变量名称只能是英文或者数字，不能以数字开头
''内特殊字符仅为一般的字符（纯文本）
""内特殊字符如$，可以保有原来的特性

\转义字符

$(command)或者`comman`率先执行命令

在为变量扩增内容时，注意使用"$变量"或者${变量}，因为直接使用会和后面的内容产生歧义，认为一同是变量名

export 使得变量成为环境变量
export后面不加变量名，会显示所有的环境变量
一般情况下，父进程自定义的变量无法给子进程使用，但是可以使用export
子进程仅会继承父进程的环境变量，而不会继承父进程的自定义变量

unset 取消变量

env 查看环境变量

常见的环境变量
HOME  		用户家目录
SHELL 		说明所使用的SHELL是哪一个程序
HISTSIZE	记录历史命令的个数
MAIL		使用mail命令收信时，会使用该MAIL变量来获取邮件信箱
PATH		运行文件搜索的路径，目录与目录直接以:间隔
LANG		语系数据
RANDOM 		随机数变量,可以获取0-32767之间
$ 		目前这个shell所使用的PID
?		命令的返回值
PS1		命令提示符
OSTYPE,HOSTTYPE,MACHTYPE:(主机硬件与核心等级)
-		set的配置

关于PS1的配置
\d		显示出星期 月 日 eg:"Mon Feb 2"
\H		完整的主机名
\h		主机名在第一个小数点之前的名字
\t		24小时[HH:MM:SS]
\T		12小时[HH:MM:SS]
\A		24小时[HH:MM]
\@		12小时[am/pm]
\u		使用者用户名
\v		BASH的版本信息
\w		完整的工作目录名，以根目录写起
\W		利用basename获取工作目录，所以只会列出最后一个目录名
\#		下达的第几个命令
\$		提示字符：root为#，否则为$



使用set查看所有变量（包含自定义变量)

locale -a 显示linux所支持的语系
locale 通过显示的结果可以确定修改哪一个变量
LANG=en_US                   <==主语言的环境
LC_CTYPE="en_US"             <==字符(文字)辨识的编码
LC_NUMERIC="en_US"           <==数字系统的显示信息
LC_TIME="en_US"              <==时间系统的显示数据
LC_COLLATE="en_US"           <==字符串的比较与排序等
LC_MONETARY="en_US"          <==币值格式的显示等
LC_MESSAGES="en_US"          <==信息显示的内容，如菜单、错误信息等
LC_ALL=                      <==整体语系的环境


语系文件放置在/usr/lib/locale/下

read [-pt] var   <==结果放在var这个变量
--------|-p 后面接提示符
--------|-t 等待的秒数

declare [-aixr] var
--------|-a 定义变量为数组
--------|-i 定义变量为整形
--------|-x 与export类似，将变量变成环境变量
--------|-r 设置为readonly，该变量不可被修改也不可以被unset
--------|+[aix] 取消对应变量的类型定义
--------|-p 打印变量的类型
变量的类型默认为字符串，bash的数值运算只能是int

数组元素作为左值var[index]
数组元素作为右值${var[index]}

ulimit [-SHacdfltu] [配额]  <==linux的一些限制
--------|-S soft limit,警告的配置，能超过这个值但是会有警告
--------|-H hard limit,不能超过这个配置
--------|-a 显示所有限制额度
--------|-c 限制core文件的大小
--------|-f 创建的文件最大容量，单位为KB
--------|-d 段错误容量
--------|-l 锁定lock的内存量
--------|-t 最大的cpu时间单位秒
--------|-u 单一用户最大进程数

变量的配置方法		说明
${变量#key}		若变量从头开始符合key，则删除最短的符合数据
${变量##key}		若变量从头开始符合key，则删除最长的符合数据
${变量%key}		若变量从尾向前符合key，则删除最短的符合数据
${变量%%key}		若变量从尾向前符合key，则删除最长的符合数据
${变量/old/new}		若变量内容符合old，则将第一个old替换成new
${变量//old/new}	若变量内容符合old，则将全部old替换成new

变量设置方式		str没有设置	str为空字符串	str已设置且不为空字符串
var=${str-expr}		var=expr	var=		var=$str
var=${str:-expr}	var=expr	var=expr	var=$str
var=${str+exprt}	var=		var=expr	var=expr
var=${str:+expr}	var=		var=		var=expr
var=${str=expr}		str=expr	str不变		str不变
			var=expr	var=		var=$str
var=${str:=expr}	str=expr	str=expr	str不变
			var=expr	var=expr	var=$str
var=${str?expr}		expr输出至stderr var=		var=$str
var=${str:?expr}	expr输出至stderr expr输出至stderr var=$str

${}上述都会导致var的变量变化除?

-的作用str没有设置var则为expr
=的作用str没有设置则str也为expr
+的作用是说str设置了则var=expr(与-相反)
?的作用与标准输出有关

:的作用是将str为空串视为没有设置

alias,unalias设置命令别名、取消命令别名

history [n]
history [-c]
history [-raw] file
--------|n 显示最近的n个命令
--------|-c 将目前shell中所有history内容都清空
--------|-a 将新增的history命令写入到file中，默认写入~/.bash_history
--------|-r 将file的内容读到shell的history记忆中
--------|-w 将history的内容写入到file中,默认~/.bash_history

!number
!command
!!
-------|number 运行第几个命令
-------|command 由最近的命令向前搜索以command开头的那个命令，并运行
-------|!!	运行上一个命令

-----------------------配置文件---------------------------------------

/etc/issue 决定了进站信息
/etc/issus.net 是提供给telnet这个远程登录程序使用的

issue内的代码意义
\d	本地端时间的年月日
\l	显示第几个终端机接口
\m	显示硬件的等级
\n	显示主机的网络名称
\o	显示域名
\r	操作系统版本(uname -r)
\t	本地端的时分秒
\s	操作系统的名称
\v	操作系统的版本

/etc/motd 决定了用户登录后，显示的信息

login shell以及non-login shell(不需要重复登录的举动，如在x window登录后启动终端)
login shell:流程1./etc/profile 系统整体的配置
		2.~/.bash_profile或~/.bash_login或~/.profile属于使用者个人配置


source 配置文件   <==加载配置文件

non-login shell:仅仅会读取~/.bashrc

/etc/man.config记录了man手册到哪里寻找

~/.bash_logout 注销bash后，系统做完什么后离开

stty [-a]  <==终端机的环境配置
--------|-a 列出所有参数

stty 配置项 配置值 <==配置特殊热键

set [-uvCHhmBx]  <==配置整个命令的输入输出环境
--------|-u 默认不激活，激活后，使用没有配置的变量报错
--------|-v 默认不激活，激活后，若信息被输出前，会显示信息的原始内容
--------|-x 默认不激活，激活后，会显示命令的内容前面有++符合
--------|-h 默认激活，与历史命令有关
--------|-H 默认激活，与历史命令有关
--------|-m 默认激活，与工作管理有关
--------|-B 默认激活，与[]的作用有关
--------|-C 默认不激活，使用>时，若文件存在则不会被覆盖


/etc/inputrc 按键的配置

通配符
*	匹配0到无穷个任意字符
?	匹配一个任意字符
[]	如[abcd]则abcd任选一个
[-]	如[0-9]，0-9直接的所有数字
[^]	取反,如[^abc] ，不是abc即可

bash环境下的特殊符号
#	注释，最常用在script中
\	转义字符
|	管道
;	命令分割,eg: echo h ; ls
~	用户的家目录	
$	获取变量的值（右值）
&	将命令变成后台下工作
!	not取反
/	路径的分隔符
>,>>	输出重定向，输出与累加
<,<<	输入重定向
''	不具有让特殊字符具有特殊含义
""	能让特殊字符有特殊含义
``	率先运行可以用$(command)替换
()	中间为子shell的起始与结束
{}	中间为命令区块的组合

stdin: 0, 使用<或<<
stdout: 1, 使用>或>>
stderr: 2, 使用2>或2>>

若要将stdout和stderr输出到一个文件则使用> file 2>&1 
/dev/null 可以抹掉任何导向这个设备的信息

<<代表的是结束的输入字符
eg:cat > catfile << "eof"
当输入了eof则代表输入结束，而不需要输入ctrl+d


cmd;cmd (不考虑命令的关联性)
cmd&&cmd2 cmd成功（$?=0)则运行cmd2
cmd||cmd2 cmd失败($?!=0)则运行cmd2

|管道只能处理stdout，而不能处理stderr
将上个命令的stdout作为下一个命令的stdin

cut -d'分隔符' -f fields <==用于有特殊分隔符
cut -c 字符区间   <==用户排列整齐信息
--------|-d 后面接分隔符，与-f一起使用
--------|-f 依据-d的分隔符分割后，用-fn取出第n段，n以,间隔如n1,n2取出n1和n2
--------|-c 以字符为单位取出n1-n2之间的字符
cut 用于处理同一行里面的数据分解

grep [-acinvo] [--color=auto] '搜索的字符串' filename
grep [-A] [-B] [--color=auto[ '搜索的字符串' filename
--------|-a 将二进制文件以text的文件格式搜索
--------|-c 统计找到的字符串的次数
--------|-i 忽略大小写
--------|-n 输出行号
--------|-v 反向搜索
--------|-o 只显示匹配项,不会整行一同显示
--------|--color=auto 关键字高亮显示
--------|-A 后面加数字，为after的意思，除了该行外后面的n行也列出来
--------|-B 后面加数字，为before的意思，除了该行外前面的n行也列出来
该行有关键字时grep会显示整行

sort [-fbMnrtuk] [file or stdin]
--------|-f 忽略大小写
--------|-b 忽略最前面的空格符部分
--------|-M 根据月份的名字来排序
--------|-n 用数字排序（默认是文本排序)
--------|-r 反向
--------|-u uniq,相同的数据，仅出现一行
--------|-t 分隔符，默认[tab]
--------|-k 以那个区间field来排序，与-t连用，-t划分几个段后，以-k n这个第n段来排序

uniq [-ic] <==去重(需要先排序,才能达到去除重复的效果)
--------|-i 忽略大小写
--------|-c 计数


wc [-lwm] (结果为行数 字数 字符数)
--------|-l 仅仅列出行
--------|-w 仅仅列出字（英文单词）
--------|-m 多少字符

tee [-a] file <==处理标准输入，将标准输出可以在输出至屏幕的同时输出至文件
--------|-a 追加的方式

tr [-ds] SET1 ... (删除或替换) <==处理标准输入
--------|-d 删除set1这个字符串
--------|-s 取代掉重复的字符

col [-xb] <== 一般用于替换tab
--------|-x 将tab替换成对等的空格数
--------|-b 有/时，仅保留反斜杠最后接的那个字符

join [ti12] file1 file2
--------|-t 设置分隔符号,默认空格，并且比对第一个字段的数据，如果两个文件相同，则将两个文件数据连成一行,相同字段会放置在行首
--------|-i 忽略大小写
--------|-1 第一个文件要用哪个字段来分析
--------|-2 第二个文件要用哪个字段来分析

paste [-d] file1 file2
--------|-d 设置分隔字符，默认[Tab]
--------|- 如果file部分替换成-，代表数据来自标准输入

expand [-t] file <==将tab用空格替换 <==unexpand则相反
--------|-t 空格的数目n

split [-bl] file PREFIX
--------|-b 想要分隔的文件大小，单位可以设置为b,k,m等
--------|-l 后面接行数,以行数来分隔
--------|PREFIX 代表前导符的意思，可作为分隔文件的文件名的前缀字符

!!!!!!!!!!!!关于-的作用，会被当做stdin或stdout
eg:tar -cvf - /home | tar -xvf -
-作为tar -cvf的标准输出 ，后面的-作为标准输入

xargs [-Oepn] command <== 以stdin的数据默认根据空格分隔成command的参数,command会使用原始命令，即不用alias
--------|-O 如果输入的stdin含有特殊字符，如',\，空格等，则可以将它还原成一般字符
--------|-e 替换EOF，后面接一个字符串，当输入该字符串时代表eof
--------|-p 运行每个参数的命令时，询问
--------|-n 后面接次数，每次command命令要用几个参数的意思
xargs没有接收任何command时默认echo

finger获取账号的相关信息，后面接用户名

======================================正则表达式===============================================
注意点1：注意语系的不同导致编码的不同
特殊符号	意义
[:alnum:]	0-9，a-z，A-Z
[:alpha:]	A-Z,a-z
[:blank:]	空格与[Tab]
[:cntrl:]	控制符
[:digit:]	数字
[:graph:]	除了空格和[Tab]外的其他按键
[:lower:]	a-z
[:print:]	可打印字符
[:punct:]	标点符号
[:upper:]	A-Z
[:space:]	空格，[Tab],CR等
[:xdigit:]	十六进制数，数码有0-9,A-Z,a-z

基本正则表达式
^word		以word为行首
word$		以word为行尾
.		任意一个字符
char*		重复char字符0-无数次
[list]		[]内的任意一个字符
[n1-n2]		编码n1-n2范围内的任意一个字符
[^list]		不以[]内的任意一个字符
char{n,m}	重复char字符n-m次{n,m}
		{n}重复n次
		{n,}重复n次以及n次以上
扩展的正则表达式
char+		重复char字符一次或以上
char?		重复char字符0个或一个
|		or
(string)	找出群组字符串
(string)+	一个及一个以上(string)		!!与\{1,\}的区别是()里面是字符串，而后者是字符
\bstring	精确匹配string


sed [-nefr] [动作]
--------|-n 使用安静模式，在一般sed的用法中，所有来自标准输入的数据都会被列出在屏幕上，而-n后，只有经过sed处理的那一行（或者动作）才会被列出来
--------|-e 直接在命令列模式上进行sed的动作编辑,运行sed一条命令中执行多个动作,但需要-e 动作 -e 动作
--------|-f 将sed的动作写在一个文件内，-f filename则可以运行filename内的sed动作
--------|-r 让sed支持扩展的正则表达式
--------|-i 直接修改读取的文件内容，而不是有屏幕输出

动作说明:[n1[,n2]] function 应该用''括起来
--------|n1,n2 一般表示选择的动作行数，比如10,20[动作行为]代表对于10到20行进行动作处理

function:
--------|a 新增，a后面接字符串，则这些字符串会在目前的下一行出现
--------|c 替换，c后面接字符串，这些字符串将会替换n1,n2之间的行
--------|d 删除
--------|i 插入，i后面接字符串，这些字符串出现在目前的上一行
--------|p 打印n1，n2之间的数据
--------|s 替换，eg:1,20s/old/new/g 这个/可以替换为别的分割符如#

printf 类似c语言的printf
printf '打印格式' 内容

awk '条件类型1{动作1} 条件类型2{动作2} ...' filename <==用于处理每一行栏内的数据，默认分隔符是[Tab]或空格 
===========awk注意点====================
1.由于已经使用''括住所有动作，所以要想如printf使用文字部分时需要使用""
2.和bash中的变量不同，使用时（也就是变量作为右值时）不需要加$
3.若一个动作由多个命令组成，则每个命令之间用;或者\[Enter]间隔
=========awk中所使用的变量===============
1.$1 $2 $3代表第1,2,3栏的数据，$0代表一整行数据
2.NF 每一行$0所拥有的总栏数
3.NR 目前awk所处理的是第几行数据
4.FS 目前的分割字节，默认是空格
=========awk的逻辑运算字符==============
> < >= <= != == 
========================================
=赋值
========================================
awk的处理过程:
1.读取一行数据填入$0 $1 $2...
2.依据条件类型的限制判断是否需要进行后面的动作
3.做完所有的动作与条件类型
4.重复1-3直到所有行数都处理完
=========awk的特殊字符==================
BEGIN 最先执行
END   最后执行


diff <==每行作为对比单位,一般用于ASCII纯文字文件上的对比
diff [-bBiuraN] from-file to-file
--------|-b 忽略一行当中，仅有多个空格的差异如"about me"和"about    me"视为相同
--------|-B 忽略空白行的差异
--------|-i 忽略大小写
--------|from-file 作为原始(参考)比对文件
--------|-u 输出统一内容的头部信息（打补丁使用），计算机知道是哪个文件需要修改
--------|-r 递归对比目录中的所有资源（可以对比目录）
--------|-a 所有文件视为文本（包括二进制程序）
--------|-N 无文件视为空文件,在没有使用-N时会提示文件仅在某个目录中才有无法对比
可以用-替换成标准输入

cmp [-l] file1 file2 <==逐字节比较两个文件
--------|-l 将所有的不同点的位都列出来，因为默认是第一个不同点

patch -pN < patch_file 升级 <==使用diff创建出的补丁文件
patch -R -pN < patch_file 还原
--------|-p 后面可以接取消几层目录的意思
--------|-R 代表还原

========================shell script=====================
#为注释
如何运行
1.具有rx权限直接运行
2.bash script.sh 或sh script.sh
4..
4.source
运行方式的区别=================================
1.bash 是另外开启一个子进程运行脚本
2.source 则会在父进程上运行脚本
导致了变量的生命周期不同

#!/bin/bash 告知这个文件使用的是bash的语法

编写shell的习惯
开头处：功能，版本，作者和联系方式，版权声明，历史记录，有特殊的命令使用绝对路径使用，需要的环境变量预先配置和export

当下达一些外部命令时，最好的解决方式时提供环境变量

$((运算式))这样子便于计算数值（因为默认是字符型)

------------------------------------------------------------------------------
test 命令 可以使用[]来代替test

!!!!
[]的注意点
1.内的每个组件都用空格隔开
2.变量或者常量最好都用""括起来
3.-a -o连接两个条件
4.或者使用&&或||,但格式为[ con1 ] || [ con2 ]

测试的标志				代表的意义
1.关于某个文件的文件类型判断eg:test -e filename 表示是否存在
-e					该文件存在?（常用)
-f					存在且为文件?
-d					存在且为目录?
-b					存在且为块设备?
-c					存在且为字符设备?
-S					存在且为socket文件?
-p					存在且为管道文件pipe?
-L					存在且为链接文件?
2.关于文件的权限判断,如test -r filename是否可读（但root权限经常例外)
-r					存在且可读?
-w					存在且可写?
-u					存在且具有SUID属性?
-g					存在且具有SGID属性?
-k					存在且具有Sticky bit属性?
-s					存在且非空？
3.两个文件之间的比较 test file1 -nt file2
-nt					newer than 是否比file2新
-ot					older than 是否比file2旧
-ef					主要是判断两个文件的inode是否相同
4.关于两个整数之间的判断 test n1 -eq n2
-eq					两数值相等(equal)
-ne					不等(not equal)
-gt					n1 > n2(greater than)
-lt					n1 < n2(less than)
-ge					n1 >= n2(greater than or equal)
-le					n1 <= n2(less than or equal)
5.字符串的数据判断
test -z string				为空串?
test -n string				不为空串?
test st1 = str2				两个字符串相等?
test str1 != str2			两个字符串不等?
------------------------------------------------------------------------
在shell中，变量有
变量		意义
------		--------
$0		文件名
$1,$2,$3...	后面的参数
$#		后面接的参数的个数
$@		"$1" "$2" "$3" ...每个变量都是独立的
$*		"$1c$2c$3c..."	c为分隔符，默认是空格键
--------------------------
shell中变量偏移
shift n偏移n个变量($1开始作用,$0不变)

语法
1.条件判断
if [ con1 ]; then
	语句
elif [ con2 ]; then
	语句
else
	语句
fi
2.多重选择
case $var in
	"内容1")
		程序
		;;
	"内容2")
		程序
		;;
	*)
		程序
		;;
esac
3.函数
function fname() 
{
	程序段
} 
函数中的参数,$0函数名,$1形参1
如何使用函数 fname 1 2 3 #1 2 3为fname的参数$1=1 $2=2 $3=3 $0=fname

4.循环
while [ con ]
do
	程序
done

until [ con ]
do
	程序
done

for var in con1 con2 con3
do 
	程序
done

for (( 初始值; con; 步长))   eg: for (( i = 1; i <= $nu; ++i ))
do
	程序
done


shell的调试
sh [-nvx] scripts.sh
--------|-n 检查语法问题
--------|-v 先输出shell的内容然后运行
--------|-x 将用到的shell内容输出，（类似与单步调试)

=============================账号管理与ACL配置================================

/etc/passwd文件中的结构
root:x:0:0:root:/root:/bin/bash
x占位（早期密码是直接存放在这个字段中)

UID(id范围)					(ID使用者特性)
0(系统管理员)				只要将用户的UID改成0，那么就具有了ROOT的权限，一个系统上面不见得只有root一个管理员
1-499(系统账号)				1-99:由发行版linux自行创建的系统账号,100-499若用户有系统账号需求时，可以使用的账号UID
500-65535(可登录账号)			2.6.x版本的linux已经支持2^32-1这么多的UID

root		用户信息说明栏使用finger的时候会提供很多信息
/root		账号的home目录
shell		所使用的shell

/etc/shadow的文件结构

root:$6$2mNLumdY$YbSqnh7chwBXHmDnJlYg0c5hvgwa5EpfU/TUmqQtcBaI/PBnK0cDHfjebg7m2EVIEj59rOdLDv.mPCHI1MN4Z0:18065:0:99999:7:::

1.账号名称
2.密码(加密后)
3.最近一次修改密码的日期(可以使用chage命令来帮助理解该数字)
该结果为从1970-1-1到修改密码的那一天所经过的天数
4.密码不可被更改的天数
(距离上一次修改密码后需要间隔该字段的天数后才能修改)
5.密码需要重新更改的天数
(在最近一次修改密码后需要间隔该字段的天数后必须修改，否则过期)
6.密码需要重新修改的期限前的警告天数(与第五个字段相比)
(在第五个字段的前该字段天会提示用户，即将过期，需要修改密码)
7.密码过期后的账号宽限时间(与第五个字段相比)
密码的有限期为第三个字段加上第五个字段，过期后若用户没有修改密码，则密码过期(但是还是可以使用），直到过了该字段的天数后彻底失效，无法使用,无法登录
8.账号失效日期
(与第三个字段一样都是从1970-1-1开始的天数，这个字段表示过期后账号无法使用，无论密码是否过期，一般用于收费的系统，可以配置让用户过了该日期后无法使用)
9.保留字段

/etc/group文件结构
lp:x:7:littlerain
1.用户组
2.如同/etc/passwd中第二个字段
3.GID
4.用户组中的成员中间用,隔开

/etc/passwd中，GID决定了用户的初始化群组

使用groups可以查看目前登录用户所属的用户组,第一个结果决定了用户的有效群组(这个决定了新建文件时的文件所属于的用户组)

newgrp 用户组(修改用户的有效群组)
newgrp会新起一个进程，在该进程中有效群组变更为新的用户组

/etc/gshadow的文件结构
lp:*::littlerain
1.用户组名
2.密码栏，开头为!表示无合法口令，所以没有群组管理员
3.群管理员的账号
4.用户组中的成员

----------------------------useradd的说明--------------------------------------------------------------------------------
useradd [-u UID] [-g 初始群组] [-G 次要群组] [-mM] [-c 说明栏] [-d 家目录绝对路径] [-s shell] 用户账号名
--------|-u 直接指定特殊的UID
--------|-g 该用户组的gid会放置在/etc/passwd的第四个字段中
--------|-G 决定了用户是否加入其他的用户组，会写到/etc/group中
--------|-M 强制!不要创建用户家目录(系统账号默认值)
--------|-m 强制!创建用户家目录（一般账号默认值)
--------|-c /etc/passwd中第五个字段的说明内容
--------|-d 指定该目录成为用户的home目录
--------|-r 创建一个系统账号，这个账号的UID会有限制（/etc/login.defs)
--------|-s 后面接一个shell，没有制定的话默认是/bin/bash(deepin目前的是/bin/sh
--------|-e 后面接日期，格式为yyyy-mm-dd，会写入到shadow的第八个字段(用户失效日期)
--------|-f 后面接shadow的第七个字段，指定密码是否失效，0为立刻失效，-1为永不失效(密码只会过期)

useradd -D显示默认值(/etc/default/useradd中决定)
GROUP=100 (新建用户的初始群组）
不同的发行版决定了不同的用户组机制
1.私有用户组机制(系统会创建一个与账号一样的用户组作为用户的用户组，不会参考GROUP这个默认值)
2.公共用户组机制(则参考GROUP这个值)

HOME=/home (用户家目录的基准目录，都会创建在/home下面

INACTIVE=-1: 密码过期后是否会失效的配置值（-1不会，0立刻，数字如30则过期后30天失效)

EXPIRE=:    账号的失效日期

SHELL=/bin/bash: 默认使用的shell名称

SKEL=/etc/skel: 用户家目录参考的基准目录
(创建用户后会copy一份/etc/skel放置在用户home目录里)

CREATE_MAIL_SPOOL=yes: 创建用户的mailbox
ls -l /var/spool/mail/用户

UID/GID的默认值参考/etc/login.defs
/etc/login.defs中文件结构
1.MAIL_DIR /var/spool/mail 	用户默认信息目录
2.PASS_MAX_DAYS 99999		/etc/shadow内的第五栏，多久需要变成密码
3.PASS_MIN_DAYS 0		/etc/shadow内的第四栏，多久不可重新配置密码
4.PASS_MIN_LEN 5		密码最短长度，已经被pam静态库取代
5.PASS_WARN_AGE	7		/etc/shadow内的第六栏，过期前的警告日期
7.UID_MIN	500		小于这个数属于系统保留
8.UID_MAX	60000		使用者最大能够使用的UID
9.GID_MIN	500		小于属于系统保留
10.GID_MAX	60000		使用者最大能够使用的GID
11.CREATE_HOME	yes		在不加-m或-M时，是否主动创建home目录
12.UMASK	077		用户家目录创建的umask
13.USERGROUPS_ENAB yes		删除用户时userdel，是否删除初始化群组
14.MD5_CRYPT_ENAB yes		是否经过md5加密

需要注意的是系统给予一个账户UID时，1参考UID_MIN取得最小数值，然后2.有/etc/passwd中找最大的UID，1和2对比后，在最大的基础上加一就是新的UID
---------------------------------------------------------------------------------------------------------------------------------------------

passwd [--stdin]  <==所有人均可使用来改自己的密码
passwd [-l] [-u] [--stdin] [-S] [-n 日期] [-x 日期] [-w 日期] [-i 日期] 账号
--------|--stdin: 接受标准输入作为密码(不是所有的发行版都支持)
--------|-l lock的意思，将/etc/shadow的第二栏最前面加上!，使密码失效
--------|-u unlock
--------|-S 列出密码相关参数,shadow文件内的大部分信息
--------|-n 后面接天数，shadow的第四个字段，多久不可修改密码天数
--------|-x 后面接天数，shadow的第五个字段，多久内必须要修改密码
--------|-w 后面接天数，shadow的第六个字段，密码过期前的警告天数
--------|-i 后面接日期，shadow的第七个字段，密码失效日期

chage [-ldEImMW] 用户名
--------|-l 列出该账号的详细密码参数
--------|-d 后面接日期，修改shadow的第三个字段（最近一次更改密码的日期）格式YYYY-MM-DD
--------|-E 后面接日期，修改shadow的第八字段（账号失效日期），格式YYYY-MM-DD
--------|-I 后面接天数，修改shadow的第七字段（密码失效日期）
--------|-m 后面接天数，修改shadow的第四字段（密码最短保留天数）
--------|-M 后面接天数，修改shadow的第五字段（密码多久需要进行变更）
--------|-W 后面接天数，修改shadow的第六字段（密码过期前警告天数）

usermod [-cdegGlsuLU] username  <==也可直接修改/etc/passwd 或/etc/shadow
--------|-c /etc/passwd的第五栏的说明栏，可以加入账号的说明
--------|-d 修改用户的home目录，/etc/passwd的第六个字段
--------|-e 后面接日期，YYYY-MM-DD /etc/passwd的第八个字段
--------|-f 后面接天数，shadow的第七个字段
--------|-g 后面接初始用户组，修改/etc/passwd的第四个字段，也就是gid的字段
--------|-G 后面接次要用户组，修改的是/etc/group
--------|-a 与-G一起使用，可添加次要用户组的支持（新增）而不是配置（修改）
--------|-l 后面接账号名称，修改账号名称,/etc/passwd的第一栏
--------|-s shell的实际文件，可以使/bin/bash或者/bin/csh
--------|-u 后面接UID数字，修改/etc/passwd的第三栏数据
--------|-L 暂时冻结用户密码，/etc/shadow的密码栏
--------|-U 解冻密码

用户的数据有
/etc/passwd,/etc/shadow  用户的账号和密码
/etc/group,/etc/gshadow  用户组的相关信息
/home/username,/var/spool/mail/username 用户个人文件

------------一般用户可以使用,上述基本属于管理员
userdel [-r] username
--------|-r 连同用户的家目录一起删除

finger [-s] usernmae
--------|-s 仅列出用户账号，全名，终端代号，登录时间等
--------|-m 列出与后面接的账号相同者，而不是利用部分比对

chfn [-foph] [账号名]  <==会修改/etc/passwd的第五个字段
--------|-f 全名
--------|-o 办公室房间号码
--------|-p 办公室电话号码
--------|-h 家庭电话

chsh [-ls]   <==change shell
--------|-l 列出可用的shell，/etc/shells
--------|-s 配置修改自己的shell

id [username]  <==查看用户的uid/gid相关信息

groupadd [-g gid] [-r] 组名
--------|-g 特定GID
--------|-r 创建系统用户组/etc/login.defs中的GID_MIN有关

groupmod [-g gid] [-n group_name] 组名
--------|-g 修改现有的gid
--------|-n 修改现有的组名

groupdel [groupname]

gpasswd groupname
gpasswd [-A user1,...] [-M user3,...] groupname
gpasswd [-rR] groupname
--------|  没有参数时，表示给予groupname一个密码/etc/gshadow
--------|-A 将groupname的控制权给后面的用户管理（用户组管理员)
--------|-M 将用户加入到该组中
--------|-r 将groupname的密码移除
--------|-R 将groupname的密码失效
gpasswd [-ad] user groupname
--------|-a 将用户加入用户组
--------|-d 将用户移除用户组

------------------------------------ACL (access control list)-------------------------
1.使用者(user) 针对使用者来配置权限
2.用户组(group) 针对用户组来配置权限
3.默认属性(mask) 针对该目录下创建文件/目录时，规范新数据的默认权限

若系统没有默认增加ACl的话可以
mount -o remount,acl /
修改/etc/fstab
LABEL=/1 / ext3 defualts,acl 1 1

setfacl [-bkRd] [{-m|-x} acl参数] 目标文件名
--------|-m 配置后续的acl参数给文件使用，不可与-x合用
--------|-x 删除后续的acl参数，不可与-m使用
--------|-b 移除所有的acl参数
--------|-k 移除默认的acl参数
--------|-R 递归配置acl
--------|-d 配置默认的acl参数，只对目录有效，在该目录新建数据时会引用此数据
1.针对特定使用者的方式
配置语法:  u:[使用者列表]:[rwx]没有使用者时，默认配置的是文件拥有者
2.针对特定群组的方式
配置语法:  g:[用户组列表]:[rwx]
3.针对有效权限mask的方式
配置语法:  m:[rwx]   <==限制u和g的最大权限
4.针对默认权限的配置方式
配置语法:  d:[ug]:使用者列表/用户组列表:[rwx]


getfacl filename
选项几乎和setfacl一致

su [-lm] [-c 命令] [username]  <==切换谁，需要谁的密码
--------|- 单独使用时代表使用login-shell的变量文件读取方式来登录系统,若使用者没有，则是切换为root身份
--------|-l 与-类似，但是后面需要加想要切换的用户账号，也是login-shell的方式
--------|-m 与-p一样，表示使用目前的环境配置，而不读取新用户的配置文件
--------|-c 仅执行一次命令，所以要后面加命令

sudo [-b] [-u 新使用者] <==/etc/sudoers决定了谁有权限使用该命令 切换用户来执行某个操作，密码仅仅需要当前使用的用户的密码
--------|-b 将后续的命令放在后台中让系统自行运行，而不和目前的shell产生影响
--------|-u 后面接想要切换的用户，没有用户则是root

/etc/sudoers的文件格式
使用visudo来编辑该文件（会检查语法错误），命令中应该使用绝对路径
1.单一用户的配置
使用者账号		登陆者的来源主机名=（可切换的身份）	可下达的命令   
root 			ALL=(ALL) 				ALL	       
2.用户组和免密码的配置
%groupname		ALL=(ALL)				ALL
username/%groupname	ALL=(ALL)				NOPASSWD:ALL
3.有限制的命令配置	
myuser			ALL=(root)				!/usr/bin/passwd, /usr/bin/passwd [A-Za-z]*   <==!代表无法执行，也就是无法修改root的密码
4.通过别名建立配置
User_Alias UPPER = user1, user2, user3    <==设置用户别名，别名都需要大写
Cmnd_Alias UPPERCOM = !/usr/bin/passwd, /usr/bin/passwd [a-zA-Z]*  <==设置命令别名
UPPER			ALL=(root)				UPPERCOM
5.sudo的时间间隔为五分钟（五分钟内再次使用sudo不需要密码)


特殊的shell /sbin/nologin 可以使用系统资源但是无法登录（无法使用bash获取其他的shell来操作) /etc/nologin.txt可以编辑无法登录的原因告知用户

------------------PAM(Pluggable Authentication Modules，嵌入式模块)

PAM用来进行验证的数据称为Modules

/etc/pam.d/配置文件  使用PAM的程序会调用该目录下同名的配置文件，依据该配置文件寻找对应的PAM静态库

eg:CentOS下/etc/pam.d/passwd
#%PAM-1.0	<==PAM的版本
auth	include		system-auth   <==每一行都是验证过程
account	include		system-auth
passwordinclude		system-auth
验证类别控制标准	PAM静态库与静态库参数
include代表呼叫后面的文件来作为这个类别的验证

第一个字段：验证类别
1.auth
	authentication(认证),主要用来验证使用者的身份，通常是需要密码来验证，所以后面接的静态库是用来检验用户的身份
2.account
	account(账号)则大部分进行授权，主要验证使用者是否拥有正确的权限
3.session
	session会话，使用者在本次登录（本次命令）期间，PAM所给予的环境配置，通常用于记录用户登录或注销时的信息
4.password
	主要在提供验证的修改工作，比如修改密码

第二个字段：验证的控制标志（control flag)  <==通过验证的标准
1.required
	成功则带有success的标志，否则failure，但不论成功与否都会继续后续的验证流程
2.requisite(必须的)
	若验证失败则立刻回复原程序failure，并且终止后续验证，若成功则带有success并继续验证（与1的区别，失败后立即终止后续验证)
3.sufficient(充足的)
	成功立刻回复success给原程序，终止后续验证，若失败，则带有failure并且继续（与2相反)
4.optional
	大多数用于显示信息


/etc/pam.d/* 每个程序个别的PAM配置文件
/etc/security/* 其他PAM环境的配置文件
/lib/security/*	PAM静态库文件的实际放置目录
/usr/share/doc/pam-*/ 详细的PAM说明

较常使用的PAM静态库
1.pam_securetty.so:
	限制管理员只能够从安全的终端机登录，安全的终端机配置则写在/etc/securetty这个文件中
2.pam_nologin.so:
	限制一般用户是否能够登录主机，当/etc/nologin存在时，则所有一般用户无法再登录系统，并且会显示该配置文件的内容
3.pam_selinux.so:
	针对程序来进行细部管理权限的功能
4.pam_console.so:
	当系统出现某些问题，或者需要使用特殊的终端接口（如RS232）登录主机时，这个静态库可以帮助处理一些文件的权限，让使用者能够通过特殊终端来登录系统
5.pam_loginuid.so:
	验证使用者的UID是否满足程序需要
6.pam_env.so:
	配置环境变量的一个静态库，如果需要额外的环境变量配置参考/etc/security/pam_env.conf
7.pam_unix.so:
	可以用在验证阶段的认证功能，用在授权阶段的账号许可证管理，用在会话阶段的登陆文件记录，甚至是密码修改阶段的检验，在早期使用的非常频繁
8.pam_cracklib.so:
	用来检验密码的强度，包括密码是否在字典中，密码输入几次失败后就断开此次联机都是由该静态库提供
9.pam_limits.so:
	ulimit的功能由该静态库提供


limits.conf可以限制每次仅能有一个用户登录系统

w / who 查询已经登录在系统上的用户
lastlog 查询每个账号最近登录的时间会读取/var/log/lastlog文件

-------------------------用户间的通信--------------
write 用户 [用户所在终端接口]	<==用户之间的通信(但是会打断该用户当前的工作)

mesg n 拒绝除root外的对话
mesg y 开启对话
mesg 显示状态

wall 广播

mail username@localhost -s "邮件标题"  <==可使用<重定向来决定邮箱信息
mail则会查看邮箱内容

-------------------------手动增加用户或者用户组---------------
pwck 检查/etc/passwd的信息，与实际home目录是否存在的信息，还可以对比/etc/passwd /etc/shadow的信息是否一致
grpck 则用于检查用户组
pwconv 主要用于将/etc/passwd内的账号和密码，移动到/etc/shadow当中
pwunconv 则与上一个相反,并且会删除/etc/shadow文件
chpasswd 一般用于批量创建用户 eg: echo "username:password" | chpasswd -m

手动创建的步骤
1.先创建所需要的群组 ( vi /etc/group )；
2.将 /etc/group 与 /etc/gshadow 同步化 ( grpconv )；
3.创建账号的各个属性 ( vi /etc/passwd )；
4.将 /etc/passwd 与 /etc/shadow 同步化 ( pwconv )；
5.创建该账号的口令 ( passwd accountname )；
6.创建用户家目录 ( cp -a /etc/skel /home/accountname )；
7.更改用户家目录的属性 ( chown -R accountname.group /home/accountname )

========================磁盘配额与进阶文件系统管理============================
Quota的一般用途:
1.针对www server,例如：每个人的网页空间的容量限制!
2.针对mail server,例如，每个人的邮件空间限制
3.针对file server,例如，每个人最大的可用网络磁盘空间

针对linux系统主机上面的配置
1.限制某一用户组所能使用的最大磁盘配额
2.限制某一使用者最大的磁盘配额
3.以硬链接的方式，来使邮件可以作为限制的配额


Quota配额的使用限制
1.只能针对整个文件系统
2.内核必须支持
3.Quota的记录文件（现已从quota变成了aquota)
4.只对一般身份使用者有效(root无法配置quota)


对于文件系统的限制有
1.容量限制block或文件数量限制inode
2.柔性劝导与硬性规定(soft/hard)
inode/block有两个配置值一个是hard一个是soft，通常hard比sort还要高，高出sort后会有警告
3.会倒数计时的宽限时间（grace time),超过soft后会有宽限时间允许用户删除文件，宽限时间过后最大用量将由hard变成soft的值

Quota流程-1.文件系统的支持
挂载时加入usrquota,grpquota

Quota流程-2.创建quota记录文件
Quota是通过分析整个文件系统当中，每个使用者（用户组）所拥有的文件总数和容量，再将这些数据记录到该文件系统的最顶层目录，然后在该记录文件中在使用每个账号（用户组）的限制值去规范磁盘使用量的

quotacheck [-avugfM] [/mount_point]  <==扫描文件系统并创建quota的记录文件
--------|-a 扫描所有在/etc/mtab内，含有quota支持的文件系统，加上此参数后，/mount_point不必写
--------|-u 针对使用者扫描文件与目录的使用情况，会创建aquota.user
--------|-g 针对用户组扫描文件与目录的使用情况，会创建aquota.group
--------|-v 显示扫描过程的信息
--------|-f 强制扫描文件系统，并写入新的quota的配置文件中（危险）
--------|-M 强制以读写的方式扫描文件系统，只有在特殊情况才会使用

Quota流程-3.Quota启动，关闭与限制值配置
quotaon [-avug]
quotaon [-vug] [/mount_point]
--------|-u 针对使用者启动(aquota.user)
--------|-g 针对用户组启动(aduota.group)
--------|-v 显示启动过程的相关信息
--------|-a 根据/etc/mtab内的文件系统配置启动有关的quota，若不加-a则后面需要加特定的挂载点

quotaoff [-a]
quotaoff [-ug] [/mount_point]
--------|-a 全部的文件系统都关闭，根据/etc/mtab
--------|-u 仅针对后面那个挂载点关闭user quota
--------|-g 仅针对后面那个挂载点关闭group quota

edquota <==编辑账号/用户组的限制与宽限时间
edquota [-u username] [-g groupname]  
edquota -t <==修改宽限时间
edquota -p 范本账号 -u 新账号
--------|-u 后面接用户名，可以进入quota的编辑画面去配置username的限制值(单位KB)(该界面只要保持每一行有七栏即可，不需要对齐
--------|-g 后面接用户组，可以进入quota的编辑画面去配置groupname的限制值(单位KB)
--------|-t 可以修改宽限时间
--------|-p 复制范本，那个范本账号为已经存在并配置好quota的使用者
	    目的是将范本的账号这个用户的quota限制复制给新账号

Quota流程-4.Quota限制值的报表
quota [-uvs] [username]
quota [-gvs] [groupname]
--------|-u 后面接username表示显示出该使用者的quota限制，若不接则显示出运行者的quota限制
--------|-v 显示每个用户在文件系统的quota值
--------|-s 使用1024为倍数来制定单位，会显示如M的单位
--------|-g 后面接groupname表示显示出该用户组的quota限制值

repquota -a [-vugs] 针对整个文件系统的限额做报表
--------|-a 查阅/etc/mtab寻找具有quota的标志的文件系统，并报告quota的结果
--------|-v 输出的数据将含有文件系统相关的细致信息
--------|-g 显示出个别用户组的quota的值
--------|-s 使用M，G为单位
--------|-u 显示出使用者的quota限制值（默认)

Quota流程-5.测试与管理

warnquota根据/etc/warnquota.conf的配置来找出目前系统上超过soft的用户，然后通过email的功能发送给用户和root

setquota <==直接在命令中配置quota的限制值
setquota [-u|-g] 名称 block(soft) block(hard) inode(soft) inode(hard) 挂载点

------------------------------------------------RAID磁盘阵列--------------------------------
Redundant Arrays of Inexpensive Disks,RAID
容错式廉价磁盘阵列

磁盘阵列的等级
RAID-0(等量模式,stripe)性能最佳,这种模式下硬盘会先切出等额的区块，然后当文件需要写入RAID时，该文件会依据区块的大小分割，然后依照RAID中硬盘的顺序，循环轮流写入到各个硬盘中。
特点:只要有任何一个硬盘损坏，在RAID上面的所有数据都会遗失而无法读取

RAID-1(映射模式，mirror)完整备份
让同一份数据，完整的保存在RAID中的每一个硬盘中
特点：数据的备份，以及读取的性能提高，当多个进程读取同一个数据时，可以选择不同的硬盘去读取

RAID 0+1,RAID 1+0
0+1，率先组成RAID-0，然后多个RAID-0组成RAID-1
1+0，率先组成RAID-1，然后多个RAID-1组成RAID-0

RAID-5:性能与数据备份的均衡考虑
类似于RAID-0,不过在循环写入的时候，会在每一个硬盘上加一个同位检查数据（Parity),这个数据被记录其他硬盘的备份数据，用于当有硬盘损坏时的救援
eg:
DiskA		DiskB		DiskC
A0		B0		parity0
A1		parity1		C1
parity2		B2		C2
特点:RAID-5的总容量会是整体硬盘数量-1，而且当损坏的硬盘数量大于1时，这整个RAID就损坏,因为RAID-5默认仅支持一个硬盘损坏
RAID-6则允许两块硬盘作为parity的储存

Spare Disk:预备硬盘的功能:
一个或多个硬盘没有包含在磁盘阵列中，平时不会被使用，当磁盘阵列中任何硬盘损坏时，则这个spare disk则会主动被拉近磁盘阵列中，并且将坏的硬盘移除，然后重新建立数据系统（但坏的硬盘还是需要人手工替换的)

磁盘阵列的优点：
1.数据安全性和可靠性
2.读写性能
3.容量

软件/硬件磁盘阵列：硬件需要有磁盘阵列卡以及驱动，软件则是模拟出磁盘阵列。
硬件磁盘阵列在linux下面看来就是一个大的硬盘/dev/sd[a-p]，而软件模拟出来的，所使用的设备名称时系统的设备文件/dev/md[0-n]

mdadm --detail /dev/md0
mdadm --create --auto=yes /dev/md[0-9] --raid-devices=N --level=[015] --spare-devices=N /dev/sdx
--------|--create 创建RAID
--------|--auto=yes 决定创建后接的软件磁盘阵列设备即/dev/md[0-9]
--------|--raid-devices=N 使用几个硬盘作为磁盘阵列的设备
--------|--level=[015] 磁盘阵列的等级，但是不只是015
--------|--spare-devices=N 使用几个作为磁盘阵列的备份设备
--------|-detail 显示后面的磁盘阵列的信息







