第一部份：Linux的规划与安装
第二部份：Linux文件、目录与磁盘格式
第三部份：学习Shell与Shell Scripts
第四部份：Linux使用者管理
第五部份：Linux系统管理员
第六部份：其他备份文章


-------------------------计算机概论-----------------------------
芯片组通常分为两个桥接器来控制各组件的通信
（1）北桥负责连接速度较快的CPU，内存与显卡等组件；
（2）南桥负责连接速度较慢的周边接口，包括硬盘，USB,网卡等

库函数调用系统调用　
系统调用调用内核函数

一般来说操作系统会提供开发接口，让开发商制作他们的驱动程序
驱动程序与开发商有关，与操作系统的开发者无关

BIOS(Basic Input Output System)是一套程序，这套程序是写死在主板上面的一个内存芯片中，这个内存芯片在没有通电时也能够将数据记录，那就是只读存储器
操作系统（系统调用和内核）

IDE硬盘		/dev/hd[a-d]
SCSI/SATA/U盘	/dev/sd[a-p]
U盘		/dev/sd[a-p]
软盘		/dev/fd[0-1]
打印机		ｕ盘/dev/usb/lp[0-15]
		25针/dev/lp[0-2]
鼠标		Ｕ盘/dev/usb/mouse[0-15]
		ps2:/dev/psaux
当前的鼠标	/dev/mouse

磁盘的第一个扇区主要记录了两个重要的信息
1.主要启动记录区MBR：可以安装启动管理程序的地方，有446Bytes
2.分区表:记录整个磁盘分区的状态，有64bytes(四组记录,四个分区,每组记录了该区段的起始和结束的柱面号)


分区的一些限制:
1.主分区和扩展分区共计4个
2.扩展分区最多只有一个
3.逻辑分区是扩展分区继续划分出来的
4.扩展分区无法格式化

分区注意点,如果扩展分区被破坏，那么所有的逻辑分区都会被删除，因为逻辑分区的分区表记录在扩展分区里面

启动流程到操作系统之前的动作:
BIOS:启动主动运行的程序，会识别第一个可启动的设备
MBR:第一个可启动设备的第一个扇区内的主要启动记录区块，内含启动管理程序
启动管理程序(Boot loader):一个可读取内核文件来运行的软件
内核文件(操作系统内核):开始操作系统的功能

Boot loader的任务:
提供菜单:使用者可以选择不同的启动项目
加载内核文件:直接指向可启动的程序段开始操作系统
转交其他loader:将启动管理功能转交

每个分区都有自己的启动扇区(boot sector)
实际可启动的内核文件都是放在各个分区内

shutdown [-t 秒] [-arkhncfF] 时间[警告信息]
-t sec: -t后面加秒数，过sec秒后关机
-k    :	发送警告消息，不关机
-r    :	在将系统的服务停掉后就重新启动
-h    : 在将系统的服务停掉后就立即关机
-n    : 不经过init程序，直接以shutdown的功能来关机
-f    : 关机并启动之后，强制略过fsck的磁盘检查
-F    : 系统重新启动后，强制进行fsck的磁盘检查
-c    : 取消已经在进行的shutdown命令内容
时间  : 一定要加的参数！指定系统关机时间

run level 0:关机
run level 3:纯文本模式
run level 5:含有图形接口模式
run level 6:重新启动

man手册中的操作
空格		向下翻一页
[page down]	向上翻一页
[page up]	向下翻一页
[home]		回退第一页
[end]		去最后一页
/string		向下查找
?string		向上查找
n,N		移动查找结果的光标

man [-fk] [n]
-f	:显示工具和工具的简单说明等价于whatis	
n	:显示哪一页的man手册
-k	:搜索有关key的手册

\[enter]使命令连续到下一行

---------------------------linux基本命令------------------------------
date 
cal
bc
[Ctrl]+c	中断
[Ctrl]+d	终止输入


linux文件权限与目录配置----------------------------------|
/etc/passwd 记录系统上的账户和账户信息
/etc/shadow 记录个人密码
/etc/group  记录用户组

chgrp	[-R]	dirname/filename...
-R		:递归修改

chown	修改文件所属者
chown owner:group filename

chmod	修改文件权限
rwx:(三个bit对应三个状态有无)
chmod [-R] 文件或目录
-R		:递归修改

chmod | u | + | r | file/dir
      | g | - | w |
      |	o | = | x |
      |	a |   |   |

权限对于文件的重要性
r	可读
w	可编辑，新增修改（但不含删除）
x	可执行

权限对于目录的重要性
r	可以查询当前目录下的文件名数据
w	可以修改目录结构的权限（建立新文件或目录，删除已经存在的目录或文件，重命名，移动）
x	代表用户是否让该目录成为自己的工作目录,同时决定了能够使用该目录下的程序

文件种类:
1.正规文件:属性[-]
	纯文本文件ascii
	二进制文件binary
	数据格式文件data 通过特定程序来读取

2.目录:属性[d]
3.连接（类似于快捷方式):属性[l]
4.设备文件:
	块设备[b]:成组的设备比如硬盘
	字符设备[c]:串行端口的借口设备，特点一次性读取，不能截断
5.数据接口文件sockets:属性[s]
6.管道文件pipe:属性[p] 特点FIFO

重要的目录
/lost+found	这个目录是使用标准的ext2/ext3文件系统格式才会产生的一个目录，目的在于当文件系统发生错误时， 将一些遗失的片段放置到这个目录下。这个目录通常会在分区的最顶层存在， 例如你加装一颗硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录『/disk/lost+found』
/proc	这个目录本身是一个『虚拟文件系统(virtual filesystem)』喔！他放置的数据都是在内存当中， 例如系统内核、进程信息(process)、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的文件例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/* 等等。
/sys	这个目录其实跟/proc非常类似，也是一个虚拟的文件系统，主要也是记录与内核相关的信息。 包括目前已加载的内核模块与内核侦测到的硬件设备信息等等。这个目录同样不占硬盘容量喔！
/etc：配置文件
/bin：重要执行档
/dev：所需要的设备文件
/lib：执行档所需的函式库与内核所需的模块
/sbin：重要的系统执行

/bin主要放置在开机时，以及进入单人维护模式后还能够被使用的指令，至于/usr/bin则是大部分软件提供的指令放置处。

. 当前目录
.. 上级目录
- 前一个目录
~ 当前用户的home目录
~account account的home目录


pwd [-P]
--------|-p 显示出确实的路径，而非使用链接路径(默认会显示链接路径)

mkdir [-mp] 目录名称
--------|-m 配置文件的权限，直接配置，不需要看默认权限umask的脸色
--------|-p 递归创建

rmdir [-p] 空目录名称
--------|-p 递归删除

会根据PATH的设置，来决定率先使用哪一个命令
使用绝对路径或相对路径直接指定某个命令的档名来运行，会比搜寻PATH来的正确

ls [-aAdfFhilnrRSt] 目录名称
ls [--color={never,auto,always}] 目录名称
ls [--full-time] 目录名称
--------|-a 全部的文件，连同隐藏文件
--------|-d 仅列出目录本身，而不列出目录内的数据文件
--------|-l 长数据列出，包含文件的属性和权限等
--------|常用

--------|-A 全部的文件，但不包括. 和..
--------|-f 直接列出结果，而不进行排序（默认以文档名排序)
--------|-F 根据文件、目录等，赋予附加的数据结构（如/代表目录)
--------|-h 将文件容量以人类较易读的方式列出来
--------|-i 列出inode号码
--------|-n 列出UID和GID而非使用者和用户组的名字
--------|-r 将排序结果反向输出
--------|-R 递归列出
--------|-S 以文件大小排序，而不是以文件名排序
--------|-t 根据时间排序
--color=never:不要依据文件特征给出颜色显示
--color=always:显示颜色
--color=auto:让系统自行依据配置判断是否显示颜色
--full-tile:显示完整时间（年月日时分)
--time={atime,ctime}:输出访问access时间或改变权限属性时间(ctime)而非内容变更的时间(modification time)

cp [-adfilprsu] source destination
cp [options] source1 source2 source3... directory
--------|-a 相当于-pdr
--------|-d 若来源属于链接，则赋值链接而非文件本身
--------|-f 强制，若目标文件已经存在且无法开启，则移动后再尝试一次
--------|-i 若目标文件已经存在，则询问是否覆盖
--------|-l 进行硬链接的链接创建，而非复制文件本身
--------|-p 连同文件属性一起赋值，而非使用默认属性(备份常用)
--------|-r 递归复制
--------|-S 赋值为符号链接
--------|-u 若des比src旧才升级des

rm [-fir] 文件或目录
--------|-f 强制，忽略不存在的文件，没有警告信息
--------|-i 删除前询问
--------|-r 递归删除

\command 将会忽略掉alias的指定选项

mv [fiu] src des
mv [options] src1 src2 src3 ... des
--------|-f 强制，若目标文件存在，不会问询直接覆盖
--------|-i 若des存在，则询问是否覆盖
--------|-u 若des已经存在，且src较新，则升级update des

basename 获取文件名
dirname 获取目录名

cat [-AbEnTv]
--------|-A 相当于-vET,可列出一些特殊字符
--------|-b 列出行号，仅针对非空行号
--------|-E 将结尾的换行字节$显示出来
--------|-n 连同空行一起显示行号
--------|-T 将[tab]以^|显示出来
--------|-v 显示出特殊字符


nl [-bnw] 文件
--------|-b 指定行号方式，-b a：表示不论空行同样显示行号，-b t:有空行忽略显示行号（默认)
--------|-n 列出行号的方式，-n ln:行号最左边显示,rn最右边显示且不用0占位，rz用0占位，最右边显示
--------|-w 行号栏位的占用的位数如让行号占4位 -w 4

more内的操作
space:向下翻页
Enter:向下翻一行
/key:向下查找key
:f :显示文档名和当前行数
q 退出
b 回翻


less内的操作
space：向下翻一页
[pagedown]：等同于space
[pageup]：向上翻一页
/key
?key
n :重复前一个搜索
N :反向重复前一个搜索
q 退出


head [-n number] 文件
--------|-n 后面接数字，代表显示几行的意思
	    number为负数时，表示后面number行都不显示，只显示前面的


tail [-n number] 文件
--------|-n 后面接数字，代表显示几行
--------|-f 表示持续侦测后面所接的文件，要等到按下[ctrl]+c才会结束侦测(当数据更新时实时显示)
基本等同于head，只是方向相反


ob [-t Type] 文件
--------|-t a:利用默认字符输出
	    c:利用ascii字符输出
	    d[size] 利用十进制来输出数据，每个输出数据占用size 字节（以size字节来读取原始文本)
	    f[size]
	    o[size]
	    x[size]
最左边第一栏是以8进制显示的字节数

------------------------------------------------------------
modification time(mtime):默认
当前文件的内容变更时，会变更这个时间，内容指的是文件的内容而不是文件的属性或者权限
status time(ctime):
当该文件的状态改变时，比如权限或者属性被更改时，才会修改这个时间
access time(atime):
当文件的内容被读取时（文件被访问时），这个时间才会被修改
-------------------------------------------------------------



touch [-acdmt] 文件
--------|-a 仅修改访问时间
--------|-c 仅修改文件时间，若文件不存在则不创建文件
--------|-d 后面可以接想要修改的日期而不用目前的日期，也可以用--date="时间或日期"
--------|-m 仅修改modifytime（文件内容修改时间)
--------|-t 后面接想要修改的时间，格式为[YYMMDDhhmm]

默认权限umask -S（以可读形式展现)
umask(以数字，需要减掉的权限显示)
默认文件没有x权限，目录有x权限
eg:umask 
结果为0022 (022) user group other
		 0    2     2 //在777减去022
		 7    7     7
		 7    5     5 //实际权限
		 rwx  r-x   r-x


文件的隐藏属性
chattr(只能在Ext2/Ext3的文件系统上生效)
chattr [+-=] [ASacdistu] 文件或目录名
--------|+ 添加一个特殊参数
--------|- 移除一个特殊参数
--------|= 赋予权限
==========
--------|A 当配置了A属性时，若有存取此文件（或目录）时，它的存取时间atime将不会被修改，可避免I/O较慢的机器过度的存取磁盘。这对速度较慢的计算机有帮助
--------|S 一般文件是非同步写入磁盘的，如果加上S这个属性时，当你进行任何文件的修改，该改动会同步写入到磁盘中（sync)
--------|a 这个文件只能添加数据，不能删除也不能修改数据，只有root才能配置该权限
--------|c 将会自动将此文件压缩，在读取的时候自动解压缩，但是在存储的时候，将会先进行压缩然后再存储（对于大文件来说有用)
--------|d 当dump程序被运行的时候，配置d将可以使得该文件（目录）不会被dump备份
--------|i 让一个文件不能被删除、改名、配置连接也无法写入或新增数据!只有root可以配置，对系统安全性有强大的帮助
--------|s 如果这个文件被删除，它将会被完全的移除这个硬盘中，所以误删没有办法救回来
--------|u 与s相反，删除后，文件还留在硬盘中

lsattr(显示文件隐藏属性)
lsattr [-adR] 文件或目录
--------|-a 将隐藏文件的属性也显示
--------|-d 仅写出目录本身的属性
--------|-R 递归显示


Set UID
当s这个标志出现在文件拥有者x的权限上时，如/usr/bin/passwd 
[-rwsr-xr-x] 此时就称之为set UID，简称SUID的特殊权限
1.SUID权限仅对二进制程序有效
2.运行者对于该程序需要具有x的可执行程序
3.本权限仅在运行该程序的过程中有效（run-time)
4.运行者将具有该程序拥有者的权限

Set GID
s出现在文件用户组x的权限上
与SUID不同的是，SGID可以针对文件或目录配置
如果是文件:
1.SGID对二进制程序有效
2.程序运行者需要具有x权限
3.运行者在运行时会获得该程序用户组的权限支持
如果是目录:
1.使用者若对该目录具有r和x的权限时，使用者能够进入该目录
2.使用者在此目录下的有效用户组将会变成该目录的用户组
3.用途：若使用者在此目录下具有w权限（可以新建文件），则使用者所创建的新文件，该文件的用户组和此目录的用户组相同权限

Sticky Bit(sticky黏)
SBIT仅针对目录有效
1.当使用者对于该目录有wx权限
2.当使用者在该目录下创建文件或目录，仅有自己和root才有权限删除该文件
如/tmp [drwxrwxrwt]

4为SUDI
2为SGID
1为SBIT
ugb
例如:chmod 4755 test
当本身不具有x的权限时，赋予了UGB的话（实际上是具有空的权限)，其次s和t变成大写的ST

file(查看文件类型)


which(寻找可执行文件)
which [-a] command
--------|-a 显示所有PATH目录中可以找到的命令，而不只是第一个

whereis(寻找文件)(与find搜索磁盘不同，whereis是利用数据库搜索)
whereis [-bmsu] 文件或目录
--------|-b 只查找二进制文件
--------|-m 只找在说明文件manual路径下的文件
--------|-s 只找source来源文件
--------|-u 搜索不在上诉三个项目当中的其他特殊文件

whereis和locate是根据linux系统内记载了所有文件记录的一个数据库文件

locate [ir] keyword
--------|-i 忽略大小写
--------|-r 后面可以接正则表达式的显示方法

手动更新数据库updatedb

find [PATH] [option] [action] -a -o -a连接两个选项 -o或
1.与时间有关的选项-atime -ctime -mtime
	如:
	-mtime n: 在n天之前的一天之内被更改过内容的文件
	-mtime +n: 列出在n天之前（不含n）被更改过内容的文件
	-mtime -n: 列出在n天之内（含n)被更改过内容的文件 
	-newer file: file为一个存在的文件，列出比file还要新的文件
2.与使用者或用户组有关的参数
	-uid n: n为数字，即UID，
	-gid n: n为数字，即GID
	-user name: name为使用者的账户名称
	-group name: 用户组名
	-nouser: 寻找文件的拥有者不存在/etc/passwd 的人
	-nogroup: 寻找文件的用户组不在/etc/group的文件
3.与文件权限及名称有关的参数
	-name filename: 寻找文件名叫filename的文件
	-size [+-] SIZE: 寻找比SIZE还要大(+)或小(-)的文件
			c byte k 1024 bytes 
			eg：[-size +50k] 比50KB还要大的文件
	-type TYPE:一般正规文件f, 设备文件b,c 目录d 链接l 管道s FIFO p等属性	
	-perm mode: 寻找文件刚好等于mode的文件，如-rwsr-xr-x 4755
	-perm -mode: 寻找文件必须要全部包含mode权限的文件(以mode为基准增加0或多个属性)
	-perm +mode: 寻找文件包含任意mode权限的文件(2005后不在支持用--perm /mode替换)
4.额外的动作
	-exec command : command为其他命令 -exec 后面可以接command来处理结果
	-print : 默认动作，打印到屏幕

eg:
[root@www ~]# find / -perm /7000 -exec ls -l {} \;
# 注意到，那个 -exec 后面的 ls -l 就是额外的命令，命令不支持命令别名，
# 所以仅能使用 ls -l 不可以使用 ll 喔！注意注意！
解读:
{} 代表的是『由 find 找到的内容』，如上图所示，find 的结果会被放置到 {} 位置中；
-exec 一直到 \; 是关键字，代表 find 额外动作的开始 (-exec) 到结束 (\;) ，在这中间的就是 find 命令内的额外动作。 在本例中就是『 ls -l {} 』罗！
因为『 ; 』在 bash 环境下是有特殊意义的，因此利用反斜线来跳脱。


权限和命令间的关系
一：让使用者能够进入某个目录成为工作目录的基本权限	
可使用的命令：cd
目录所需权限：x
额外要求：如ls，则需要有r权限
二：使用者在某个目录内读取一个文件的基本权限
可使用的命令:cat,more,less等等
目录所需权限：x
文件所需权限：r
三：让使用者可以修改一个文件的基本权限
可使用的命令：nano或vi或vim
目录所需权限：x
文件所需权限：rw
四：让使用者可以创建一个文件的基本权限
目录所需权限：wx
五：让使用者进入某个目录并且运行该目录下的基本权限
目录所需权限：x
文件所需权限：x

========================================文件系统===============================================================
superblock:记录此文件系统的整体信息，包括inode/block的总量，使用量，剩余量，以及文件系统的格式和相关信息
inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码
block:实际记录文件的内容，若文件太大时，会占用多个block

磁盘碎片整理：因为文件写入的block太过于离散，此时文件读取的效能将会变得很差，这个时候通过碎片整理将同一个文件所属的blocks汇整在一起，加快读取速度

=======================================Ext2文件系统===========================================================
=======================================================================
data block(数据区块)
Ext2文件系统的限制如下
-----------------------------------------------------
|Block 大小	1KB	2KB	4KB		    |
|最大单一文件限制	16GB	256GB	2TB         |
|最大文件系统总容量	2TB	8TB	16TB	    |
-----------------------------------------------------
1.原则上，block的大小与数量在格式化完就不能够再改变了（除非重新格式化）
2.每个block内最多只能放置一个文件的数据
3.承上，如果文件大于block的大小，则一个文件会占用多个block数量
4.承上，如果文件小于block，则该block的剩余容量就不能再被使用了（磁盘空间会被浪费)
=======================================================================
=======================================================================
inode table(inode 表)
inode记录的文件数据至少包含:
1.该文件的存取模式rwx
2.该文件的拥有者和用户组owner/group
3.该文件的容量
4.该文件的创建或状态更改的时间ctime
5.最近一次的读取时间atime
6.最近一次的修改时间mtime
7.特殊文件的标志如setUID
8.文件真正内容的指向(block)

每个inode大小为128bytes(ext2系统)
每个文件只会占用一个inode
文件系统所能创建的文件数量和inode的数量有关
系统读取文件的时候需要先找到inode,并分析inode所记录的权限与用户是否符合，若符合才开始读取block的内容
=======================================================================
=======================================================================
Superblock(超级区块)
1.block和inode的总量
2.未使用和已使用的inode/block数量
3.block和inode的大小(block为1,2,4k，inode为128bytes)
4.文件系统的挂载时间，最近一次写入数据的时间，最近一次检验磁盘（fsck）的时候等文件系统的相关信息
5.一个valib bit数值，若文件系统已被挂载则为0，否则为1

利用dumpe2fs命令查看superblock
可能每个block group都含有superblock，但是一个文件系统应该仅有一个superblock而已，因为，其他的block group若含有的话，主要是为了第一个block group内的superblock的备份
=======================================================================
=======================================================================
Filesystem Description(文件系统描述说明)
描述每个block group的开始和结束的block号码，以及说明每个区段(superblock, bitmap, inodemap, data block)分别介于哪一个block号码之间，同样利用dump2fs查看
=======================================================================
=======================================================================
block bitmap(区块对照表)
利用位图算法来判断哪一个block可以用
inode bitmap(inode对照表)
利用位图算法来判断哪一个inode可以用
=======================================================================
=======================================================================
dumpe2fs[-bh] 设备文件名
--------|-b 列出保留为坏轨的部分（一般用不到）
--------|-h 仅列出superblock的数据

=======================================================================





新增一个文件时，文件系统的行为：
现根据用户对于新增文件的目录是否有wx权限，若有才能新增
根据inode bitmap查找没有使用的inode号码，并且根据umask将新文件的权限/属性写入
根据block bitmap查找没有使用的block号码，将实际的数据写入，并且更新inode里block指向数据
将刚写入的block和inode写入inode bitmap和block bitmap，并更新superblock的内容

superblock,inode bitmap, block bitmap 中间数据metadata
=======================================================================
在上古时期，没有日志，若发生数据不一致，需要检查中间数据（即superblock inodebitmap和blockbitmap）和实际数据的一致性，所以文件系统越大，时间越长
=======================================================================
日志式文件系统
1.预备：当系统要写入一个文件的时候，先在日志记录区块中记录某个文件准备要写入的信息
2.实际写入：开始写入文件的权限和数据,开始更新metadata的数据（509-513行的行为)
3.结束：完成数据和metadata更新后，在日志记录区块中完成该文件的记录
=======================================================================
系统会将常用的文件数据放置到内存的缓冲区，以加速文件系统的读写
可以手动使用sync来强迫内存中配置为dirty的文件（文件内容被修改）写入到硬盘里
若正常关机时，关机命令会主动执行sync来将内存的数据写入到硬盘中
若不正常关机，由于数据尚未写会到硬盘中，因此重启后可能会花很多时间进行磁盘检查，甚至可能导致文件系统的损坏
=======================================================================


df [-ahikHTm] [目录或文件名]
--------|-a 列出所有的文件系统，包括系统特有的/proc等文件系统
--------|-h 以人类较易读的方式gb，kb，mb
--------|-i 不使用硬盘容量，而以inode的数量来显示
--------|-k 以kB来显示各个文件系统
--------|-H 以M=1000K取代M=1024K
--------|-T 连同该分区的文件系统名称也列出来
--------|-m 以MB来显示各个文件系统

/dev/shm是利用内存虚拟出来的硬盘空间
1.访问速度快
2.关机后消失

du [-ahskm] 文件或目录名称
--------|-a 列出所有的文件和目录的容量，因为默认统计目录底下的目录量而已
--------|-h 以人类较易读的方式
--------|-s 列出总量，而不列出各个目录所占用的容量
--------|-S 不包括子目录下的统计
--------|-k 以kB
--------|-m 以mB

hard link的限制:
不能跨越文件系统
不能link目录

ln [-sf] 来源文件 目的文件
--------|-s 软连接，默认硬链接
--------|-f 如果目标文件存在，则主动将目标文件删除后在创建

fdisk [-l] 设备名称 <==制作分区
--------|-l 输出后面接的设备所有的分区内容，若仅有fdisk -l时，则系统将会把整个系统内能够搜索到的设备的分区均列出来
fdisk的限制：没有办法处理2TB以上的硬盘分区表

mkfs [-t 文件系统格式] 设备名称
--------|-t 如ext3, ext2, vfat等

mke2fs [-b block大小] [-i block大小] [-L 标头] [-cj] 设备
--------|-b 可以设置每个block的大小，1024,2048,4096bytes
--------|-i 多少容量给予一个inode
--------|-c 检查硬盘错误，仅使用一次-c时，会进行快速读取测试，如果-c -c 则会测试读写，较慢
--------|-L 标头名称，
--------|-j 加上journal

磁盘检查fsck,badblocks

fsck [-t 文件系统] [-ACay] 设备名称 （检验文件系统是否出错，数据将会放在lost+found）
--------|-t 如同mkfs根据-t选项调用不同的文件系统程序
--------|-A 根据/etc/fstab的内容，将设备进行扫描，通常启动过程中会运行这一命令
--------|-a 自动修复检查到的有问题的扇区
--------|-y 与-a类型，但是某些文件系统仅支持-y
--------|-C 显示检测进度
EXT2/EXT3的额外选项功能(e2fsck所提供)
--------|-f 强制检查！一般来说，如果fsck没有发现任何unclean的标志，不会主动进入细部检查
--------|-D 针对文件系统下的目录进行优化配置


badblocks [-svw] 设备名称	（用于检查硬盘或软盘扇区有没有坏轨）
--------|-s 在屏幕上列出进度
--------|-v 可以在屏幕上看到进度
--------|-w 使用写入的方式来测试，不建议使用，尤其是待检查的设备已有文件时


mount [-a] [-l] [-t 文件系统] [-L Label名] [-o 额外选项] [-n] 设备文件名 挂载点
--------|-a 依照配置文件/etc/fstab的数据将所有未挂载的硬盘都挂载上来
--------|-l 单纯的输入mount会显示目前挂载的信息，加上-l可以显示label名称
--------|-t 与mkfs的选项非常类似，可以加上文件系统种类来指定想要挂载的类型
--------|-n 在默认的情况下，系统会将实际挂载的情况实时写入/etc/mtab中,以利其他程序的运行，但是在某些情况下（如单人维护模式）为了避免问题，会可以不写入，此时就需要用-n
--------|-L 系统除了利用设备文件名之外，还可以利用文件系统的标头名称Label来挂载，最好为文件系统取一个独一无二的名称
--------|-o 后面可以接一些挂载时额外的参数，比如账号，密码，读写权限等
	    ro,rw: 挂载文件系统成为只读，或可读写
	    async,sync: 此文件系统是否使用同步写入sync或一部async的内存机制，请参考文件系统运行方式，默认为async
	    auto,noauto: 是否允许此分区被mount -a自动挂载
	    dev,nodev: 是否允许此分区上，可以创建设置文件
	    suid,nosuid: 是否允许此分区上拥有suid/sgid的文件格式
	    exec,noexec: 是否允许此分区上拥有可执行程序
	    user,nouser: 是否允许此分区让任何使用者运行mount，一般来说mount只有root可以运行，但有user参数时，则一般用户也可以进行mount对于此分区
	    defaults: rw,suid,dev,exec,auto,nouser,and async
	    remount: 重新挂载，在系统错误，或重新升级时使用
	    -o的参数以,间隔

umount [-fn] 设备或挂载点
--------|-f 强制卸载，可以用在类似于网络文件系统NFS无法读取的情况下 
--------|-n 不更新/etc/mtab下卸载

主要设备代码（major） 次要设备代码（minor)
eg: ll /dev/sda*
磁盘文件名	Major	Minor
/dev/hda	3	0~63
/dev/hdb	3	64~127
/dev/sda	8	0-15
/dev/sdb	8	16-31

当需要创建设备文件时
mknod 设备文件名 [bcp] [Major] [Minor]
--------|b 配置设备名称成为一个周边存储设备，如硬盘
--------|c 配置设备名称成为一个周边输入设备，如鼠标/键盘
--------|p 配置设备名称成为一个FIFO文件(管道文件)
Major: 主要设备代码
Minor: 次要设备代码

e2label 修改文件系统label(文件系统的label类似于win上面的C: d: E:)
e2label 设备名称 新的label名称

tune2fs [-jlL] 设备名称
--------|-j 将ext2转换为ext3文件系统
--------|-l 类似dumpe2fs -h将superblock内的数据读取出来
--------|-L 类似e2label修改设备的label

硬盘为IDE接口时使用hdparm,如果是SATA接口这个命令没有多大用途
hdparm [-icdmXTt] 设备名
--------|-i 将内核检测到的硬盘参数显示出来
--------|-c 配置32位存储模式，这个32位存储模式指的是在硬盘与PCI接口之间传输的模式，而硬盘本身依旧以16位跑的，默认情况下，这个配置值都会被使用
--------|-d 配置是否激活dma模式，-d1为启动，-d0为取消
--------|-m 配置同步读取多个扇区的模式，一般来说，配置此模式，可降低系统因为读取硬盘而损耗的性能，不过wd的硬盘则不建议配置，一般来说，配置为16/32为优化，不过wd硬盘默认是4/8,这个值的最大值可以用hdparm -i /dev/hda 输出的MaxMultSect来配置
--------|-x 配置UtraDMA模式，一般来说，UDMA的模式值加64即为配置值。并且，硬盘和主板芯片必须同步，所以，取最小的那个，一般来说
	33 MHz DMA mode 0~2(x64~x66)
        66 MHz DMA mode 3~4 (X67~X68)
        100MHz DMA mode 5   (X69)
        如果您的硬盘上面显示的是 UATA 100 以上的，那么配置 X69 也不错！
--------|-T 测试缓冲区cache的存取性能
--------|-t 测试硬盘的实际存取性能


/etc/fstab 是启动时的配置文件，不过，实际文件系统的挂载是记录到/etc/mtab与/proc/mounts这两个文件当中的

partprobe 更新分区表

制作swap分区 使用硬盘充当内存，暂时空出内存给更需要内存的程序使用
mkswap 设备名
free 查看系统中内存情况
swapon 使用交换分区

du查看某个目录所使用的容量

parted 分割2TB以上的分割槽
parted [设备] [命令 [参数]]
-------- 选项与参数：
	 命令功能:
	 新增分割: mkpart [primary][logical][extended] [ext3|vfat] 开始 结束
	 删除分割: rm [partition]
	 打印分割表: print


常见的压缩文件扩展名
*.Z		compress 程序压缩的文件
*.gz		gzip 程序压缩的文件
*.bz2		bzip2 程序压缩的文件
*.tar		tar 程序打包的数据，并没有进行压缩
*.tar.gz 	tar 程序打包的文件，其中并且经过gzip的压缩
*.tar.bz2	tar 程序打包的文件，其中并且经过bzip2的压缩

======================================压缩命令=========================
compress [-rcv] 文件或目录 (不再使用，而常用gzip，默认情况下压缩后源文件不见，压缩文件命名为basename.Z)
--------|-r 连同目录下的文件一同压缩
--------|-c 将压缩数据输出成为标准输出
--------|-v 可以展示出压缩后的文件信息以及压缩过程中一些文件名的变化
解压uncompress

------------------------
gzip [-cdtv#] 文件名 (压缩为*.gz)
--------|-c 默认情况将压缩的数据标准输出，可以通过重定向来处理到输出一个文件
--------|-d 解压缩的参数
--------|-t 可以用来检验一个压缩档的一致性，看文件有无错误
--------|-v 可以显示出源文件/压缩文件的压缩比等信息
--------|-# 压缩等级，-1最快但压缩比差，-9最慢但是压缩比好，默认-6

zcat 将解压的数据标准输出

bzip2 [-cdkzv#] 文件名
bzcat 文件名.bz2
--------|-c 将压缩的数据标准输出
--------|-d 解压缩
--------|-k 保留原始文件，而不会删除原始文件
--------|-z 压缩的参数
--------|-v 可以显示出压缩比等信息
--------|-# 同gzip，-9最佳

tar [-j|-z] [cv] [-f 创建的档名] filename <==打包与压缩
tar [-j|-z] [tv] [-f 创建的档名] <==查看档名
tar [-j|-z] [xv] [-f 创建的档名] [-C 目录] 解压缩
--------|-c 创建打包文件，可以搭配-v来观察过程中打包的档名filename
--------|-t 观察打包文件的内容含有哪些档名
--------|-x 解打包或解压缩的功能，可以搭配-C（大写）在特定目录解开
	    注意！！！-c,-t,-x不可同时出现
--------|-j 通过bzip2压缩或者解压缩,*.tar.bz2
--------|-z 通过gzip压缩或者解压缩，*.tar.gz
--------|-v 将正在处理的文件显示出来
--------|-f filename : -f后面要接要被处理的档名
--------|-C 目录: 在特定目录下解压

--------|-p 保留备份数据的原本权限和属性，常用于备份(-c)重要的配置文件
--------|-P 保留绝对路径,即运行备份数据中含有根目录存在
--------|--exclude=FILE 在压缩的过程中，不要将FILE打包

压缩:tar -jcv -f filename.tar.bz2 要被压缩的文件或目录
查询:tar -jtv -f filename.tar.bz2
解压缩:tar -jxv -f filename.tar.bz2 -C 想要解压到的文件目录
filename.tar.bz2为自己取的文件名
tar并不会主动产生文件

解压缩单独某个文件
tar -jxv -f filename.tar.bz2 等待解压缩的指定文件名

dump [-Suvj] [-level] [-f 备份档] 待备份数据
dump -W
--------|-S 仅列出后面的数据需要多少空间才能备份完
--------|-u 将这次dump的时间记录到/etc/dumpdates文件中(现在为/var/lib/dumpdates)
--------|-v 将dump的文件过程显示出来
--------|-j 加入bzip2的支持，默认压缩等级为2
--------|-level -0~-9十个等级
--------|-f 类似于tar，后面接产生的文件，也可以接设备名
--------|-W 列出/etc/fstab里面的具有dump配置的分区是否有备份过

当用dump备份目录时，-u level1~9不适用
使用restore恢复dump的备份

restore -t [-f dumpfile] [-h] 查看dump文件
restore -C [-f dumpfile] [-D 挂载点] 比较dump与实际文件
restore -i [-f dumpfile] 进入互动模式
restor -r [-f dumpfile] 还原整个文件系统
如同tar中-cx不能混用
--------|-t 此模式用在观察dump起来的备份文件中含有什么重要数据如同tar -t
--------|-C 列出dump文件内有记录的，且与目前文件系统不同的文件
--------|-i 可以仅还原部分文件，用在dump备份目录时
--------|-r 用在针对文件系统时全部还原
--------|-h 查看备份数据中inode和文件系统label等信息
--------|-f 后面接要处理的dump文件
--------|-D 与-C搭配使用，查看后面接的挂载点与dump内的不同文件

mkisofs [-o 镜像文件] [-rv] [-m file] 待备份文件.. [-V vol] \
> -graft-point isodir=systemdir ... <==制作镜像文件
--------|-o 后面接要产生的镜像文件名
--------|-r 通过Rock Ridge阐述支持Unix/linux的文件数据，可以记录较多的咨询
--------|-v 显示过程
--------|-m file 排除该文件类似exclude
--------|-V vol 创建Volume，类似win上文件管理里面看到的CD title
--------|-graft-point 将systemdir备份到isodir中

cdrecord -scanbus dev=ATA <==查询刻录机的位置
cdrecord -v dev=ATA:x,y,z blank=[fast|all] 抹除重复读写片
cdrecord -v dev=ATA:x,y,z -format 格式化DVD+RW
cdrecord -v dev=ATA:x,y,z [可用选项功能] file.iso
--------|-scanbus 扫描可用的刻录机，后续的装置为ATA界面
--------|-v 显示过程
--------|dev=ATA:x,y,z 后续的xyz为系统刻录机所在的位置
--------|blank=[fast|all] blank为抹除可重复读写的CD/DVD-RW,使用fast较快，all较完整
--------|-format 仅针对DVD+RW这个格式的DVD
-----------------------写入cd/dcd时使用
--------|-data 指定后面的文件以数据格式写入，而不是以CD音轨的方式写入
--------|speed=x 制定刻录速度
--------|-eject 指定刻录后自动退出光盘
--------|fs=Ym 指定多少缓冲内存
-----------------------写入dvd的选项
--------|driveropts=burnfree 打开buffer underrun free模式写入
--------|-sao 支持DVD-RW格式

dd if="input file" of="output file" bs="block size" count="number blocks"
将inputfile输出到outputfile，bs规定block的大小，count规定block的个数
if或of可以为设备名，复制的时候会将整个设备所有数据都复制，意味着包括文件系统,包括MBR与分区表，包括superblock，boot sector，meda data

cpio -ovcB > [file|device] <==备份
cpio -ivcdu < [file|device] <==还原
cpio -ivct < [filedevice] <==查看
--------|-o 将数据copy输出到文件或装置
--------|-B 让blosks可以添加至5120bytes

--------|-i 将数据自文件或设备copy出来到系统当中
--------|-d 自动创建目录
--------|-u 以较新文件覆盖旧文件
--------|-t 配合-i,观察

--------|-v 显示过程
--------|-c 新的便携式格式存储

vimtutor命令具有vim的操作说明
============================vim编辑器=================================
1.一般模式（进入后的默认模式)
2.指令模式:/?进入
3.编辑模式

----------------------------移动光标的方法-----------------------------
|h        光标向左移动一个字符					      |
|j  	  光标向下移动一个字符					      |
|k        光标向上移动一个字符					      |
|l 	  光标向右移动一个字符					      |
|n+[hjkl] 移动n个字符在对应方向					      |
|ctrl+f   向下移动一页Page down					      |
|ctrl+b	  向上移动一页Page Up					      |
|ctrl+d   向下移动半页						      |
|ctrl+u   向上移动半页						      |
|+	  光标移动到非空格符的下一行				      |
|-	  光标移动到非空格符的上一行				      |
|n<space> 光标向右移动n个字符					      |
|0或Home  移动到这一行的最前面字符处				      |
|$或End	  移动到这一行的最后面字符处				      |
|H        移动到这个屏幕的最上方那一行的第一个字符		      |
|M	  移动到这个屏幕的中央那一行的第一个字符		      |
|L	  移动到这个屏幕的最下方那一行的第一个字符	 	      |
|G	  移动到这个文件的最后一行				      |
|nG	  移动到第n行						      |
|gg	  移动到第一行						      |
|n<enter> 向下移动n行						      |
-----------------------------------------------------------------------
----------------------------搜索与替换---------------------------------
|/key	  向下寻找key字符串					      |
|?key	  向上寻找key字符串					      |
|n	  重复前一个搜索动作					      |
|N	  反向重复前一个搜索动作				      |
|:n1,n2s/word1/word2/g 	n1到n2行之间将word1替换成word2		      |
|			不完全匹配，即string若搜索/str会标记string    |
|:1,$s/word1/word2/g	第一行到最后一行将word1替换成word2	      |
|:1,$s/word1/word2/gc	给出提示是否要替换从第一行到最后一行的word1   |
-----------------------------------------------------------------------
---------------------------删除，复制与粘贴----------------------------
|x,X	  x删除光标的那个字符，X删除光标前的一个字符		      |
|nx       从光标起删除n个字符					      |
|dd	  删除光标所在这一行					      |
|ndd      删除光标开始的n行					      |
|d1G      删除光标所在到第一行的所有数据			      |
|dG       删除光标所在到最后一行的所有数据			      |
|d0       删除光标所在到该行的最前面那个字符			      |
|d$	  删除光标所在到该行的最后那个字符			      |
|yy       复制光标这一行					      |
|nyy      复制光标开始的n行					      |
|y1G      复制光标所在到第一行的所有数据			      |
|yG       复制光标所在到最后一行的所有数据			      |
|y0       复制光标所在到该行的最前面那个字符                          |
|y$       复制光标所在到该行的最后那个字符			      |
|p,P      p粘贴到光标后面，P则为光标前面			      |
|J        将光标所在行和下一行合并为一行                              |
|c        重复删除多个数据,cn[hjkl]				      |
|u	  撤销上一个动作					      |
|ctrl+r   恢复上一个动作					      |
|.        重复上一个动作                                              |
-----------------------------------------------------------------------
!!!!!!!! x d删除| y复制| p粘贴| u撤销| ctrl+r恢复| .重复|可以接0$nG
--------------------------进入插入或替换的编辑模式---------------------
|i,I	  i在光标所在位置插入，I在光标所在行首插入		      |
|a,A      a在光标后一个字符插入，A在光标所在行尾插入                  |
|o,O      o在光标所在行的下方另起一行，O则相反			      |
|r,R      r替换光标所在的那个字符，R从光标开始处一直替换到输出了ESC   |
-----------------------------------------------------------------------
--------------------------指令的存储和离开等---------------------------
|:w	  保存							      |
|:w!      强制写入，不过到底能不能取决于文件权限                      |
|:q       退出                                                        |
|:q!	  曾修改过文件但是不保留强制退出                              |
|:wq      储存后离开                                                  |
|ZZ       储存后离开						      |
|:w [filename] 另存为						      |
|:r [filename] 读取文件到光标所在行的后面			      |
|:n1,n2 w [filename] n1到n2行的内容另存为			      |
|:!command 暂时离开vim，执行command命令                               |
-----------------------------------------------------------------------
-------------------------区块选择的按键意义----------------------------
|v	  字符选择	 					      |
|V        行选择						      |
|ctrl+v   区块选择	 					      |
|y	  复制							      |
|d	  删除							      |
-----------------------------------------------------------------------
-------------------------多文件编辑的按键------------------------------
|:n       编辑下一个文件				              |
|:N	  编辑上一个文件					      |
|:files	  列出vim所开启的全部档案 	  			      |
-----------------------------------------------------------------------
-------------------------多窗口情况下的按键功能------------------------
|:vs [filename] 横向分屏					      |
|:sp [filename]	开启一个新窗口，若不加filename则同步显示(纵向分屏)    |
|ctrl+w+j	移动到下面的窗口				      |
|ctrl+w+k	移动到上面的窗口				      |
|ctrl+w+q	:q						      |
-----------------------------------------------------------------------

=========================vim 的环境设定参数============================
:set nu
:set nonu	就是设定与取消行号啊！
:set hlsearch
:set nohlsearch	hlsearch 就是 high light search(高亮度搜寻)。 这个就是设定是否将搜寻的字符串反白的设定值。默认值是 hlsearch
:set autoindent
:set noautoindent	是否自动缩排？autoindent 就是自动缩排。
:set backup	是否自动储存备份档？一般是 nobackup 的， 如果设定 backup 的话，那么当你更动任何一个档案时，则源文件会被另存成一个档名为 filename~ 的档案。 举例来说，我们编辑 hosts ，设定 :set backup ，那么当更动 hosts 时，在同目录下，就会产生 hosts~ 文件名的档案，记录原始的 hosts 档案内容
:set ruler	还记得我们提到的右下角的一些状态栏说明吗？ 这个 ruler 就是在显示或不显示该设定值的啦！
:set showmode	这个则是，是否要显示 --INSERT-- 之类的字眼在左下角的状态栏。
:set backspace=(012)	一般来说， 如果我们按下 i 进入编辑模式后，可以利用退格键 (backspace) 来删除任意字符的。 但是，某些 distribution 则不许如此。此时，我们就可以透过 backspace 来设定啰～ 当 backspace 为 2 时，就是可以删除任意值；0 或 1 时，仅可删除刚刚输入的字符， 而无法删除原本就已经存在的文字了！
:set all	显示目前所有的环境参数设定值。
:set	显示与系统默认值不同的设定参数， 一般来说就是你有自行变动过的设定参数啦！
:syntax on
:syntax off	是否依据程序相关语法显示不同颜色？ 举例来说，在编辑一个纯文本档时，如果开头是以 # 开始，那么该行就会变成蓝色。 如果你懂得写程序，那么这个 :syntax on 还会主动的帮你除错呢！但是， 如果你仅是编写纯文本档案，要避免颜色对你的屏幕产生的干扰，则可以取消这个设定 。
:set bg=dark
:set bg=light	可用以显示不同的颜色色调，预设是『 light 』。如果你常常发现批注的字体深蓝色实在很不容易看， 那么这里可以设定为 dark 喔！试看看，会有不同的样式呢！
======================================================================
文件换行符的区别
dos2unix [-kn] file [newfile] <==dos转unix
unix2dos [-kn] file [newfile] <==unix转dos
--------|-k 保留该文件原来的mtime时间格式（不更新文件上次内容更改的时间)
--------|-n 保留原始文件的旧档，将转换后的内容输出到新文件eg:dos2unix -n old new


iconv --list
iconv -f 原本编码 -t 新编码 filename [-o newfile]
--------|--list 列出iconv所支持的语系编码
--------|-f from,来源，后面接原本的编码格式
--------|-t to,新的编码格式
--------|-o file, 保留源文件，-o输出到新文件

======================================================================

===============================bash====================================
/etc/shells 记录了有几个可以用的shells
登录后会根据/etc/passwd文件的配置给我们一个默认的shell

alias 命令别名
eg:alias rm='rm -i'

=======================================
type [-tpa] name
--------| 显示name是内建命令还是外部命令
--------|-t file为外部命令，alias为别名，builtin为内建命令
--------|-p 为外部命令时，显示完整文件名
--------|-a 由PATH定义的路径下，将所有name的命令都列出来包括alias


变量作为左值直接使用
变量作为右值$var 或者${var}

变量名称只能是英文或者数字，不能以数字开头
''内特殊字符仅为一般的字符（纯文本）
""内特殊字符如$，可以保有原来的特性

\转义字符

$(command)或者`comman`率先执行命令

在为变量扩增内容时，注意使用"$变量"或者${变量}，因为直接使用会和后面的内容产生歧义，认为一同是变量名

export 使得变量成为环境变量
export后面不加变量名，会显示所有的环境变量
一般情况下，父进程自定义的变量无法给子进程使用，但是可以使用export
子进程仅会继承父进程的环境变量，而不会继承父进程的自定义变量

unset 取消变量

env 查看环境变量

常见的环境变量
HOME  		用户家目录
SHELL 		说明所使用的SHELL是哪一个程序
HISTSIZE	记录历史命令的个数
MAIL		使用mail命令收信时，会使用该MAIL变量来获取邮件信箱
PATH		运行文件搜索的路径，目录与目录直接以:间隔
LANG		语系数据
RANDOM 		随机数变量,可以获取0-32767之间
$ 		目前这个shell所使用的PID
?		命令的返回值
PS1		命令提示符
OSTYPE,HOSTTYPE,MACHTYPE:(主机硬件与核心等级)
-		set的配置

关于PS1的配置
\d		显示出星期 月 日 eg:"Mon Feb 2"
\H		完整的主机名
\h		主机名在第一个小数点之前的名字
\t		24小时[HH:MM:SS]
\T		12小时[HH:MM:SS]
\A		24小时[HH:MM]
\@		12小时[am/pm]
\u		使用者用户名
\v		BASH的版本信息
\w		完整的工作目录名，以根目录写起
\W		利用basename获取工作目录，所以只会列出最后一个目录名
\#		下达的第几个命令
\$		提示字符：root为#，否则为$



使用set查看所有变量（包含自定义变量)

locale -a 显示linux所支持的语系
locale 通过显示的结果可以确定修改哪一个变量
LANG=en_US                   <==主语言的环境
LC_CTYPE="en_US"             <==字符(文字)辨识的编码
LC_NUMERIC="en_US"           <==数字系统的显示信息
LC_TIME="en_US"              <==时间系统的显示数据
LC_COLLATE="en_US"           <==字符串的比较与排序等
LC_MONETARY="en_US"          <==币值格式的显示等
LC_MESSAGES="en_US"          <==信息显示的内容，如菜单、错误信息等
LC_ALL=                      <==整体语系的环境


语系文件放置在/usr/lib/locale/下

read [-pt] var   <==结果放在var这个变量
--------|-p 后面接提示符
--------|-t 等待的秒数

declare [-aixr] var
--------|-a 定义变量为数组
--------|-i 定义变量为整形
--------|-x 与export类似，将变量变成环境变量
--------|-r 设置为readonly，该变量不可被修改也不可以被unset
--------|+[aix] 取消对应变量的类型定义
--------|-p 打印变量的类型
变量的类型默认为字符串，bash的数值运算只能是int

数组元素作为左值var[index]
数组元素作为右值${var[index]}

ulimit [-SHacdfltu] [配额]  <==linux的一些限制
--------|-S soft limit,警告的配置，能超过这个值但是会有警告
--------|-H hard limit,不能超过这个配置
--------|-a 显示所有限制额度
--------|-c 限制core文件的大小
--------|-f 创建的文件最大容量，单位为KB
--------|-d 段错误容量
--------|-l 锁定lock的内存量
--------|-t 最大的cpu时间单位秒
--------|-u 单一用户最大进程数

变量的配置方法		说明
${变量#key}		若变量从头开始符合key，则删除最短的符合数据
${变量##key}		若变量从头开始符合key，则删除最长的符合数据
${变量%key}		若变量从尾向前符合key，则删除最短的符合数据
${变量%%key}		若变量从尾向前符合key，则删除最长的符合数据
${变量/old/new}		若变量内容符合old，则将第一个old替换成new
${变量//old/new}	若变量内容符合old，则将全部old替换成new

变量设置方式		str没有设置	str为空字符串	str已设置且不为空字符串
var=${str-expr}		var=expr	var=		var=$str
var=${str:-expr}	var=expr	var=expr	var=$str
var=${str+exprt}	var=		var=expr	var=expr
var=${str:+expr}	var=		var=		var=expr
var=${str=expr}		str=expr	str不变		str不变
			var=expr	var=		var=$str
var=${str:=expr}	str=expr	str=expr	str不变
			var=expr	var=expr	var=$str
var=${str?expr}		expr输出至stderr var=		var=$str
var=${str:?expr}	expr输出至stderr expr输出至stderr var=$str

${}上述都会导致var的变量变化除?

-的作用str没有设置var则为expr
=的作用str没有设置则str也为expr
+的作用是说str设置了则var=expr(与-相反)
?的作用与标准输出有关

:的作用是将str为空串视为没有设置

alias,unalias设置命令别名、取消命令别名

history [n]
history [-c]
history [-raw] file
--------|n 显示最近的n个命令
--------|-c 将目前shell中所有history内容都清空
--------|-a 将新增的history命令写入到file中，默认写入~/.bash_history
--------|-r 将file的内容读到shell的history记忆中
--------|-w 将history的内容写入到file中,默认~/.bash_history

!number
!command
!!
-------|number 运行第几个命令
-------|command 由最近的命令向前搜索以command开头的那个命令，并运行
-------|!!	运行上一个命令

-----------------------配置文件---------------------------------------

/etc/issue 决定了进站信息
/etc/issus.net 是提供给telnet这个远程登录程序使用的

issue内的代码意义
\d	本地端时间的年月日
\l	显示第几个终端机接口
\m	显示硬件的等级
\n	显示主机的网络名称
\o	显示域名
\r	操作系统版本(uname -r)
\t	本地端的时分秒
\s	操作系统的名称
\v	操作系统的版本

/etc/motd 决定了用户登录后，显示的信息

login shell以及non-login shell(不需要重复登录的举动，如在x window登录后启动终端)
login shell:流程1./etc/profile 系统整体的配置
		2.~/.bash_profile或~/.bash_login或~/.profile属于使用者个人配置


source 配置文件   <==加载配置文件

non-login shell:仅仅会读取~/.bashrc

/etc/man.config记录了man手册到哪里寻找

~/.bash_logout 注销bash后，系统做完什么后离开

stty [-a]  <==终端机的环境配置
--------|-a 列出所有参数

stty 配置项 配置值 <==配置特殊热键

set [-uvCHhmBx]  <==配置整个命令的输入输出环境
--------|-u 默认不激活，激活后，使用没有配置的变量报错
--------|-v 默认不激活，激活后，若信息被输出前，会显示信息的原始内容
--------|-x 默认不激活，激活后，会显示命令的内容前面有++符合
--------|-h 默认激活，与历史命令有关
--------|-H 默认激活，与历史命令有关
--------|-m 默认激活，与工作管理有关
--------|-B 默认激活，与[]的作用有关
--------|-C 默认不激活，使用>时，若文件存在则不会被覆盖


/etc/inputrc 按键的配置

通配符
*	匹配0到无穷个任意字符
?	匹配一个任意字符
[]	如[abcd]则abcd任选一个
[-]	如[0-9]，0-9直接的所有数字
[^]	取反,如[^abc] ，不是abc即可

bash环境下的特殊符号
#	注释，最常用在script中
\	转义字符
|	管道
;	命令分割,eg: echo h ; ls
~	用户的家目录	
$	获取变量的值（右值）
&	将命令变成后台下工作
!	not取反
/	路径的分隔符
>,>>	输出重定向，输出与累加
<,<<	输入重定向
''	不具有让特殊字符具有特殊含义
""	能让特殊字符有特殊含义
``	率先运行可以用$(command)替换
()	中间为子shell的起始与结束
{}	中间为命令区块的组合

stdin: 0, 使用<或<<
stdout: 1, 使用>或>>
stderr: 2, 使用2>或2>>

若要将stdout和stderr输出到一个文件则使用> file 2>&1 
/dev/null 可以抹掉任何导向这个设备的信息

<<代表的是结束的输入字符
eg:cat > catfile << "eof"
当输入了eof则代表输入结束，而不需要输入ctrl+d


cmd;cmd (不考虑命令的关联性)
cmd&&cmd2 cmd成功（$?=0)则运行cmd2
cmd||cmd2 cmd失败($?!=0)则运行cmd2

|管道只能处理stdout，而不能处理stderr
将上个命令的stdout作为下一个命令的stdin

cut -d'分隔符' -f fields <==用于有特殊分隔符
cut -c 字符区间   <==用户排列整齐信息
--------|-d 后面接分隔符，与-f一起使用
--------|-f 依据-d的分隔符分割后，用-fn取出第n段，n以,间隔如n1,n2取出n1和n2
--------|-c 以字符为单位取出n1-n2之间的字符
cut 用于处理同一行里面的数据分解

grep [-acinv] [--color=auto] '搜索的字符串' filename
--------|-a 将二进制文件以text的文件格式搜索
--------|-c 统计找到的字符串的次数
--------|-i 忽略大小写
--------|-n 输出行号
--------|-v 反向搜索
--------|--color=auto 关键字高亮显示
该行有关键字时grep会显示整行

sort [-fbMnrtuk] [file or stdin]
--------|-f 忽略大小写
--------|-b 忽略最前面的空格符部分
--------|-M 根据月份的名字来排序
--------|-n 用数字排序（默认是文本排序)
--------|-r 反向
--------|-u uniq,相同的数据，仅出现一行
--------|-t 分隔符，默认[tab]
--------|-k 以那个区间field来排序，与-t连用，-t划分几个段后，以-k n这个第n段来排序

uniq [-ic] <==去重(需要先排序,才能达到去除重复的效果)
--------|-i 忽略大小写
--------|-c 计数


wc [-lwm] (结果为行数 字数 字符数)
--------|-l 仅仅列出行
--------|-w 仅仅列出字（英文单词）
--------|-m 多少字符

tee [-a] file <==处理标准输入，将标准输出可以在输出至屏幕的同时输出至文件
--------|-a 追加的方式

tr [-ds] SET1 ... (删除或替换) <==处理标准输入
--------|-d 删除set1这个字符串
--------|-s 取代掉重复的字符

col [-xb] <== 一般用于替换tab
--------|-x 将tab替换成对等的空格数
--------|-b 有/时，仅保留反斜杠最后接的那个字符

join [ti12] file1 file2
--------|-t 设置分隔符号,默认空格，并且比对第一个字段的数据，如果两个文件相同，则将两个文件数据连成一行,相同字段会放置在行首
--------|-i 忽略大小写
--------|-1 第一个文件要用哪个字段来分析
--------|-2 第二个文件要用哪个字段来分析

paste [-d] file1 file2
--------|-d 设置分隔字符，默认[Tab]
--------|- 如果file部分替换成-，代表数据来自标准输入

expand [-t] file <==将tab用空格替换 <==unexpand则相反
--------|-t 空格的数目n

split [-bl] file PREFIX
--------|-b 想要分隔的文件大小，单位可以设置为b,k,m等
--------|-l 后面接行数,以行数来分隔
--------|PREFIX 代表前导符的意思，可作为分隔文件的文件名的前缀字符

!!!!!!!!!!!!关于-的作用，会被当做stdin或stdout
eg:tar -cvf - /home | tar -xvf -
-作为tar -cvf的标准输出 ，后面的-作为标准输入

xargs [-Oepn] command <== 以stdin的数据默认根据空格分隔成command的参数,command会使用原始命令，即不用alias
--------|-O 如果输入的stdin含有特殊字符，如',\，空格等，则可以将它还原成一般字符
--------|-e 替换EOF，后面接一个字符串，当输入该字符串时代表eof
--------|-p 运行每个参数的命令时，询问
--------|-n 后面接次数，每次command命令要用几个参数的意思
xargs没有接收任何command时默认echo

finger获取账号的相关信息，后面接用户名


