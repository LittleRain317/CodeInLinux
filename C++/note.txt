<regex>
!!!需要注意c/c++字符串中\本身需要转义


给符号型变量赋予一个超出它的表示范围的行为是未定义的
如
signed char ch = 256;//未定义行为

初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值抹去，而以一个新的值代替

c++11中允许使用花括号初始化基本类型的变量
如
int i{0};
在列表初始化中将大类型的变量赋予给小类型变量
如
long double ld = 3.1415926535;
int a{ld}; //将会警告处理(g++) c++标准中指出该行为禁止 
//以下是c++原文
//list-initialization limits the allowed implicit conversions by prohibiting the following:

conversion from a floating-point type to an integer type
conversion from a long double to double or to float and conversion from double to float, except where the source is a constant expression and overflow does not occur
conversion from an integer type to a floating-point type, except where the source is a constant expression whose value can be stored exactly in the target type
conversion from integer or unscoped enumeration type to integer type that cannot represent all values of the original, except where source is a constant expression whose value can be stored exactly in the target type

引用不是对象

const是对给定类型的修饰试做(type)const;
如
typedef char * pChar;
const pChar p1; //等价于char * const p1;

auto推断类型的时候一般会忽略掉顶层const而保留底层const
对于auto &则会保留
如
#include <iostream>
#include <typeinfo>
using namespace std;
int main(void)
{
	const int i = 42;
	auto j = i;//j的类型为int;
	j = 10;//成立
	const auto &k = i;//k的类型为const int
	k = 10;//成立
	auto *p = &i;//p的类型为const int *
	*p = 23;
	--p;//成立
	const auto j2 = i, &k2 = i;//j2的类型为const int, k2的类型为const int
//cout << decltype(j) << endl;
	j2 = 10;
	k2 = 10;
//	cout << typeid(j).name() << endl;
//	cout << typeid(k).name() << endl;
//	cout << typeid(p).name() << endl;
//	cout << typeid(j2).name() << endl;
//	cout << typeid(k2).name() << endl;
	return 0;
}

decltype(c++11引入推测表达式类型)和auto在处理引用和const有所不同
decltype会保持const（包含顶层)
当decltype(expression)中expression可以为左值时将返回一个引用类型
特例:因为普通变量能够作为左值当想使用该变量的引用时需要加()修饰否则默认为该变量类型
特例:因为赋值语句是会产生引用的一类典型的表达式，所以结果仍需加上&

getline读取一整行时不会残留空白符（将空白符删除），并且会读取上一次缓冲区中残留的空白符，当遇到空白符时会继续读取
cin读取一整行时会残留空白符，并且会过滤开头缓冲区中的空白符，当遇到空白符时结束读取


vector的使用心得
当使用vector无法确认执行列表初始化后，编译器会尝试使用默认初始化vector对象
因此在实际编程时应该注意花括号的使用，注意匹配初始值和T的类型是否相同

注意:范围for语句体内不应该改变其所遍历序列的大小,范围for运用了容器中的begin()以及end(),在使用范围for的时候应该注意推测容器中的元素类型


容器为空时，begin()和end()返回的结果相同，都是尾后迭代器
因为end()返回的指向并不确定所以不能自增或者自减
标准容器中绝大多数没有重载<和[]因此应该尽可能使用迭代器以及！=
凡是使用了迭代器中的循环体，都不要向迭代器所属的容器添加元素

数组名存在隐式转换所以利用auto推断类型的时候会导致结果为指针


但用decltype则会得到数组类型, 因此在多层循环处理数组的数组的时候，应该加上&或者用decltype，这样数组名便不会隐式转换

在string转c风格字符串的时候应该注意拷贝副本，否则修改string的时候会导致c风格字符串一同修改
如:
  1 #include <string>
  2 #include <cstring>
  3 #include <iostream>
  4 #include <cctype>
  5 using namespace std;
  6 int main(void)
  7 {       
  8         string str = "hello";
  9         const char * cStr = str.c_str();
 10         cout << cStr << endl;
 11         for (auto & it : str)
 12                 it = toupper(it);
 13         cout << str << endl;
 14         cout << cStr << endl;
 15         return 0;
 16 }
//运行结果为hello
HELLO
HELLO

关于符号位如何处理没有明确规定，所以建议使用位运算时应该使用无符号类型

sizeof(expr)不会对表达式进行求值所以可以使用指针非法访问,但不建议,sizeof(array)中不会让数组名隐式转换为指针

当数组被用作decltype,&,sizeof,typeid,&引用时不会隐式转换为指针

使用try catch throw处理异常

g++ -c只编译

在赋值时会忽略掉顶层const,解释如下int * const p = &a;
int * p2 = p;//仅仅是p不能修改指向，与p2无关

省略符形参是c++访问c代码而设置的，不进行类型检查

initializer_list中对象永远是常量不应该去修改

在实现方法时应写出所有路径下的返回情况，如果没有很多程序可能错误，编译器有可能无法发现此类错误

方法将引用作为返回值，其结果为左值
const type &能够被字面值赋值,同时可以存在隐式转换
如:
可以写出const string & s = "fweeg";const double & d = i(i为int类型);这个时候编译器会构造出一个临时类型的temp让const类型的引用指向这个临时值
而不能写出string & s = "fewg";double & d = i;

当设计默认形参时应该让不怎么使用默认值的形参放置前面，而经常使用默认值的形参放后面

inline只是向编译器发送一个请求，编译器可以选择忽略

assert常用于开发阶段在发布时可#define NDEBUG忽略assert,使用assert有助于调戏信息

常量对象只能调用常量成员函数,因为非常量成员函数的this类型为
type * const ，而常量对象的this为const type * const

编译器先编译类成员的声明然后才编译成员函数，因此成员函数不关心类成员声明的先后顺序,编译器处理完类中的全部声明后才会处理成员函数的定义

在使用按值传递调用参数时或者初始化对象时会调用拷贝构造函数
而在使用赋值运算符时会调用=重载

inline成员函数应该和类的定义放在一起

友元函数可以定义在类的内部，会隐式内联
友元可以是普通函数，可以是类成员函数，可以是类
友元分为友元声明，需要单独作函数声明，友元声明仅仅是对访问权限的影响，尽管有的编译器并不强制要求再次函数声明，但也应该进行函数声明

类的作用域决定了需要用::作用域访问符号来确认类型
如：
pos Screen::size() const
{
	return height * width;
}//pos被定义在Screen中，因此需要加上作用域声明符号
正确格式
Screen::pos Screen::size() const
{
	return height * width;
}

explicit抑制构造函数定义的隐式转换,explicit可以修饰构造函数但一般只用于修饰形参"只有一个"(因为可以用默认参数导致看似多个形参列表的变为一个形参)的，因为存在多个形参时不会发生隐式类型转换

inline可以在声明处写或是定义时写
而explicit只能在声明时写 static也只能在声明时写,
const则需要在声明和定义时同时写以保证类型的匹配

类的类型隐式转换时将会转换成const的类型

constexpr函数能拥有的唯一可执行语句就是返回语句
static函数体内不能使用this指针，并且只和类关联因此不能声明为const

static成员不能使用类内初始值来初始化也不能由类的构造函数进行初始化，只能在类外定义如同全局变量,若需对static成员进行初始化而需要static const 
或static constexpr(
但static const成员类内初始化时只能定义static const int 类型的成员
并且只能用整形字面值或是可以隐式转换成整形的字面值，
或用static constexpr成员来对static const int 成员进行类内初始化,而static constexpr则没有这种限制
如static const int name = 4.6;
如static const int name = 4;
如static constexpr double rate = 6.5;
static const int name = rate;
)
static constexpr例子:
static constexpr double rate = 6.5;//编译成功

若该静态成员仅仅用于编译器可以替换它的情况，则无需在类外定义，否则则需在类外再次定义，因为在出现编译器不把const static仅仅作为文本替换时，会导致无法找到该成员的定义语句.

需要把const static或constexpr static成员作为函数的参数时（即编译器不把它作为文本替换时，将会出现无法找到定义语句的错误)，因此需要再次在类外单独定义const staitc成员，但不应该提供初始值（类内提供初始值)

static成员与普通成员的区别:
1.可以使用在不完全类型中,如前置声明后使用static type name//通过
type * pName;//通过
type & reName;//通过
type name;//错误
2.可以将static成员作为默认参数


static成员定义应该与非内联函数的定义放在同一个文件即都放在实现文件中

一个输出流可能被关联到另外一个流，这种情况下当读写关联流的时候，关联到的流的缓冲区会刷新，因为关联到的流与流缓冲（ rdbuf() ）所控制的输出序列同步，即在任何 *this（关联流） 上的输入/输出操作前，在关联到的流上调用 flush() 。
如:
#include <iostream>
#include <fstream>
#include <string>
 
int main()
{
    std::ofstream os("test.txt");
    std::ifstream is("test.txt");
    std::string value("0");
 
    os << "Hello";//此时Hello留在文件输出缓冲区中，还未写入到文件中
    is >> value;//读取失败
 
    std::cout << "Result before tie(): \"" << value << "\"\n";
    is.clear();//恢复状态位
    is.tie(&os);//将is关联到os
 
    is >> value;//因为对is进行读操作且is关联到os，因此os的缓冲区将被刷新，隐式调用flush()，此时hello才写入到文件中，因此is才能够开始读取
 
    std::cout << "Result after tie(): \"" << value << "\"\n";
}

在c++11标准之前，文件名只能是c风格字符串或者字符数组,从11后可以用string作为文件名

当文件流对象被销毁时，会自动调用close

list的迭代器不允许比较大小<>

对于一个接受容器作为参数的构造函数来说，需要严格遵守容器类型和所装类型一致，array在此基础上需要大小一致
而对于接受两个迭代器作为参数的构造函数来说，只需要迭代器所指向的对象能够转换成容器所装的类型即可

除array外，swap不对任何元素进行拷贝，删除或插入操作，除string外，指向容器的迭代器，引用，和指针在swap操作之后都不会失效（尾后迭代器除外），他们仍然指向swap操作之前的那些元素，但是在swap交换之后，这些元素不属于之前的容器了
如假定iter在swap操作之前指向svec1[3]的string那么在操作之后指向svec2[3]的元素。除array外swap操作元素本身没有被替换，只是交换了两个容器的内部数据结构

容器赋值时允许使用花括号进行赋值，但需要注意的是容器类型需要相同，大小可以不同（唯独array不行，因为大小作为array类型的一部分)
可以使用assign方法赋值容器的一部分内容，或者不相同类型容器但元素可以互相转换的

向容器中插入元素或者初始化或者赋值是进行元素的拷贝
容器的emplace方法是对元素的构造而非拷贝，因此参数类型需要匹配容器拥有的构造函数

支持随机访问的容器才支持下标访问和at方法
容器list,forward_list

所有适配器都要求容器具有添加和删除的功能

拷贝构造函数第一个参数是自身类类型的引用，且其他额外参数都有默认值，而且一般参数为const类型

()直接初始化
=拷贝初始化
赋值运算符通常应该返回一个指向其左侧运算对象的引用

析构函数首先执行函数体，然后按照初始化逆序销毁,但是这并不会调用delete,也就意味着若不在函数体中执行delte会发生内存泄露

当需要析构函数时，几乎可以肯定一定需要自定义拷贝赋值运算符和拷贝构造函数

当需要拷贝或者赋值时，不一定需要析构（也就是不一定存在释放内存的操作），但拷贝或者赋值基本是成对出现

可以对任何成员函数指定=delete
析构函数不应该用=delete因为如果析构函数被删除，则对象将无法销毁,虽然无法定义这种的局部对象，但是可以动态分配，然而无法delete
当类内的成员不能默认构造，赋值，拷贝，销毁时，其对应的成员函数将会被定义为删除的
在重载=的时候，正确工作是应该能让自身赋予自身，一个好的解决方法是先拷贝右侧运算对象，然后销毁左侧运算对象



如何类定义了swap成员函数则通用算法algorithm将会使用该定义的swap，否则使用标准库的swap

inline不只适用于成员函数

对于分配了资源的类，自己重载swap只交换指针内容将会得到性能上的优化
使用拷贝(即传参数时使用拷贝构造函数，也就是传参数时没有使用引用而是直接使用了值)和交换(使用自己写的swap函数，该函数仅仅交换行为为值的成员的指针)的赋值运算符自动就是异常安全的，且能正确处理自赋值

当拷贝赋值运算符通常需要做拷贝构造函数以及析构函数需要做的工作时，通常情况下公共的工作应该放在private的工具函数中完成

泛型算法
accumulate求和 需要注意的是第三个参数决定了accumululate使用何种+运算
equal相等 需要注意的是那些只接受单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长
fill填充制定范围
用一个单一迭代器表示第二个序列的算法都假定第二个序列至少与第一个序列一样长，确保算法不会试图访问第二个序列中不存在的元素是程序员的责任
fill_n填充制定个数

back_inserter接受一个容器的引用，返回一个与该容器绑定的插入迭代器
copy复制
replace替换
replace_copy替换复制到制定序列
sort排序
unique去重复 需要注意使用该算法，相邻的重复元素将被"删除",它仅仅是覆盖相邻的重复元素，unique返回的迭代器指向最后一个不重复之后的位置，这个位置之后的元素仍然存在，但我们不知道它们的值是什么

标准库算法对迭代器操作而不是容器操作，因此，算法不能（直接）添加或删除元素
stable_sort是以升序排序范围内的元素，保证保持等价元素的序列
partition划分
stable_partition
find_if返回第一个使得谓词返回非0值的元素
count_if返回谓词为真的次数

lambda表达式
[capture list] (parameter list) -> type {function body}
lambda表达式不能有默认参数
一个lambda表达式只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量
捕获列表只用于局部非static变量，lambda可以直接使用局部static变量和在它所在函数之外声明的名字
对于值捕获，是在lambda创建时拷贝，而非是调用时拷贝，因此随后对其值进行修改不会影响到lambda内对应的值
对于引用捕获，必须保证在lambda执行时变量是存在的
当我们混合使用隐式捕获和显示捕获时，捕获列表中的第一个元素必须是=或&
如果一个lambda体包含return之外的renhe语句，则编译器假定此lambda返回void

头文件functional
bind可以视为一个通用的函数适配器，它接受一个可调用对象，生成一个心得可调用对象来适应原来对象的参数列表
auto newCallable = bind(callable, arg_list);plachholders的名字空间里有_n
ref函数返回参数的引用

迭代器的种类
插入迭代器 流迭代器 反向迭代器 移动迭代器
插入迭代器:
back_inserter;
front_inserter;
inserter;
只有在当前容器支持相关操作的时候，才可以使用对应的迭代器

插入迭代器与流迭代器ostream_iterator都支持解引用，前后置自增，但每个运算符都返回本身

不可在forword_list或者流迭代器中创建反向迭代器
反向迭代器(reverse_iterator)与原来的迭代器会生成相邻的位置而非同一个位置
反向迭代器存在物理位置和逻辑位置，实际运用时应该以逻辑位置为准

输入迭代器（输入：向算法中输入):可以读取序列中的元素，可以比较逻辑等与不等，可以递增，解引用为“右值”
输出迭代器恰恰与输入迭代器相反属性（可视为补集)
前向迭代器双向迭代器
随机访问迭代器还支持：下标运算（做差和[])

通用算法的一般规则
向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据，接受单独beg2的算法都假定从beg2开始的序列至少和begin,end的范围一样大(如copy):
重载版本(谓词和运算符)  _if版本 _copy版本
